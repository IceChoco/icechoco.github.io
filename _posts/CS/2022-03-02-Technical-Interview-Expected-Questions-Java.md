---
title: '[CS] 기술면접 예상 질문 - JAVA, DB'
layout: post
categories: cs
tags: cs
comments: true
---

기술면접 단골질문

### 1.객체 지향 프로그래밍 OOP(Object Oriented Programming)?
Object를 기준으로 코드를 나누어 구현하는 프로그래밍(Java는 구분 단위가 class)
- 장점: 재사용성이 좋고, 협업하기가 좋다 (캡슐화, 추상화 때문에 쓰기 좋음)  

1) **캡슐화**: 비슷한 역할을 하는 속성과 메소드들을 하나의 클래스로 모은 것  
2) **추상화**: 어떤 실체로부터 공통적인 부분이나 관심있는 특성들만 한곳에 모은 것  
  ex) 어떤 하위 클래스들에 존재하는 공통적인 메서드를 인터페이스로 정의하는 것  
3) **상속**: 클래스를 재사용하는 것, 상속이 있기 때문에 코드를 재활용 할 수 있고 그렇기 때문에 생산성이 높고 유지보수하기 좋음  
4) **다형성**

### 2.오버로딩과 오버라이딩의 차이
1) 오버라이딩
 - 부모 클래스에게 상속받은 메소드를 자식클래스에서 재정의 하는 것  

2) 오버로딩
 - 한 클래스내에 이름이 같은 여러개의 메서드를 재정의하는 것
 - 메서드 시그니처가 다름

### 3. Spring Boot와 Spring의 차이점이 뭔가요?
-	Spring: 자바 엔터프라이즈 어플리케이션 개발을 편리하게 해주기 위한 프레임 워크.
     	스프링을 사용하면 의존성 주입, DI 컨테이너 제공으로 다형성과 OCP, DIP(의존 관계 역전 원칙)를 지키며 좋은 객체 지향을 설계할 수 있도록 지원합니다.
-	Spring Boot: 이러한 스프링을 최소한의 설정으로 단독 실행 가능하고, 제품 수준의 스프링 기반 애플리케이션을 만들 수 있도록 쉽게 스프링을 쓸 수 있게 제공해주는 툴.
     	스프링 부트가 다루는 영역: 대표적으로 간편하고 자동화된 설정과 표준화된 라이브러리를 제공하며 빌드, 빌딩, 배포 및 관리 등 어플리케이션 개발 관련 거의 모든 분야에서 도움을 줌.

### 4. JVM의 구조
- 자바 가상 머신의 약자를 따서 줄여 부르는 용어
- JVM의 역할은 자바 애플리케이션을 클래스 로더를 통해 읽어 자바 API와 함께 실행하는 것
- 메모리 관리(GC)을 수행하며 스택기반의 가상머신입니다.
- 구조: Class Loader, 실행 엔진, Runtime Data Area, JNI, Native Method Library
  1) 클래스 로더: JVM내로 클래스를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈
  2) 실행 엔진: 바이트 코드를 실행시키는 역할
     - 인터프리터: 바이트 코드를 한줄씩 실행합니다.
     - JIT 컴파일러
       - 인터피르터 효율을 높이기 위한 컴파일러
       - 인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러가 반복되는 코드를 네이티브 코드로 바꿔줍니다.
       - 그 다음부터 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용합니다.
     - GC(Garbage Collector): 가비지 컬렉터로 힙 영역에서 사용되지 않는 객체들을 제거하는 작업을 의미합니다.
  3) Runtime Data Areas: 프로그램 실행 중에 사용되는 다양한 영역입니다.
    - PC Register: Thread가 시작될 때 생성되며 현재 수행 중인 JVM 명령의 주소를 갖고 있습니다.
    - Stack Area: 지역 변수, 파라미터 등이 생성되는 영역. 실제 객체는 Heap에 할당되고 해당 레퍼런스만 Stack에 저장됩니다.
    - Heap Area: 동적으로 생성된 오브젝트와 배열이 저장되는 곳으로 GC의 대상 영역입니다.
    - Method Area: 클래스 멤버 변수, 메소드 정보, Type 정보, Constant Pool, static, final 변수 등이 생성됩니다. 상수 풀(Constant Pool)은 모든 Symbolic Reference를 포함하고 있습니다.
  4) JNI (Java Native Interface)
    - 자바 애플리케이션에서 C, C++, 어셈블리어로 작성된 함수를 사용할 수 있는 방법을 제공
    - Native 키워드를 사용하여 메서드를 호출합니다.
    - 대표적인 메서드는 Thread의 currentThread()입니다.
  5) Native Method Library: C, C++로 작성된 라이브러리입니다.

### 5. JAVA의 실행방식
- 자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어 자바 바이트코드(.class)로 변환시킵니다.
- Class Loader를 통해 class 파일들을 JVM으로 로딩합니다.
- 로딩된 class파일들은 Execution engine을 통해 해석됩니다.
- 해석된 바이트코드는 Runtime Data Areas에 배치되어 실질적인 수행이 이루어집니다.

### 6. GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.
- https://icechoco.github.io/java/2021-12-07-Java-reference-and-GC/

### 7. 컬렉션 프레임워크에 대해서 설명해주세요.
- 널리 알려져 있는 자료구조를 바탕으로 객체, 데이터들을 효율적으로 관리할 수 있는 자료구조들이 있는 라이브러리를 컬렉션 프레임워크라고 합니다.
- List, Set은 Collection 인터페이스을 상속받지만, Map 인터페이스는 구조상의 차이라 별도로 정의합니다.

### 8. 제네릭에 대해서 설명해주세요.
- 클래스 내부에서 사용할 데이터의 타입을 나중에 인스턴스를 생성할 때 확정하는 것
- 타입만 다르고 소스의 구조가 같은 경우 타입이 안전하다는 장점이 있으나, 소스가 중복된다는 단점이 있음
- 타입이 안전하면서도 소스코드의 중복성을 제거하기 위해 제너릭이 등장함
- 제너릭으로하면 모든 객체가 모두 들어올 수 있다는 문제가 있는데, 이럴 땐 상속을 이용해 제너릭에 제한 조건을 줄 수 있다.

### 9. 애노테이션에 대해서 설명해주세요.
- 인터페이스를 기반으로 한 문법으로 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있습니다.
- built-in annotation은 상속받아서 메소드를 오버라이드 할 때 나타나는 @Override 애노테이션이 그 대표적인 예
- 메타 애너테이션은 애노테이션을 선언할 때 사용하는 애노테이션입니다.
  •	@Retention: 애노테이션 유지 범위를 지정합니다. (소스, 클래스, 런타임)
  •	@Inherit: 애노테이션을 하위 클래스까지 전달여부를 지정합니다. 이 애노테이션이 있으면 하위 클래스까지 상속이 가능합니다.
  •	@Target: 해당 애노테이션을 어디에 사용할 지 결정합니다. (타입, 필드, 메서드, 파라미터, 생성자, 로컬변수, 애노테이션 타입)

### 10. 오버라이딩과 오버로딩이 무엇이며 어떤 차이?
1) 오버라이딩
   - 부모 클래스에게 상속받은 메소드를 자식클래스에서 재정의 하는 것
   - 메서드 선언에만 달 수 있다.
   - 상위 클래스나 상위 인터페이스의 메서드를 재정의 했음을 뜻한다.
   - 런타임의 다형성이기도 함  
   - 재정의하려는 모든 메서드에 @Override 애너테이션을 사용하는 것이 좋음  
     → 컴파일러가 매개변수 타입 오류 또는 오타로 인한 실수를 잡아주면서 버그들을 예방해준다.  
     → 디폴트 메서드를 지원하기 시작하면서, 인터페이스 메서드를 구현한 메서드에도 @Override를 다는 습관을 들이면 시그니처가 올바른지 재차 확신할 수 있다.  
     → 예외) 구체클래스에서 상위 클래스의 추상메서드를 재정의 한 경우 애너테이션을 달지 않아도 된다. 하지만 헷갈리지 않기 위해서 이 경우에도 @override 애네터이션을 추가해주는 것이 좋다고 생각한다.  

2) 오버로딩
   - 한 클래스내에 이름이 같은 여러개의 메서드를 재정의하는 것
   - 메서드 시그니처가 다름
   - 컴파일 타임의 다형성이기도 함
   - 오버라이딩 될 수 있음  

[참고: [Effective Java] Day 26 - Item 40 :: @Override 애너테이션을 일관되게 사용하라](https://icechoco.github.io/java/2022-01-02-Effective-java-Day26-item40/)

### 11. 인터페이스와 추상클래스의 차이점
- 추상클래스
  - 객체의 추상적인 상위 개념으로 공통된 개념을 표현할 때 사용
  - 단일 상속만 가능
  - 추상클래스를 상속하는 집합간에는 연관관계가 있음
- 인터페이스
  - 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용
  - 다중 상속이 가능
  - 인터페이스를 구현하는 집합간에는 관계가 없을 수 있음

### 12. 클래스는 무엇이고 객체는 무엇인가요?
- 클래스: 객체를 정의하는 틀 또는 설계도와 같은 의미
 - 객체
   - 식별 가능한 개체 또는 사물.
   - 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가짐
   - 인스턴스들을 통칭하는 용도로 사용

### 13. 정적(static)이란 무엇인가요?
- static은 클래스 멤버라고 하며, 클래스 로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리됨
- static 키워드를 통해 생성된 정적멤버들은 Permanent(1.7까지) 또는 heap영역(1.8 이후)에 저장
- 저장된 메모리는 모든 객체가 공유하며 하나의 멤버를 어디서든지 참조할 수 있음
- 그러나, 1.7 버전까지는 GC의 관리 영역 밖에 존재하기 때문에 프로그램 종료시까지 메모리가 할당된 채로 존재
- 너무 남발하게 되면 시스템 성능에 악영향을 줄 수 있음
- 단 1.8 이후부터는 static Object가 heap영역으로 바뀌면서 참조를 잃은 경우 GC의 대상이 될 수 있음


## DB
### 1. Sharding, DB 이중화란?
- **Sharding**
  - 데이터 분할이라고도 하는 샤딩은 기본적으로 DB를 인덱싱하는 계층적 방법이다.
  - 피자 조각을 공유하는 것과 동일한 개념. 피자를 생각해보자. 한 조각씩 잘려진 피자를 갖고 있고 이 조각 피자를 친구들에게 공유하려고 한다.
  - 기본적으로 큰 데이터 세트를 더 작은 덩어리(논리적 샤드)로 분할하고 이러한 덩어리를 다른 머신/데이터베이스 노드(물리적 샤드)에 저장/배포하는 데이터베이스 아키텍처 패턴이다.
  - 여기서 각 덩어리/파티션은 "샤드"로 불리며 **각 샤드는 원본 데이터베이스와 동일한 데이터베이스 스키마를 가진다.**
  - 우리는 각 행이 정확히 하나의 샤드에 나타나는 방식으로 데이터를 배포한다. 이것은 애플리케이션의 확장성을 향상시키는 좋은 메커니즘이다.
  - Shard가 실패하면?
    - 마스터/슬레이브 아키텍처를 사용한다. 쓰기는 항상 마스터로 이동하고, 읽기는 슬레이브에 분산된다.
    - 마스터가 실패하면 슬레이브 중 하나가 마스터가 된다.
  - 샤드가 용량을 초과하면 어떻게 될까?
    - 그것은 바로 샤드를 더 작은 샤드로 분할하는 것이다(이건 Dymano DB에서 해줌)
- **DB 이중화**
  - 시스템 오류로 인한 DB 서비스 중단이나 물리적 손상 발생 시 이륵 복구하기 위해서 DB를 복제해 관리하는 것

## 참고
- [백엔드 개발자로 입사를 준비하며 받았던 질문, 예상했던 질문, 인터넷 참고한 질문(CC BY-NC)](https://github.dev/ksundong/backend-interview-question)