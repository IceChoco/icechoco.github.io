<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://icechoco.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://icechoco.github.io/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2022-05-15T13:08:28+09:00</updated><id>https://icechoco.github.io/feed.xml</id><title type="html">IceChoco</title><subtitle>Hydejack is a boutique Jekyll theme for hackers, nerds, and academics, with a focus on personal sites that are meant to impress.
</subtitle><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><entry><title type="html">[Spring] SpringBoot로 Rest API 만들기 - Swagger API 문서 자동화</title><link href="https://icechoco.github.io/java,/spring/2022-05-12-make-rest-api-with-springBoot/" rel="alternate" type="text/html" title="[Spring] SpringBoot로 Rest API 만들기 - Swagger API 문서 자동화" /><published>2022-05-12T00:00:00+09:00</published><updated>2022-05-12T15:26:29+09:00</updated><id>https://icechoco.github.io/java,/spring/make-rest-api-with-springBoot</id><content type="html" xml:base="https://icechoco.github.io/java,/spring/2022-05-12-make-rest-api-with-springBoot/"><![CDATA[<p>평소에 내가 속한 부서에서는 프론트와 백엔드 개발자가 나뉘어 있지 않고 한 사람이 다 하다보니 API 문서 자동화를 제공해주는 Swagger를 사용하고 있지 않았다. 
외부 시스템과 연계해야 할 때는 API 문서를 엑셀 또는 파워포인트로 정리하여 공유가 되었다. 그런데, 최근에 외부 시스템과 원활한 IF를 위해 Swagger를 적용하는 곳이 생기고 있다.  <br />
그런데 이번에 YAPP 백엔드 팀원 분이 Swagger를 사용해봤더니 프론트와 백엔드 간의 의사소통이 원활했다라는 말을 듣고 이번 사이드 프로젝트에도 적용하기로 하였다.</p>

<p>Swagger는 문서 자동화 툴이며 간단한 설정으로 테스트가 가능한 Web UI를 지원한다. API를 테스트하기 위해 부가적으로 Postman과 같은 프로그램을 깔지 않아도 된다!<br />
또한 최소한의 작업을 통해 자동으로 API Document를 만들어주기 때문에 프론트 개발자에게 문서 내용을 전달하기위해 워드나 파워포인트를 만들지 않아도 된다는 장점이 있다.</p>

<h2 id="buildgrald에-swagger-라이브러리-추가하기">build.grald에 swagger 라이브러리 추가하기</h2>
<p><code class="language-plaintext highlighter-rouge">build.grale</code> 파일에 아래와 같이 라이브러리를 추가한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">implementation</span> <span class="nl">group:</span> <span class="err">'</span><span class="n">io</span><span class="o">.</span><span class="na">springfox</span><span class="err">'</span><span class="o">,</span> <span class="nl">name:</span> <span class="err">'</span><span class="n">springfox</span><span class="o">-</span><span class="n">swagger2</span><span class="err">'</span><span class="o">,</span> <span class="nl">version:</span> <span class="err">'</span><span class="mf">2.9</span><span class="o">.</span><span class="mi">2</span><span class="err">'</span>
	<span class="n">implementation</span> <span class="nl">group:</span> <span class="err">'</span><span class="n">io</span><span class="o">.</span><span class="na">springfox</span><span class="err">'</span><span class="o">,</span> <span class="nl">name:</span> <span class="err">'</span><span class="n">springfox</span><span class="o">-</span><span class="n">swagger</span><span class="o">-</span><span class="n">ui</span><span class="err">'</span><span class="o">,</span> <span class="nl">version:</span> <span class="err">'</span><span class="mf">2.9</span><span class="o">.</span><span class="mi">2</span><span class="err">'</span>
</code></pre></div></div>

<h2 id="buildgrald에-swagger-라이브러리-추가하기-1">build.grald에 swagger 라이브러리 추가하기</h2>
<p>yapp.bestFriend.config 패키지에 SwaggerConfig 파일을 작성한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableSwagger2</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SwaggerConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">Docket</span> <span class="nf">docket</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Docket</span><span class="o">(</span><span class="nc">DocumentationType</span><span class="o">.</span><span class="na">SWAGGER_2</span><span class="o">).</span><span class="na">select</span><span class="o">()</span>
                <span class="o">.</span><span class="na">apis</span><span class="o">(</span><span class="nc">RequestHandlerSelectors</span><span class="o">.</span><span class="na">basePackage</span><span class="o">(</span><span class="s">"yapp.bestFriend.controller"</span><span class="o">))</span>
                <span class="o">.</span><span class="na">paths</span><span class="o">(</span><span class="nc">PathSelectors</span><span class="o">.</span><span class="na">any</span><span class="o">())</span>
                <span class="o">.</span><span class="na">build</span><span class="o">()</span>
                <span class="o">.</span><span class="na">apiInfo</span><span class="o">(</span><span class="n">apiInfo</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">ApiInfo</span> <span class="nf">apiInfo</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ApiInfoBuilder</span><span class="o">()</span>
                <span class="o">.</span><span class="na">title</span><span class="o">(</span><span class="s">"절친 API 문서"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">description</span><span class="o">(</span><span class="s">"절친 API 서버 문서입니다."</span><span class="o">)</span>
                <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="s">"1.0"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li><strong>basePackage(“yapp.bestFriend.controller”)).paths(PathSelectors.any())</strong>
    <ul>
      <li>yapp.bestFriend.controller 하단의 Controller 내용을 읽어 mapping된 resource들을 문서화 시킨다.</li>
      <li><code class="language-plaintext highlighter-rouge">PathSelectors.ant("/v1/**"")</code>와 같이 설정하여 v1으로 시작하는 resource들만 문서화 시키는 것도 가능하다.</li>
    </ul>
  </li>
  <li>ApiInfo를 작성하면 문서에 대한 설명과 작성자 정보를 표시할 수 있다.</li>
</ul>

<h2 id="usecontroller-수정하기">UseController 수정하기</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Api</span><span class="o">(</span><span class="n">tags</span> <span class="o">=</span> <span class="o">{</span><span class="s">"회원 API"</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserController</span> <span class="o">{</span>

<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li><strong>@Api(tags = {“회원 API”})</strong>
    <ul>
      <li>UserController를 대표하는 최상단 타이틀 영역에 표시되는 값 세팅</li>
    </ul>
  </li>
  <li></li>
</ul>

<h3 id="참고">참고</h3>
<ul>
  <li><a href="https://daddyprogrammer.org/post/313/swagger-api-doc/">SpringBoot2로 Rest api 만들기(4) - Swagger API 문서 자동화</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="java," /><category term="spring" /><category term="java" /><summary type="html"><![CDATA[평소에 내가 속한 부서에서는 프론트와 백엔드 개발자가 나뉘어 있지 않고 한 사람이 다 하다보니 API 문서 자동화를 제공해주는 Swagger를 사용하고 있지 않았다. 외부 시스템과 연계해야 할 때는 API 문서를 엑셀 또는 파워포인트로 정리하여 공유가 되었다. 그런데, 최근에 외부 시스템과 원활한 IF를 위해 Swagger를 적용하는 곳이 생기고 있다. 그런데 이번에 YAPP 백엔드 팀원 분이 Swagger를 사용해봤더니 프론트와 백엔드 간의 의사소통이 원활했다라는 말을 듣고 이번 사이드 프로젝트에도 적용하기로 하였다.]]></summary></entry><entry><title type="html">[Spring] 카카오, 구글 소셜 로그인 구현하기</title><link href="https://icechoco.github.io/java,/spring/2022-05-10-social-login/" rel="alternate" type="text/html" title="[Spring] 카카오, 구글 소셜 로그인 구현하기" /><published>2022-05-10T00:00:00+09:00</published><updated>2022-05-13T00:41:45+09:00</updated><id>https://icechoco.github.io/java,/spring/social-login</id><content type="html" xml:base="https://icechoco.github.io/java,/spring/2022-05-10-social-login/"><![CDATA[<p>Spring Boot 구조로 구성된 사이드 프로젝트에 적용 예정인 OAuth2 소셜로그인에 대해 정리하기위해 이 글을 쓰게 되었다.</p>

<h2 id="전체-시퀀스-다이어그램">전체 시퀀스 다이어그램</h2>

<p><img src="/assets\img/total_sequence_diagram.jpg" alt="total_sequence_diagram" /></p>

<blockquote>
  <p>시퀀스 상단: OAuth 2.0 표준을 따르는 소셜 로그인 시퀀스 다이어그램<br />
시퀀스 하단: JWT 토큰의 유효기간이 끝났을 때의 시퀀스 다이어그램</p>
</blockquote>

<h3 id="시퀀스-설명">시퀀스 설명</h3>
<p>위 다이어그램과 같이 보길 권장한다.</p>
<ol>
  <li>유저 - 소셜 로그인을 요청</li>
  <li>프론트엔드 - 백엔드로 GET “/oauth2/authorization/{provider-id}?<br />
redirect_uri=http://localhost:3000/oauth/redirect”으로 OAuth 인가 요청</li>
  <li>백엔드 - Provider 별로 Authorization Code 인증을 할 수 있도록 리다이렉트 (Redirect: GET “https://oauth.provider.com/oauth2.0/authorize?…”)</li>
  <li>유저 - 리다이렉트 화면에서 provider 서비스에 로그인</li>
  <li>로그인이 완료된 후, Authorization server → 백엔드로 Authorization Code 응답</li>
  <li>백엔드 - Authorization Code를 이용해 Authorization Server에 Access Token 요청</li>
  <li>Authorization Server → 백엔드로 Access Token 응답</li>
  <li>백엔드 - Access Token을 활용하여 Resource Server에 User data 요청</li>
  <li>백엔드 - 획득한 User Data를 DB에 저장 후, JWT 액세스 토큰과 Refresh Token을 생성</li>
  <li>Refresh Token은 수정이 불가능한 쿠키에 저장하고, 액세스 토큰은 프론트엔드 리다이렉트 URI에 쿼리스트링에 토큰을 담아 리다이렉트 (Redirect: GET http://localhost:3000/oauth/redirect?token={jwt-token})</li>
  <li>프론트엔드에서 토큰을 저장 후, API 요청 시 헤더에 Authorization: Bearer {token}을 추가하여 요청</li>
  <li>백엔드에서는 토큰을 확인하여 권한 확인</li>
  <li>토큰이 만료된 경우, 쿠키에 저장된 리프레스 토큰을 이용하여 액세스 토큰과 리프레시 토큰을 발급</li>
</ol>

<h3 id="참고">참고</h3>
<ul>
  <li><a href="https://deeplify.dev/back-end/spring/oauth2-social-login#%EC%B9%B4%EC%B9%B4%EC%98%A4-oauth-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%93%B1%EB%A1%9D">스프링부트 소셜 로그인</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="java," /><category term="spring" /><category term="java" /><summary type="html"><![CDATA[Spring Boot 구조로 구성된 사이드 프로젝트에 적용 예정인 OAuth2 소셜로그인에 대해 정리하기위해 이 글을 쓰게 되었다.]]></summary></entry><entry><title type="html">[Spring] 좋은 객체 지향 설계의 5가지 원칙(SOLID)대로 개발하기</title><link href="https://icechoco.github.io/java,/spring/2022-05-09-SOLID/" rel="alternate" type="text/html" title="[Spring] 좋은 객체 지향 설계의 5가지 원칙(SOLID)대로 개발하기" /><published>2022-05-09T00:00:00+09:00</published><updated>2022-05-12T14:55:18+09:00</updated><id>https://icechoco.github.io/java,/spring/SOLID</id><content type="html" xml:base="https://icechoco.github.io/java,/spring/2022-05-09-SOLID/"><![CDATA[<p>사이드 프로젝트 개발을 본격적으로 들어가기 전, 객체 지향 설계를 위해서는 고려해야하는 SOLID 중 가장 중요한 DIP에 대해서 정리한다.<br />
그리고 정리한 개념을 기억하며 순수 Java로 Spring의 dependency 설정 도움 없이 구현을 해보고자 한다.<br />
이 과정을 통해 왜 Spring을 사용해야 하는지 알게 되는 것이 목적이다.</p>

<h2 id="좋은-객체-지향-설계의-5가지-원칙solid">좋은 객체 지향 설계의 5가지 원칙(SOLID)</h2>
<h3 id="dip-의존-관계-역전-원칙dependency-inversion-principle">DIP 의존 관계 역전 원칙(Dependency Inversion Principle)</h3>
<ul>
  <li>의존 관계 역전 원칙은 SOILD에서 가장 중요한 원칙 중 하나이다.</li>
  <li>프로그래머는 <strong>“추상화에 의존해야지, 구체화에 의존하면 안된다.”</strong> 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
    <ul>
      <li>Client Code가 구현체를 바라보는게 아니라 Interface만 바라봐라</li>
    </ul>
  </li>
  <li>즉, 역할에 의존해라</li>
  <li>그런데 OCP에서 설명한 MemberService는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존한다.</li>
</ul>

<h3 id="정리">정리</h3>
<ul>
  <li>객체 지향의 핵심은 다형성</li>
  <li>다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.</li>
  <li>다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.</li>
  <li><strong>다형성 만으로는 OCP, DIP를 지킬 수 없다.</strong></li>
  <li>뭔가 더 필요하다.</li>
</ul>

<h2 id="객체-지향-설계와-스프링">객체 지향 설계와 스프링</h2>
<p>Spring을 공부하다보면 왜 이렇게 객체 지향의 중요성에 대해 많이 이야기가 나오는 것일까? 그것은 <strong>스프링은 다음 기술로 다형성과 OCP, DIP</strong>를 가능하게 지원하기 때문이다.</p>
<ul>
  <li>DI(Dependency injection) : 의존관계, 의존성 주입</li>
  <li>DI 컨테이너 제공 : 자바 객체들을 컨테이너 안에 넣어어놓고 그 안에서 의존관계를 주입해주는 역할을 한다. 이것들을 활용하면 클라이언트의 변경 없이 개발이 가능하다.</li>
</ul>

<h3 id="정리-1">정리</h3>
<ul>
  <li>모든 설계에 역할과 구현을 분리하자
    <ul>
      <li>자동차, 공연의 예를 떠올려보자</li>
    </ul>
  </li>
  <li>어플리케이션 설계도 공연을 설계하듯이 배역만 만들어두고, 배우는 언제든지 <strong>유연</strong>하게 <strong>변경</strong>할 수 있도록 만드는 것이 좋은 객체 지향 설계다.</li>
  <li>이상적으로는 모든 설계에 인터페이스를 부여하자.</li>
</ul>

<p>하지만 실무적으로 고민해보자.</p>
<ul>
  <li>인터페이스를 도입하면 추상화라는 비용이 발생한다. 이말은 추상화를 하게 되면 개발자의 코드를 한 번 더 열어봐야 한다. 이것이 코드 추상화의 단점이다.</li>
  <li>그러므로 기능을 확장할 가능성이 없다면 처음에는 구현체로 하는 것도 좋다.</li>
</ul>

<h2 id="스프링의-핵심원리-이해-1---예제-만들기">스프링의 핵심원리 이해 1 - 예제 만들기</h2>
<h3 id="프로젝트-생성">프로젝트 생성</h3>
<ol>
  <li><a href="https://start.spring.io/">start.spring.io</a>에 접속한다</li>
  <li>아래와 같이 설정 후 Genereate 한다.
    <ul>
      <li>Project : Gradle Project</li>
      <li>Language: Java</li>
      <li>Spring Boot : 2.6.7 (정식 릴리즈 된 버전 중 가장 최신 버전)</li>
      <li>Project Metadata (여긴 Custom하게 자기가 설정하고 싶은 이름으로 설정하면 된다)
        <ul>
          <li>Group: hello</li>
          <li>Artifact : core</li>
          <li>Packaging : Jar</li>
          <li>Java : 11</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h3 id="참고">참고</h3>
<ul>
  <li><a href="https://www.google.com/search?q=%EA%B5%AC%EA%B8%80%EB%B2%88%EC%97%AD%EA%B8%B0&amp;oq=&amp;aqs=chrome.0.35i39i362l8.1609134099j0j15&amp;sourceid=chrome&amp;ie=UTF-8">소트웍스 앤솔러지 - 규칙 8: 일급 콜렉션 사용</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="java," /><category term="spring" /><category term="java" /><summary type="html"><![CDATA[사이드 프로젝트 개발을 본격적으로 들어가기 전, 객체 지향 설계를 위해서는 고려해야하는 SOLID 중 가장 중요한 DIP에 대해서 정리한다. 그리고 정리한 개념을 기억하며 순수 Java로 Spring의 dependency 설정 도움 없이 구현을 해보고자 한다. 이 과정을 통해 왜 Spring을 사용해야 하는지 알게 되는 것이 목적이다.]]></summary></entry><entry><title type="html">[Spring] AOP를 SpringConfig에 @Bean으로 등록 했을 때 순환 참조 발생</title><link href="https://icechoco.github.io/spring/2022-05-07-Spring-AOP-trouble-shooting/" rel="alternate" type="text/html" title="[Spring] AOP를 SpringConfig에 @Bean으로 등록 했을 때 순환 참조 발생" /><published>2022-05-07T00:00:00+09:00</published><updated>2022-05-07T22:00:35+09:00</updated><id>https://icechoco.github.io/spring/Spring-AOP-trouble-shooting</id><content type="html" xml:base="https://icechoco.github.io/spring/2022-05-07-Spring-AOP-trouble-shooting/"><![CDATA[<p>AOP를 사용하는 방법은 크게 2가지가 있다.</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">@Component</code>로 선언하는 방법</li>
  <li><code class="language-plaintext highlighter-rouge">SpringConfig.java</code> 파일에 <code class="language-plaintext highlighter-rouge">@Bean</code>으로 등록하는 방법</li>
</ol>

<p>김영한님의 Spring 강의 로드맵대로 강의를 들으며 2번 방법대로 AOP를 구현하던 중 아래와 같이 빈 순환 참조 에러가 발생했다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The dependencies of some of the beans in the application context form a cycle:

   meberController defined in file [C:\Ara\공부\김영한님 스프링 완전 정복 로드맵\hello-spring\out\production\classes\hello\hellospring\controller\MeberController.class]
      ↓
   memberService defined in class path resource [hello/hellospring/SpringConfig.class]
┌─────┐
|  timeTraceAop defined in class path resource [hello/hellospring/SpringConfig.class]
└─────┘
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">hello.hellospring</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringConfig</span> <span class="o">{</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">TimeTraceAop</span> <span class="nf">timeTraceAop</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">TimeTraceAop</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Aspect</span> <span class="c1">//AOP 쓸려면 무조건 이 Annotation을 달아야함</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TimeTraceAop</span> <span class="o">{</span>

    <span class="nd">@Around</span><span class="o">(</span><span class="s">"execution(* hello.hellospring..*(..))"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">execute</span><span class="o">(</span><span class="nc">ProceedingJoinPoint</span> <span class="n">joinPoint</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="c1">//...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>TimeTraceAop의 AOP 대상을 지정하는 @Around 코드를 보면 그 범위를 hello.hellospring 패키지와 동일하거나, 그 하위에 있는 소스들로 지정하고 있다.<br />
SpringConfig는 hello.hellospring에 위치하고있으므로 timeTraceAop() 메서드도 AOP로 처리하게 된다. 그런데 이건 자기 자신인 TimeTraceAop를 생성하는 코드가 되면서 순환참조 문제가 발생한다.
반면에 SpringConfig 파일이 아닌 @Component 방식을 사용하면 AOP의 대상이 되는 코드 자체가 없기 때문에 문제가 발생하지 않고 정상적으로 작동한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Aspect</span> <span class="c1">//AOP 쓸려면 무조건 이 Annotation을 달아야함</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TimeTraceAop</span> <span class="o">{</span>

    <span class="nd">@Around</span><span class="o">(</span><span class="s">"execution(* hello.hellospring..*(..))"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">execute</span><span class="o">(</span><span class="nc">ProceedingJoinPoint</span> <span class="n">joinPoint</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="c1">//...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>그렇다면 Bean 방식으로는 해결할 수 없는걸까? 아니다. 아래와 같이 @Around를 수정하여 대상에서 SpringConfig 파일을 제외해주면 된다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Aspect</span> <span class="c1">//AOP 쓸려면 무조건 이 Annotation을 달아야함</span>
<span class="c1">//@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TimeTraceAop</span> <span class="o">{</span>

    <span class="nd">@Around</span><span class="o">(</span><span class="s">"execution(* hello.hellospring..*(..)) &amp;&amp; !target(hello.hellospring.SpringConfig)"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">execute</span><span class="o">(</span><span class="nc">ProceedingJoinPoint</span> <span class="n">joinPoint</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="c1">//...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>위처럼 수정한 다음 소스를 돌려보면 정상적으로 수행되는 것을 볼 수 있다.</p>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="spring" /><category term="spring" /><summary type="html"><![CDATA[AOP를 사용하는 방법은 크게 2가지가 있다. @Component로 선언하는 방법 SpringConfig.java 파일에 @Bean으로 등록하는 방법]]></summary></entry><entry><title type="html">[Spring] Spring이란?</title><link href="https://icechoco.github.io/spring/2022-04-29-Spring-introduction/" rel="alternate" type="text/html" title="[Spring] Spring이란?" /><published>2022-04-29T00:00:00+09:00</published><updated>2022-05-15T13:07:07+09:00</updated><id>https://icechoco.github.io/spring/Spring-introduction</id><content type="html" xml:base="https://icechoco.github.io/spring/2022-04-29-Spring-introduction/"><![CDATA[<p>오늘의 목표: 김영한님의 스프링 완전 정복 로드맵을 처음부터 끝까지 보고 실무 개발에 꼭 필요한 스프링 학습하기. 코드로 스프링 전반에 대한 이해도를 높이는 것을 목표로 한다.</p>

<p>아래와 같이 Spring 프로젝트로 전반적인 흐름을 흘려보며 진행하려 한다.</p>
<ul>
  <li>스프링 프로젝트 생성</li>
  <li>스프링 부트로 웹 서버 실행</li>
  <li>회원 도메인 개발 등…</li>
</ul>

<p><strong>프로젝트 사용 기술</strong></p>
<ul>
  <li>Spring Boot: 스프링을 쉽게 쓰기 위해 제공해주는 툴
    <ul>
      <li>스프링: 자바 엔터프라이즈 어플리케이션 개발을 편리하게 해주기 위한 프레임 웤</li>
      <li>JEE: Java Enterprise Application</li>
      <li>스프링 부트가 다루는 영역: 대표적으로 빌드, 빌딩, 배포 및 관리가 있음. 어플리케이션 개발 관련 거의 모든 분야에서 도움을 줌.</li>
    </ul>
  </li>
  <li>Gradle</li>
  <li>Thymeleaf</li>
  <li>JPA</li>
  <li>Tomcat</li>
  <li>HIBERNATE</li>
</ul>

<p>학습 방법: 처음부터 끝까지 직접 코딩하기</p>

<p><strong>스프링</strong> 완전 정복 로드맵</p>
<ul>
  <li>스프링 입문</li>
  <li>스프링 핵심 원리</li>
  <li>스프링 웹 MVC</li>
  <li>스프링 DB 데이터 접근기술</li>
  <li>실전! 스프링 부트</li>
</ul>

<h2 id="프로젝트-환경-설정">프로젝트 환경 설정</h2>
<ul>
  <li>프로젝트 생성</li>
  <li>라이브러리 살펴보기</li>
  <li>View 환경설정</li>
  <li>빌드하고 실행하기</li>
</ul>

<h3 id="프로젝트-생성">프로젝트 생성</h3>
<p><strong>사전 준비물</strong></p>
<ul>
  <li>Java 11 설치</li>
  <li>IDE: IntelliJ 또는 Eclipse 설치</li>
</ul>

<p><strong>스프링 부트 스타터 사이트로 이동해서 스프링 프로젝트 생성</strong></p>
<ul>
  <li>https://start.spring.io
    <ul>
      <li>Spring Boot 기반으로 스프링 관련 프로젝트를 만들어주는 사이트</li>
      <li>Project: Maven Project, Gradle Project
        <ul>
          <li>필요한 라이브러리를 불러오고 빌드해주는 대표적인 두가지 툴</li>
          <li>과거에는 Maven을 많이 썼지만 요즘에는 Gradle을 많이 사용 하는 추세</li>
          <li>스프링 라이브러리 자체도 예전에는 Maven을 사용하다가 요즘에는 Gradle로 넘어옴</li>
        </ul>
      </li>
      <li>Spring Boot
        <ul>
          <li>스프링 부트 버전
            <ul>
              <li>스냅삿: 개발 중인 버전. 가급적 사용 지양 권장</li>
              <li>M버전: 배포는 했지만 바뀔 수 있는 버전</li>
              <li>RC버전(Release Condidate)</li>
              <li>GA버전(General. AVailable):
아무것도 뒤에 안달려있는 버전. 최종적인 정식</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>프로젝트 메타데이터
    <ul>
      <li>내가 만드는 프로젝트의 중요한 정보들</li>
      <li>여기서 중요한건 Group, Artifact</li>
      <li>종류
        <ul>
          <li>Artifact
            <ul>
              <li>프로젝트명과 동일하게 설정한다.</li>
              <li>빌드되어 나올 때의 결과물</li>
              <li>제품의 이름으로, 버전 정보를 생략한 jar 파일의 이름이다.</li>
              <li>소문자로만 작성하며 특수문자는 사용하지 않는다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Dependencies : 아래 2개 선택
    <ul>
      <li>spring-boot-start-web
        <ul>
          <li>spring-boot-starter-tomcat: 톰캣(웹서버)</li>
          <li>spring-webmvc: 스프링 웹 MVC</li>
        </ul>
      </li>
      <li>spring-boot-starter-thymeleaf: 타임리프 템플릿 엔진(View)</li>
    </ul>
  </li>
</ul>

<p>위와 같이 선택이 완료되었으면 <code class="language-plaintext highlighter-rouge">Generate</code> 버튼을 클릭한다. 해당 버튼을 클릭하면 압축 형태의 스프링 부트 프로젝트 파일이 생성된다.<br />
이 파일을 원하는 경로에 이동시킨 후 압축을 해제하고, 자신이 사용하는 IDEA를 통해 열어보자. 나의 경우는 IntelliJ를 사용하고 있다.</p>

<h4 id="스프링-부트-프로젝트-살펴보기---디렉토리-구조">스프링 부트 프로젝트 살펴보기 - 디렉토리 구조</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hello-spring  
├─ gradle
│ ├── wrapper // Gralde을 쓰는 폴더
├─── src  
│ ├── main
│ │ ├─── java      // 실제 패키지와 소스 파일들이 위치한 곳
│ │ ├─── resources // 실제 자바코드 파일을 제외한 어떤 xml이나 properties, HTML 등 설정파일    
│ ├── test         // TestCode와 관련된 소스들이 위치한 곳
│ │ ├─── java      
│ │   ├─── hello.hellospring
│ ├── build.gradle // 버전 설정 및 라이브러리 가져오는 역할
</code></pre></div></div>

<ul>
  <li>build.gradle</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plugins</span> <span class="o">{</span>
	<span class="n">id</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="err">'</span> <span class="n">version</span> <span class="err">'</span><span class="mf">2.5</span><span class="o">.</span><span class="mi">13</span><span class="err">'</span>
	<span class="n">id</span> <span class="err">'</span><span class="n">io</span><span class="o">.</span><span class="na">spring</span><span class="o">.</span><span class="na">dependency</span><span class="o">-</span><span class="n">management</span><span class="err">'</span> <span class="n">version</span> <span class="err">'</span><span class="mf">1.0</span><span class="o">.</span><span class="mi">11</span><span class="o">.</span><span class="na">RELEASE</span><span class="err">'</span>
	<span class="n">id</span> <span class="err">'</span><span class="n">java</span><span class="err">'</span>
<span class="o">}</span>

<span class="n">group</span> <span class="o">=</span> <span class="err">'</span><span class="n">hello</span><span class="err">'</span>
<span class="n">version</span> <span class="o">=</span> <span class="err">'</span><span class="mf">0.0</span><span class="o">.</span><span class="mi">1</span><span class="o">-</span><span class="no">SNAPSHOT</span><span class="err">'</span>
<span class="n">sourceCompatibility</span> <span class="o">=</span> <span class="err">'</span><span class="mi">11</span><span class="err">'</span> <span class="c1">//자바 11버전</span>

<span class="n">repositories</span> <span class="o">{</span>
	<span class="n">mavenCentral</span><span class="o">()</span> <span class="c1">// 메이븐 센트럴에서 라이브러리들 다운로드 받게 간단한 설정해주기.</span>
	               <span class="c1">// 필요하면 특정사이트 URL을 넣어줄 수 있음.</span>
<span class="o">}</span>

<span class="n">dependencies</span> <span class="o">{</span>
	<span class="n">implementation</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">thymeleaf</span><span class="err">'</span>
	<span class="n">implementation</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">web</span><span class="err">'</span>
	<span class="n">testImplementation</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">test</span><span class="err">'</span>
<span class="o">}</span>

<span class="n">tasks</span><span class="o">.</span><span class="na">named</span><span class="o">(</span><span class="err">'</span><span class="n">test</span><span class="err">'</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">useJUnitPlatform</span><span class="o">()</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>plugins
    <ul>
      <li><code class="language-plaintext highlighter-rouge">io.spring.dependency-management</code> 플러그인은 스프링 부트의 의존성들을 관리해주는 플러그인이기 때문에 꼭 추가해주어야 한다.</li>
    </ul>
  </li>
  <li>repositories
    <ul>
      <li>각종 의존성(라이브버리)들을 어떤 원격 저장소에서 받을지 결정</li>
      <li>MavenCentral
        <ul>
          <li>기본적으로 MavenCentral을 많이 사용하지만, 최근에는 <strong>라이브러리 업로드 난이도</strong>때문에 jcenter도 많이 사용함</li>
          <li>본인이 만든 라이브러리를 업로드하기 위해서는 <strong>정말 많은 과정과 설정</strong>이 필요</li>
        </ul>
      </li>
      <li>jcenter
        <ul>
          <li>위 문제점이 개선되어 <strong>라이브러리 업로드가 간단</strong></li>
          <li>jcenter에 라이브러리를 올리면 mavenCentral에도 업로드 될 수 있도록 자동화 가능</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>dependencies
    <ul>
      <li>프로젝트 개발에 필요한 의존성들을 선언하는 곳</li>
    </ul>
  </li>
</ul>

<p>스프링 부트는 tomcat과 웹서버를 내장하고 있다. 그래서 WAS를 자체적으로 띄우면서 Spring Boot가 같이 올라오는 구조이다.<br />
최초 프로젝트를 생성하게 되면 <code class="language-plaintext highlighter-rouge">HelloSpringApplication</code> 클래스에 main 메서드가 위치하게 된다. 실행시켰을 때 정상적으로 서버가 띄워진다면 정상적으로 설치가 잘 된 것이다.</p>

<h3 id="라이브러리-살펴보기">라이브러리 살펴보기</h3>
<p>Gradle과 Maven과 같은 빌드툴들은 의존 관계를 관리해준다. 예를들어 dependencies에 <code class="language-plaintext highlighter-rouge">org.springframework.boot:spring-boot-starter-web</code>를 떙겨오는 경우 이 라이브러리가 의존성을 갖고 있는 라이브러리들을 자동으로 다운로드 받아 준다.</p>

<p><strong>스프링 부트 라이브러리</strong></p>
<ul>
  <li>spring-boot-starter(공통): 스프링 부트 + 스프링 코어 + 로깅
    <ul>
      <li>spring-boot
        <ul>
          <li>spring-core</li>
        </ul>
      </li>
      <li>spring-boot-starter-logging
        <ul>
          <li>logback, slf4j</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><strong>테스트 라이브러리</strong></p>
<ul>
  <li>junit: 테스트 프레임워크. 요즘은 junit5를 많이 사용함</li>
  <li>mockito: 목 라이브러리</li>
  <li>assertj: 테스트 코드를 좀 더 편하게 작성하게 도와주는 라이브러리</li>
  <li>spring-test: 스프링 통합 테스트 지원</li>
</ul>

<h3 id="view-환경설정">View 환경설정</h3>
<h4 id="welcome-page-만들기">Welcome Page 만들기</h4>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE HTML&gt;</span>
<span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span>Hello<span class="nt">&lt;/title&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"Content-Type"</span> <span class="na">content=</span><span class="s">"text/html; charset=UTF-8"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
Hello
<span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"/hello"</span><span class="nt">&gt;</span>hello<span class="nt">&lt;/a&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>
<blockquote>
  <p>Spring Boot supports both static and templated welcome pages. It first looks for an index.html file in the configured static content locations. If one is not found, it then looks for an index template. If either is found, it is automatically used as the welcome page of the application.</p>
</blockquote>

<ul>
  <li>스프링 부트가 제공하는 Welcome Page기능
    <ul>
      <li>스프링부트는 <code class="language-plaintext highlighter-rouge">resources/static/index.html</code>에 파일을 만들면, 이 파일을 웰컴 페이지로 만들어준다.</li>
      <li>스프링부트는 static content가 위치한 곳에서 먼저 <code class="language-plaintext highlighter-rouge">index.html</code> 파일을 찾고, 만약에 못찾으면 <code class="language-plaintext highlighter-rouge">index</code> template을 찾는 식으로 동작한다.</li>
      <li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.reactive.webflux.static-content">Spring boot docs - 2.1.4. Welcome Page</a></li>
    </ul>
  </li>
</ul>

<h4 id="thymeleaf-템플릿-엔진">thymeleaf 템플릿 엔진</h4>
<p>Spring Boot는 다음 4가지 템플릿 엔진에 대한 자동 구성을 해준다.</p>
<ul>
  <li>FreeMarker</li>
  <li>Groovy</li>
  <li>Thymeleaf</li>
  <li>Mustache</li>
</ul>

<p>템플릿 엔진을 쓰면 loop 등을 사용하여 내가 원하는 대로 모양을 바꿀 수 있다.</p>
<ul>
  <li><a href="https://www.thymeleaf.org/">Thymeleaf 공식 사이트</a></li>
  <li><a href="https://spring.io/guides/gs/serving-web-content/">스프링 공식 튜토리얼</a></li>
  <li><a href="https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/
html/spring-boot-features.html#boot-features-spring-mvc-template-engines">스프링부트 메뉴얼</a></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloController</span> <span class="o">{</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"hello"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">hello</span><span class="o">(</span><span class="nc">Model</span> <span class="n">model</span><span class="o">){</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>웹 어플리케이션에서 <code class="language-plaintext highlighter-rouge">GetMapping</code> 어노테이션을 달면 <code class="language-plaintext highlighter-rouge">서버 URL/hello</code> 수행 시 이 메소드를 수행하겠다는 뜻이다.
<img src="/assets\img/Spring-operating-environment.png" alt="Spring-operating-environment" /></p>
<ul>
  <li>컨트롤러에서 리컨 값으로 문자를 반환하면 뷰 리졸버(<code class="language-plaintext highlighter-rouge">viewResolver</code>)가 화면을 찾아서 처리한다.
    <ul>
      <li>스프링 부트 템플릿엔진 기본 viewName 매핑</li>
      <li><code class="language-plaintext highlighter-rouge">resources:templates/</code>+{ViewName}+<code class="language-plaintext highlighter-rouge">.html</code></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>참고로 <code class="language-plaintext highlighter-rouge">spring-boot-devtools</code> 라이브러리를 추가하면, <code class="language-plaintext highlighter-rouge">html</code> 파일을 컴파일만 해주면 서버 재시작 없이 View 파일 변경이 가능하다.<br />
인텔리J 컴파일 방법: 메뉴 build → Recompile</p>
</blockquote>

<h3 id="빌드하고-실행하기">빌드하고 실행하기</h3>
<ol>
  <li>프로젝트가 있는 경로에서 cmd 창을 실행하여 <code class="language-plaintext highlighter-rouge">gradlew.bat build</code>를 수행한다.</li>
  <li><code class="language-plaintext highlighter-rouge">cd build/libs</code></li>
  <li><code class="language-plaintext highlighter-rouge">java -jar hello-spring-0.0.1-SNAPSHOT.jar</code>를 수행하면 스프링이 실행된다.
    <ul>
      <li>즉 서버를 배포할 떄는 위 jar 파일만 복사해서 서버에 넣은다음, <code class="language-plaintext highlighter-rouge">java -jar</code> 명령어를 통해 실행시키면 된다. 그렇게 하면 서버에서도 스프링이 동작하게 된다.</li>
    </ul>
  </li>
  <li>실행확인</li>
</ol>

<h2 id="spring-웹-개발-기초">spring 웹 개발 기초</h2>
<ul>
  <li>정적 컨텐츠
    <ul>
      <li>Welcome 페이지 개발했던 것처럼 서버에서 하는 것 없이 파일을 그대로 Web 브라우저에 그대로 내려주는 것이다.</li>
    </ul>
  </li>
  <li>MVC와 템플릿 엔진
    <ul>
      <li>가장 많이 하는 방식이다. 과거에 JSP, PHP가 흔히 말하는 템플릿 엔진이다. HTML을 그대로 내려주는 것이 아니라 서버에서 동적으로 수행한 뒤에 내려준다.</li>
      <li>이것들을 하기 위해서 Controller, Model, View를 합해 MVC라고 하는데 요즘 이 패턴으로 개발을 많이 한다. (지금 회사에서도 MVC 패턴으로 개발 중이다.)</li>
    </ul>
  </li>
  <li>API
    <ul>
      <li>만약 안드로이드나 아이폰 Client와 통신을 해야하는 경우 Json 데이터 포맷으로 내려주는 것을 API 방식이라 한다.</li>
      <li>리액트로 프론트엔드가 개발된 경우에 많이 씀</li>
      <li>서버끼리 통신할 때</li>
    </ul>
  </li>
</ul>

<h3 id="정적-컨텐츠">정적 컨텐츠</h3>
<p>스프링 부트는 정적 컨텐츠 기능을 <code class="language-plaintext highlighter-rouge">/static</code> 폴더에서 찾아서 자동으로 제공한다.</p>
<ul>
  <li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.reactive.webflux.static-content">Spring boot docs - 2.1.4. Welcome Page</a></li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE HTML&gt;</span>
<span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span>static content<span class="nt">&lt;/title&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"Content-Type"</span> <span class="na">content=</span><span class="s">"text/html; charset=UTF-8"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
정적 컨텐츠 입니다.
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>
<p><img src="/assets\img/spring-static-content-feature.png" alt="spring-static-content-feature" /></p>

<h3 id="mvc와-템플릿-엔진">MVC와 템플릿 엔진</h3>
<p>과거에는 Controller와 View가 따로 나뉘어 있지않고 View에 모든 것을 다 구현했었는데 이를 <strong>Model 1 방식</strong>
이라 한다. 하지만 요즘은 MVC 스타일로 많이 한다.</p>
<ul>
  <li>MVC
    <ul>
      <li>Model</li>
      <li>Controller: 비즈니스 로직과 관련이 있거나 내부적으로 처리해야 하는 것을 구현해야함</li>
      <li>View: 화면과 관련된 것만 구현해야 함</li>
    </ul>
  </li>
</ul>

<p><img src="/assets\img/spring-MVC-template-engine.png" alt="spring-MVC-template-engine" /></p>

<h3 id="api">API</h3>
<p>정적 컨텐츠를 제외하면 HTML로 내리느냐, 아니면 API 방식으로 데이터를 내리느냐를 결정하면 된다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"hello-string"</span><span class="o">)</span>
<span class="nd">@ResponseBody</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">helloString</span><span class="o">(</span><span class="nd">@RequestParam</span><span class="o">(</span><span class="s">"name"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
    <span class="k">return</span> <span class="s">"hello"</span><span class="o">+</span><span class="n">name</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">@ResponseBody</code>란 http에서 헤더부와 body부가 있는데, 그 body부에 이 데이터를 내가 직접 넣어주겠다라는 뜻이다.
템플릿 엔진과의 차이점은 View가 없이 이문자가 그대로 전달된다는 차이점이 있다.</p>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="spring" /><category term="spring" /><summary type="html"><![CDATA[오늘의 목표: 김영한님의 스프링 완전 정복 로드맵을 처음부터 끝까지 보고 실무 개발에 꼭 필요한 스프링 학습하기. 코드로 스프링 전반에 대한 이해도를 높이는 것을 목표로 한다.]]></summary></entry><entry><title type="html">[Java] 일급 컬렉션 (First Class Collection)이란?</title><link href="https://icechoco.github.io/java/2022-04-22-First-Class-Collection/" rel="alternate" type="text/html" title="[Java] 일급 컬렉션 (First Class Collection)이란?" /><published>2022-04-22T00:00:00+09:00</published><updated>2022-04-22T22:37:07+09:00</updated><id>https://icechoco.github.io/java/First-Class-Collection</id><content type="html" xml:base="https://icechoco.github.io/java/2022-04-22-First-Class-Collection/"><![CDATA[<p>우아한 테크캠프 Pro 프리코스 2주차 과제에서는 1주차 과제에서 추가로 <strong>일급 콜렉션</strong>을 사용하라는 프로그래밍 요구사항이 추가되었다.
일급 컬렉션이란 무엇인지, 어떤 장점들이 있기에 객체지향적이고 리팩토링하기 쉬운 코드를 짜기위해 필요한지 알아보려한다.</p>

<ul>
  <li><span style="color:grey"><em>향로님이 올려주신 <a href="https://jojoldu.tistory.com/412">일급 컬렉션 (First Class Collection)의 소개와 써야할 이유</a>를 보고 정리한 글입니다.</em> </span></li>
</ul>

<p>우선 일급 컬렉션이라는 단어는 소트웍스 앤솔로지의 객체지향 생활체조 파트에서 언급이 되었다.</p>
<blockquote>
  <p>규칙 8: 일급 콜렉션 사용
이 규칙의 적용은 간단하다.
콜렉션을 포함한 클래스는 반드시 다른 멤버 변수가 없어야 한다.
각 콜렉션은 그 자체로 포장돼 있으므로 이제 콜렉션과 관련된 동작은 근거지가 마련된셈이다.
필터가 이 새 클래스의 일부가 됨을 알 수 있다.
필터는 또한 스스로 함수 객체가 될 수 있다.
또한 새 클래스는 두 그룹을 같이 묶는다든가 그룹의 각 원소에 규칙을 적용하는 등의 동작을 처리할 수 있다.
이는 인스턴스 변수에 대한 규칙의 확실한 확장이지만 그 자체를 위해서도 중요하다.
콜렉션은 실로 매우 유용한 원시 타입이다.
많은 동작이 있지만 후임 프로그래머나 유지보수 담당자에 의미적 의도나 단초는 거의 없다. - 소트웍스 앤솔로지 객체지향 생활체조편</p>

</blockquote>

<p>설명을 보기 전까지는 무슨 의미인지 알겠다. 그런데 소스코드를 봐야 좀 더 확실하게 알 수 있을듯하다. 아래의 코드를 보자.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put("1", "A");
map.put("2", "B");
map.put("3", "C");
</code></pre></div></div>
<p>위와 같은 코드를 아래와 같이 <strong>Wrapping</strong>할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GameRanking</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">ranks</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">GameRanking</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">ranks</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">ranks</span> <span class="o">=</span> <span class="n">ranks</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>Collection을 Wrapping</strong>하면서, <strong>그 외 다른 멤버 변수가 없는 상태</strong>를 일급 컬렉션이라 한다.
Wrapping하면서 얻게되는 이점들은 크게 4가지가 있다.</p>

<ol>
  <li><strong>비즈니스</strong>에 종속적인 <strong>자료구조</strong></li>
  <li>Collection의 <strong>불변성</strong>을 보장</li>
  <li>상태와 행위를 한 곳에서 관리</li>
  <li>이름이 있는 컬렉션</li>
</ol>

<h2 id="1-비즈니스에-종속적인-자료구조">1. 비즈니스에 종속적인 자료구조</h2>
<p>예를 들어 다음과 같은 조건으로 <strong>로또 복권 게임</strong>을 만든다고 가정해보자.
로또복권은 다음과 같은 조건이 있다.</p>
<ul>
  <li>6개의 번호가 존재</li>
  <li>보너스 번호는 이번 예제에서 제외</li>
  <li>6개의 번호를 서로 중복되지 않아야 함</li>
</ul>

<p>일반적으로 이런 일은 <strong>서비스 메소드</strong>에서 진행한다.
그래서 구현을 해보면 아래처럼 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">LOTTO_NUMBERS_SIZE</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createLottoNumber</span><span class="o">(){</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">lottotNumbers</span> <span class="o">=</span> <span class="n">createNonDuplicateNumbers</span><span class="o">();</span>
        <span class="n">validateSize</span><span class="o">(</span><span class="n">lottotNumbers</span><span class="o">);</span>
        <span class="n">validateDuplicate</span><span class="o">(</span><span class="n">lottotNumbers</span><span class="o">);</span>
        
        <span class="c1">//이후 로직 쭉쭉 실행</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="nf">createNonDuplicateNumbers</span><span class="o">()</span> <span class="o">{</span>
     <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="k">new</span> <span class="nc">Long</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateDuplicate</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">lottotNumbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">lottotNumbers</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">!=</span> <span class="no">LOTTO_NUMBERS_SIZE</span><span class="o">){</span>
           <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"로또 번호는 6개만 가능합니다."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateSize</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">lottotNumbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">nonDuplicateNumbers</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;(</span><span class="n">lottotNumbers</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nonDuplicateNumbers</span><span class="o">.</span><span class="na">size</span><span class="o">()!=</span><span class="no">LOTTO_NUMBERS_SIZE</span><span class="o">){</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"로또 번호는 중복될 수 없습니다."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>서비스 메소드에서 비즈니스 로직을 처리했다. 이럴경우 큰 문제가 있다.
<strong>로또 번호가 필요한 모든 장소에선 검증로직</strong>이 들어가야만 한다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">List&lt;Long&gt;</code>으로 된 데이터는 모두 검증로직이 필요할까 ?</li>
  <li>신규 입사자들의 경우 이 검증 로직이 필요한지 알 수 있을까?</li>
</ul>

<p>등등 <strong>모든 코드와 도메인 로직</strong>을 알고 있지 않다면 언제든 문제가 발생할 소지가 있다.
그렇다면 이 문제를 해결하기 위해서는</p>

<ul>
  <li>6개의 숫자로만 이루어져야하고</li>
  <li>6개의 숫자는 서로 중복되지 않아야만 하는</li>
</ul>

<p>이런 자료구조가 없을까? 없으니 만들면된다!
아래와 같이 <strong>해당 조건으로만 생성 할 수 있는 자료구조</strong>를 만들면 위에서 언급한 문제들이 모두 해결된다.
그리고 이런 클래스를 <strong>일급 컬렉션</strong>이라고 부른다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoTicket</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">LOTTO_NUMBERS_SIZE</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
    
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">lottoNumbers</span><span class="o">;</span>
    
    <span class="c1">//6개 / 중복되지 않은 숫자들만 가능한 자료구조</span>
    <span class="kd">public</span> <span class="nf">LottoTicket</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">lottoNumbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">validateSize</span><span class="o">(</span><span class="n">lottoNumbers</span><span class="o">);</span>
        <span class="n">validateDuplicate</span><span class="o">(</span><span class="n">lottoNumbers</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lottoNumbers</span> <span class="o">=</span> <span class="n">lottoNumbers</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateDuplicate</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">lottotNumbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">lottotNumbers</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">!=</span> <span class="no">LOTTO_NUMBERS_SIZE</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"로또 번호는 6개만 가능합니다."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateSize</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">lottotNumbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">nonDuplicateNumbers</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;(</span><span class="n">lottotNumbers</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nonDuplicateNumbers</span><span class="o">.</span><span class="na">size</span><span class="o">()!=</span><span class="no">LOTTO_NUMBERS_SIZE</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"로또 번호는 중복될 수 없습니다."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이제 로또 번호가 필요한 모든 로즉인 이 일급 컬렉션만 있으면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoService2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createLottoNumber</span><span class="o">(){</span>
        <span class="nc">LottoTicket</span> <span class="n">lottoTicket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LottoTicket</span><span class="o">(</span><span class="n">createNonDuplicateNumbers</span><span class="o">());</span>
    
    <span class="c1">//이후 로직 쭉쭉 실행</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="nf">createNonDuplicateNumbers</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="k">new</span> <span class="nc">Long</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span><span class="c1">//로직 구현하기</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>비즈니스에 종속적인 자료구조</strong>가 만들어져, 이후 발생할 문제가 최소화 되었다.</p>

<h2 id="2-불변">2. 불변</h2>
<p>일급 컬렉션은 <strong>컬렉션의 불변을 보장</strong>한다.
불변을 보장하기 위해 final을 사용하면 되는거 아니냐 생각 할 수 있지만 아니다.
자바의 final은 정확히는 불변을 만들어주는게 아니라, <strong>재할당만 금지</strong>한다.</p>

<p>아래의 테스트 코드를 참고해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">finalTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">final도_값변경이_가능하다</span><span class="o">(){</span>
        <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Boolean</span><span class="o">&gt;</span> <span class="n">collection</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        
        <span class="n">collection</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">collection</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"2"</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">collection</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"3"</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">collection</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"4"</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
        
        <span class="n">assertThat</span><span class="o">(</span><span class="n">collection</span><span class="o">.</span><span class="na">size</span><span class="o">()).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이를 실행해보면 collection에 <strong>값이 추가</strong>되는걸 확인할 수 있다.
이미 collection은 <strong>비어 있는 HashMap</strong>으로 선언되었음에도 값이 변경될 수 있다는 것이다.
추가로 테스트해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">finalTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">final은_재할당이_불가능하다</span><span class="o">(){</span>
        <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Boolean</span><span class="o">&gt;</span> <span class="n">collection</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        
        <span class="n">collection</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        
        <span class="n">assertThat</span><span class="o">(</span><span class="n">collection</span><span class="o">.</span><span class="na">size</span><span class="o">()).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 코드는 <code class="language-plaintext highlighter-rouge">collection = new HashMap&lt;&gt;();</code>에서 바로 컴파일 에러가 발생한다. <strong>final로 할당된 코드에 재할당 될 수 없기 때문이다.</strong></p>

<p>위와 같이 Java의 final은 <strong>재할당만 금지</strong>한다.
이외에도 <code class="language-plaintext highlighter-rouge">member.setAge(10)</code>와 같은 코드 역시 작동해버리니 반쪽자리라 할 수 있다.</p>

<p>요즘과 같이 SW 규모가 커지고 있는 상황에서 <strong>불변 객체</strong>는 아주 중요하다.
각각의 객체들이 <strong>절대 값이 바뀔 일이 없다</strong>는게 보장되면 그만큼 코드를 이해하고 수정하는 <strong>사이드 이펙트가 최소화</strong>되기 때문이다.</p>

<p>Java에서는 final로 그 문제를 해결할 수 없기 때문에 <strong>일급 컬렉션</strong>(First Class Collection)과 <strong>래퍼 클래스</strong>(Wrapper class) 등의 방법으로 해결해야만 한다.</p>

<p>그래서 아래와 같이 <strong>컬렉션의 값을 변경할 수 있는 메소드가 없는 컬렉션</strong>을 만들면 <strong>불변 컬렉션</strong>이 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Orders</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">orders</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">Orders</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">orders</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">orders</span> <span class="o">=</span> <span class="n">orders</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getAmountSum</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">orders</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
        <span class="o">.</span><span class="na">mapToLong</span><span class="o">(</span><span class="nl">Order:</span><span class="o">:</span><span class="n">getAmount</span><span class="o">)</span>
        <span class="o">.</span><span class="na">sum</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 클래스는 <strong>생성자와 getAmountSum()</strong>외에 다른 메소드가 없다.
즉, 이 클래스의 사용법은 <strong>새로 만들거나 값을 가져오는 것</strong>뿐이다.
List라는 컬렉션에 접근할 수 있는 방법이 없기 때문에 <strong>값을 변경/추가가 안된다.</strong></p>

<p>이렇게 일급 컬렉션을 사용하면, 불변 컬렉션을 만들 수 있다.</p>

<h2 id="3-상태와-행위를-한곳에서-관리">3. 상태와 행위를 한곳에서 관리</h2>
<p>일급 컬렉션의 세번쨰 장점은 <strong>값과 로직이 함께 존재</strong>한다는 것이다.</p>
<blockquote>
  <p>이 부분은 Enum의 장점과도 일맥상통한다.</p>
</blockquote>

<p>예를들어 여러 Pay들이 모여있고, 이 중 <strong>NaverPay 금액의 합</strong>이 필요하다고 가정해보겠다.
일반적으로는 아래와 같이 작성한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PayTest</span> <span class="o">{</span>
  <span class="nd">@Test</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="n">로직이_밖에_있는_상태</span><span class="o">(){</span>
    <span class="c1">//값은 여기 있는데</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">pays</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
            <span class="k">new</span> <span class="nf">Pay</span><span class="o">(</span><span class="no">NAVER_PAY</span><span class="o">,</span> <span class="mi">1000</span><span class="o">),</span>
            <span class="k">new</span> <span class="nf">Pay</span><span class="o">(</span><span class="no">NAVER_PAY</span><span class="o">,</span> <span class="mi">1500</span><span class="o">),</span>
            <span class="k">new</span> <span class="nf">Pay</span><span class="o">(</span><span class="no">KAKAO_PAY</span><span class="o">,</span> <span class="mi">2000</span><span class="o">),</span>
            <span class="k">new</span> <span class="nf">Pay</span><span class="o">(</span><span class="no">TOSS</span><span class="o">,</span> <span class="mi">3000L</span><span class="o">)</span>
    <span class="o">);</span>

    <span class="c1">//계산은 여기서</span>
    <span class="nc">Long</span> <span class="n">naverPaySum</span> <span class="o">=</span> <span class="n">pays</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">pay</span> <span class="o">-&gt;</span> <span class="n">pay</span><span class="o">.</span><span class="na">getPayType</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="no">NAVER_PAY</span><span class="o">))</span>
            <span class="o">.</span><span class="na">mapToLong</span><span class="o">(</span><span class="nl">Pay:</span><span class="o">:</span><span class="n">getAmount</span><span class="o">)</span>
            <span class="o">.</span><span class="na">sum</span><span class="o">();</span>

    <span class="n">assertThat</span><span class="o">(</span><span class="n">naverPaySum</span><span class="o">).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="mi">2500</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>List에 데이터를 담고</li>
  <li>Service 혹은 Util 클래스에서 필요한 로직 수행</li>
</ul>

<p>이 상황에서는 문제가 있다.<br />
결국 <code class="language-plaintext highlighter-rouge">pays</code>라는 컬렉션과 계산 로직은 <strong>서로 관계</strong>가 있는데, 이를 <strong>코드로 표현이 안된다.</strong></p>

<p>Pay 타입의 <strong>상태에 따라</strong> 지정된 메소드에서만 계산되길 월하는데, 현재 상태로는 강제할 수 있는 수단이 없다.<br />
지금은 <strong>Pay 타입의 List라면</strong> 사용될 수 있기 때문에 히스토리를 모른다면 실수할 여지가 많다.</p>
<ul>
  <li>똑같은 기능을 하는 <strong>메소드를 중복 생성</strong>할 수 있다.
    <ul>
      <li>히스토리가 관리 안된 상태에서 신규 화면이 추가되어야 할 경우 계산 메소드가 있다는 것을 몰라 다시 만드는 경우가 빈번하다.</li>
      <li>만약 기존 화면의 계싼 로직이 변경될 경우, 신규 인력은 2개의 메소드 로직을 다 변경해야하는지, 해당 화면만 변경해야 하는지 알 수 없다.</li>
      <li>관리 포인트가 증가할 확률이 매우 높다.</li>
    </ul>
  </li>
  <li>계산 메소드를 누락할 수 있다.
    <ul>
      <li>리턴 받고자 하는 것이 Long 타입이기 때문에 <strong>꼭 이 계산식을 써야한다고 강제할 수 없다.</strong></li>
    </ul>
  </li>
</ul>

<p>결국에 <strong>네이버페이 총 금액을 뽑을려면 이렇게 해야한다는 계산식을 컬렉션과 함께 두어야</strong> 한다.<br />
만약 네이버페이 외에 카카오 페이의 총금액도 필요하다면 더더욱 <strong>코드가 흩어질 확률이 높다.</strong></p>

<p>그래서 이 문제를 일급 컬렉션으로 해결할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PayGroup</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">pays</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">PayGroup</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">pays</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">pays</span> <span class="o">=</span> <span class="n">pays</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">getNaverPaySum</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">pays</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">pay</span> <span class="o">-&gt;</span> <span class="nc">PayType</span><span class="o">.</span><span class="na">isNaverPay</span><span class="o">(</span><span class="n">pay</span><span class="o">.</span><span class="na">getPayType</span><span class="o">()))</span>
                <span class="o">.</span><span class="na">mapToLong</span><span class="o">(</span><span class="nl">Pay:</span><span class="o">:</span><span class="n">getAmount</span><span class="o">)</span>
                <span class="o">.</span><span class="na">sum</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>만약 <strong>다른 결제 수단들의 합이 필요</strong>하다면 아래와 같이 <strong>람다식으로 리팩토링</strong> 가능하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PayGroups</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">pays</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">PayGroups</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">pays</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">pays</span> <span class="o">=</span> <span class="n">pays</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">getNaverPaySum</span><span class="o">(){</span>
        <span class="k">return</span> <span class="nf">getFilteredPays</span><span class="o">(</span><span class="n">pay</span> <span class="o">-&gt;</span> <span class="nc">PayType</span><span class="o">.</span><span class="na">isNaverPay</span><span class="o">(</span><span class="n">pay</span><span class="o">.</span><span class="na">getPayType</span><span class="o">()));</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">getKakaoPaySum</span><span class="o">(){</span>
        <span class="k">return</span> <span class="nf">getFilteredPays</span><span class="o">(</span><span class="n">pay</span> <span class="o">-&gt;</span> <span class="nc">PayType</span><span class="o">.</span><span class="na">isKakaoPay</span><span class="o">(</span><span class="n">pay</span><span class="o">.</span><span class="na">getPayType</span><span class="o">()));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Long</span> <span class="nf">getFilteredPays</span><span class="o">(</span><span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">){</span>
        <span class="k">return</span> <span class="n">pays</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">pay</span> <span class="o">-&gt;</span> <span class="nc">PayType</span><span class="o">.</span><span class="na">isNaverPay</span><span class="o">(</span><span class="n">pay</span><span class="o">.</span><span class="na">getPayType</span><span class="o">()))</span>
                <span class="o">.</span><span class="na">mapToLong</span><span class="o">(</span><span class="nl">Pay:</span><span class="o">:</span><span class="n">getAmount</span><span class="o">)</span>
                <span class="o">.</span><span class="na">sum</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 PayGroup라는 일급 컬렉션이 생김으로 <strong>상태와 로직이 한곳에서 관리</strong>된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PayTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">로직이_밖에_있는_상태</span><span class="o">(){</span>
        <span class="c1">//값은 여기 있는데</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">pays</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
                <span class="k">new</span> <span class="nf">Pay</span><span class="o">(</span><span class="no">NAVER_PAY</span><span class="o">,</span> <span class="mi">1000</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Pay</span><span class="o">(</span><span class="no">NAVER_PAY</span><span class="o">,</span> <span class="mi">1500</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Pay</span><span class="o">(</span><span class="no">KAKAO_PAY</span><span class="o">,</span> <span class="mi">2000</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Pay</span><span class="o">(</span><span class="no">TOSS</span><span class="o">,</span> <span class="mi">3000L</span><span class="o">)</span>
        <span class="o">);</span>

        <span class="c1">//상태와 로직이 한곳에!</span>
        <span class="nc">PayGroups</span> <span class="n">payGroups</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PayGroups</span><span class="o">(</span><span class="n">pays</span><span class="o">);</span>
        <span class="nc">Long</span> <span class="n">naverPaySum</span> <span class="o">=</span> <span class="n">payGroups</span><span class="o">.</span><span class="na">getNaverPaySum</span><span class="o">();</span>

        <span class="n">assertThat</span><span class="o">(</span><span class="n">naverPaySum</span><span class="o">).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="mi">2500</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="4-이름이-있는-컬렉션">4. 이름이 있는 컬렉션</h2>
<p>마지막 장점은 <strong>컬렉션에 이름을 붙일 수 있다</strong>는 것이다.<br />
<strong>같은 Pay들의 모임이지만 네이버페이의 List와 카카오페이의 List는 다르다.</strong><br />
그렇다면 이 둘을 구분하려면 어떻게 해야할까?<br />
가장 흔한 방법은 변수명을 다르게 하는 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="n">컬렉션을_변수명으로</span><span class="o">(){</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">naverPays</span> <span class="o">=</span> <span class="n">createNaverPays</span><span class="o">();</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">kakakoPays</span> <span class="o">=</span> <span class="n">createKakaoPays</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위와 같이 변수명으로 선언했을 떄의 단점은 뭘까?</p>
<ul>
  <li>검색이 어렵다
    <ul>
      <li>네이버 페이 그룹이 어떻게 사용되는지 검색 시 <strong>변수명으로만 검색할 수 있다.</strong></li>
      <li>이 상황에서 검색은 거의 불가능하다.</li>
      <li><strong>네이버 페이 그룹</strong>이라는 뜻은 <strong>개발자마다 다르게 지을 수 있기 때문</strong>이다.</li>
      <li>네이버 페이 그룹은 어떤 검색어로 검색이 가능할까….?</li>
    </ul>
  </li>
  <li>명확한 표현이 불가능하다.
    <ul>
      <li>변수명에 불과하기 때문에 <strong>의미를 부여하기 어렵다.</strong></li>
      <li>이는 개발팀/운영팀간에 의사소통 시 보편적인 언어로 사용하기가 어려움을 이야기한다.</li>
      <li>중요한 값임에도 <strong>이를 표현할 명확한 단어가 없는 것</strong>이다.</li>
    </ul>
  </li>
</ul>

<p>위 문제 역시 일급 컬렉션으로 쉽게 해결할 수 있다.<br />
네이버 페이 그룹과 카카오 페이 그룹 각각의 일급 컬렉션을 만들면 <strong>이 컬렉션 기반으로 용어사용과 검색</strong>을 하면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">컬렉션을_변수명으로</span><span class="o">(){</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">naverPays</span> <span class="o">=</span> <span class="n">createNaverPays</span><span class="o">();</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">kakakoPays</span> <span class="o">=</span> <span class="n">createKakaoPays</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>개발팀/운영팀 내에서 사용될 표현은 이제 이 컬렉션에 맞추면 된다.<br />
검색 역시 이 컬렉션 클래스를 검색하면 모든 사용 코드를 찾아낼 수 있다.</p>

<h2 id="마무리">마무리</h2>
<p>처음에 소트웍스 앤솔로지의 객체지향 생활체조 파트에서 언급된 일급 컬렉션에 대한 설명은 잘 이해가 안갔다.<br />
코드를 직접 보지 않으면 이해가 잘 안가는 스타일이라 그런가보다.<br />
그런데 다행이도 이렇게 너무 자세하게 남겨주신 향로님께 감사의 말씀을 드리고 싶다.<br />
올려주신 글을 보며 같이 타이핑해가면서, 소스 코드를 구현하면서 보니 이해가 더 잘된다.<br />
이제는 왜 일급 컬렉션을 왜 써야하는지 공감이 간다! :D</p>

<h3 id="참고">참고</h3>
<ul>
  <li><a href="https://developerfarm.wordpress.com/2012/02/01/object_calisthenics_/">소트웍스 앤솔러지 - 규칙 8: 일급 콜렉션 사용</a></li>
  <li><a href="https://jojoldu.tistory.com/412">일급 컬렉션 (First Class Collection)의 소개와 써야할 이유</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="java" /><category term="java" /><summary type="html"><![CDATA[우아한 테크캠프 Pro 프리코스 2주차 과제에서는 1주차 과제에서 추가로 일급 콜렉션을 사용하라는 프로그래밍 요구사항이 추가되었다. 일급 컬렉션이란 무엇인지, 어떤 장점들이 있기에 객체지향적이고 리팩토링하기 쉬운 코드를 짜기위해 필요한지 알아보려한다.]]></summary></entry><entry><title type="html">[Java] 원시값과 문자열의 포장</title><link href="https://icechoco.github.io/java/2022-04-22-wrap-primitive-type/" rel="alternate" type="text/html" title="[Java] 원시값과 문자열의 포장" /><published>2022-04-22T00:00:00+09:00</published><updated>2022-04-22T23:39:54+09:00</updated><id>https://icechoco.github.io/java/wrap-primitive-type</id><content type="html" xml:base="https://icechoco.github.io/java/2022-04-22-wrap-primitive-type/"><![CDATA[<p>우아한 테크캠프 Pro 프리코스 2주차 과제에서는 1주차 과제에서 추가로 <strong>모든 원시값과 문자열을 포장하라</strong>라는 프로그래밍 요구사항이 추가되었다.</p>
<ul>
  <li><span style="color:grey"><em>2기_오렌지님이 올려주신 <a href="https://tecoble.techcourse.co.kr/post/2020-05-29-wrap-primitive-type/">원시 타입을 포장해야 하는 이유</a>를 보고 정리한 글입니다.</em> </span></li>
</ul>

<p>우선 소트웍스 앤솔로지의 객체지향 생활체조 파트에서 언급된 내용은 아래와 같다.</p>
<blockquote>
  <p>규칙 3: 원시값과 문자열의 포장
int 값 하나 자체는 그냥 아무 의미 없는 스칼라 값일 뿐이다.<br />
어떤 메서드가 int 값을 매개변수로 받는다면 그 메서드 이름은 해당 매개변수의 의도를 나타내기 위해 모든 수단과 방법을 가리지 않아야 한다.
만약 똑같은 메서드가 시간을 매개변수로 받을 경우, 무슨 일이 생기는지는 훨씬 자명하다.<br />
이런 작은 객체가 프로그램의 유지보수성을 높일 수 있는 것은 시간 값을 매개변수로 받는 메서드에게 연도 값을 넘길 수는 없기 때문이다.<br />
원시형 변수로는 컴파일러가 의미적으로 맞는 프로그램 작성을 안내할 수 없다.<br />
객체로라면 아주 사소하더라도 컴파일러와 프로그래머에게 그 값이 어떤 값이며, 왜 쓰고 있는지에 대한 정보를 전하는 셈이다.</p>

  <p>또한 시간이나 돈과 같은 작은 객체는 행위를 놓을 분명한 곳을 마련해 줘서, 그렇지 않았다면 다른 클래스의 주위를 겉돌았을지도 모르는 사태를 방지한다.
이는 특히 게터와 세터에 관련된 규칙을 적용하고 그런 작은 객체만이 값에 접근할 수 있을 때 그렇다.</p>
</blockquote>

<p>변수를 선언하는 방법에는 두 가지가 있다.</p>
<ul>
  <li>원시타입의 변수를 선언하는 방법</li>
  <li>원시 타입의 변수를 객체로 포장한 변수를 선언하는 방법
(Collection으로 선언한 변수도 포장한다. 이를 일급 컬렉션이라 하며 본 블로그의 <code class="language-plaintext highlighter-rouge">[Java] 일급 컬렉션 (First Class Collection)이란?</code>글을 참고하길 바란다.)
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>
<span class="nc">Age</span> <span class="n">age</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Age</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>이번 글에서는 객체지향 생활 체조에서도 언급된 <strong>원시 타입의 값을 객체로 포장하면 얻을 수 있는 이점</strong>들에 대해 보겠다.</p>

<h2 id="자신의-상태-객체를-스스로-관리할-수-있다">자신의 상태 객체를 스스로 관리할 수 있다.</h2>
<p>User라는 클래스에서, 사용자의 나이를 가지고 있다고 가정해보자.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위의 형태처럼 원시타입인 int로 나이를 가지고 있으면 어떻게 될까? 쉽게 생각해보면 우선, 아래의 소스코드 처럼 나이에 관한 유효성 검사를 User 클래스에서 하게 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="nc">String</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">age</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"나이는 0살부터 시작합니다."</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 예시는 User 클래스의 멤버변수가 나이밖에 없어 문제를 크게 못느낄 수도 있다. 사용자의 이름, 이메일 등 추가적인 값들을 관리하게 된다면 문제가 생길 수 밖에 없다.<br />
두 글자 이상의 이름만을 지원한다고 가정하고, 이름 변수를 추가해보자 !</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="nc">String</span> <span class="n">nameValue</span><span class="o">,</span> <span class="nc">String</span> <span class="n">ageValue</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">ageValue</span><span class="o">);</span>
        <span class="n">validateAge</span><span class="o">(</span><span class="n">age</span><span class="o">);</span>
        <span class="n">validateName</span><span class="o">(</span><span class="n">nameValue</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">nameValue</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">()&lt;</span><span class="mi">2</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"이름은 두 글자 이상이어야 합니다."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">age</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"나이는 0살부터 시작합니다."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>두개의 멤버변수를 선언했을 뿐인데 User 클래스가 할 일이 늘어나 버렸다. <strong>이름</strong> 값에 대한 상태 관리, <strong>나이</strong> 값에 대한 상태 관리를 모두 해야한다.<br />
User 클래스는 분명히</p>
<blockquote>
  <p>아, 나는 사용자 그 자체 상태만 관리하고 싶은데 왜 자잘 자잘 한 것 까지 내가 관리해야돼? 이건 불합리해!</p>
</blockquote>

<p>라고 생가하지 않을까?<br />
그럼, 원시타입 변수를 포장해보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
   <span class="kd">private</span> <span class="nc">Name</span> <span class="n">name</span><span class="o">;</span>
   <span class="kd">private</span> <span class="nc">Age</span> <span class="n">age</span><span class="o">;</span>

   <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="nc">String</span> <span class="n">nameValue</span><span class="o">,</span> <span class="nc">String</span> <span class="n">ageValue</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Name</span><span class="o">(</span><span class="n">nameValue</span><span class="o">);</span>
      <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Age</span><span class="o">(</span><span class="n">ageValue</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Name</span> <span class="o">{</span>
   <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

   <span class="kd">public</span> <span class="nf">Name</span><span class="o">(</span><span class="nc">String</span> <span class="n">nameValue</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">()&lt;</span><span class="mi">2</span><span class="o">){</span>
         <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"이름은 두 글자 이상이어야 합니다."</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Age</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Age</span><span class="o">(</span><span class="nc">String</span> <span class="n">ageValue</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">ageValue</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">age</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"나이는 0살부터 시작합니다."</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>User 클래스가 해방됐다.</p>
<blockquote>
  <p>와! 나 이제 예외 처리 안 해도 돼!</p>
</blockquote>

<p>이름과 나이 값이 각각의 Name, Age가 담당하도록 바뀌었다.<br />
유효성 검증을 비롯한 이름, 나이 값에 대한 상태값을 User에 넘기지 않고 스스로 관리할 수 있게 되었다. 책임이 명확해졌다.</p>

<h2 id="코드의-유지보수에-도움이-된다">코드의 유지보수에 도움이 된다.</h2>
<p>이번엔 다른 예시이다. 다음은 로또 미션의 LottoNumber, Lotto, WinningLotto 클래스의 일부이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoNumber</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="no">MIN_LOTTO_NUMBER</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="no">MAX_LOTTO_NUMBER</span> <span class="o">=</span> <span class="mi">45</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="nc">String</span> <span class="no">OUT_OF_RANGE</span> <span class="o">=</span> <span class="s">"로또번호는 1~45의 범위입니다."</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">LottoNumber</span><span class="o">&gt;</span> <span class="no">NUMBERS</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">lottoNumber</span><span class="o">;</span>

    <span class="kd">static</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="no">MIN_LOTTO_NUMBER</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">MIN_LOTTO_NUMBER</span> <span class="o">+</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="no">NUMBERS</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="k">new</span> <span class="nc">LottoNumber</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">LottoNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">lottoNumber</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lottoNumber</span> <span class="o">=</span> <span class="n">lottoNumber</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">LottoNumber</span> <span class="nf">of</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">){</span>
        <span class="nc">LottoNumber</span> <span class="n">lottoNumber</span> <span class="o">=</span> <span class="no">NUMBERS</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">lottoNumber</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="no">OUT_OF_RANGE</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">lottoNumber</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Lotto</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">LottoNumber</span><span class="o">&gt;</span> <span class="n">lottoNumbers</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Lotto</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">LottoNumber</span><span class="o">&gt;</span> <span class="n">lottoNumbers</span><span class="o">){</span>
        <span class="n">validateDuplication</span><span class="o">(</span><span class="n">lottoNumbers</span><span class="o">);</span>
        <span class="n">validateAmountOfNumbers</span><span class="o">(</span><span class="n">lottoNumbers</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lottoNumbers</span> <span class="o">=</span> <span class="n">lottoNumbers</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateAmountOfNumbers</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">LottoNumber</span><span class="o">&gt;</span> <span class="n">lottoNumbers</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateDuplication</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">LottoNumber</span><span class="o">&gt;</span> <span class="n">lottoNumbers</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WinnigLotto</span> <span class="o">{</span>
    <span class="c1">//...</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">BONUS_CANNOT_BE_DUPLICATE_WITH_WINNING_NUMBER</span> <span class="o">=</span>
            <span class="s">"보너스 넘버는 위닝 넘버와 중복될 수 없습니다."</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">Lotto</span> <span class="n">winningLottoNumbers</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">bonusNumbers</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">WinnigLotto</span><span class="o">(</span><span class="nc">Lotto</span> <span class="n">winningLottoNumbers</span><span class="o">,</span> <span class="kt">int</span> <span class="n">bonusNumbers</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">winningLottoNumbers</span> <span class="o">=</span> <span class="n">winningLottoNumbers</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isBonusNumberDuplicatedWithWinningNumber</span><span class="o">(</span><span class="n">winningLottoNumbers</span><span class="o">,</span> <span class="n">bonusNumbers</span><span class="o">)){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="no">BONUS_CANNOT_BE_DUPLICATE_WITH_WINNING_NUMBER</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">bonusNumbers</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="n">bonusNumbers</span> <span class="o">&gt;</span> <span class="mi">45</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">bonusNumbers</span> <span class="o">=</span> <span class="n">bonusNumbers</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isBonusNumberDuplicatedWithWinningNumber</span><span class="o">(</span><span class="nc">Lotto</span> <span class="n">winningLottoNumbers</span><span class="o">,</span> <span class="kt">int</span> <span class="n">bonusNumbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위의 코드를 살펴보면 Lotto 클래스에서는 int 값인 로또 숫자 하나하나를 <code class="language-plaintext highlighter-rouge">LottoNumber</code>로 포장해서 사용하고 있는 것을 볼 수 있다.<br />
(<code class="language-plaintext highlighter-rouge">List&lt;int&gt;</code>가 아닌 <code class="language-plaintext highlighter-rouge">List&lt;LottoNumber&gt;</code> 사용)</p>

<p>물론 LottoNumber 대신에 Integer, int와 같은 자료형을 사용할 수도 있다.(아마 캐싱은 하지 않았거나, Lotto 클래스 내부에서 이루어졌을 것이다.)<br />
그렇게 되면 위에서 다루었듯이 <strong>개별 로또 숫자</strong>에 관한 관리가 <strong>로또</strong>에서 이루어져 로또가 수행하는 일이 늘어날 수 밖에 없어진다.<br />
자연히 Lotto 클래스의 크기도 커지게 될 것이다. 객체지향과도 작별 인사를 할 수 밖에 없어진다.</p>

<p>또 다른 문제도 있다. 현재는 로또 숫자의 범위가 1~45인데 혹여나 많은 사람들이 당첨되면 좋겠다는 생각을 하는 사람이 나타나서 나는 로또 숫자의 범위를<br />
1-10으로 할거야!라며 <strong>조건을 변경시키고, 추가시킨다면?</strong> 만약 Winning의 예시처럼 로또 숫자가 원시값이라면 같은 조건의 로또 숫자가 사용되는<br />
WinningLotto 클래스의 Lotto 클래스를 모두 고칠 수 밖에 없어진다.</p>
<blockquote>
  <p>정말 비효율적이다.</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WinnigLotto</span> <span class="o">{</span>
    <span class="c1">//...</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">BONUS_CANNOT_BE_DUPLICATE_WITH_WINNING_NUMBER</span> <span class="o">=</span>
            <span class="s">"보너스 넘버는 위닝 넘버와 중복될 수 없습니다."</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">Lotto</span> <span class="n">winningLottoNumbers</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">LottoNumber</span> <span class="n">bonusNumbers</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">WinnigLotto</span><span class="o">(</span><span class="nc">Lotto</span> <span class="n">winningLottoNumbers</span><span class="o">,</span> <span class="nc">LottoNumber</span> <span class="n">bonusNumbers</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">winningLottoNumbers</span> <span class="o">=</span> <span class="n">winningLottoNumbers</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isBonusNumberDuplicatedWithWinningNumber</span><span class="o">(</span><span class="n">winningLottoNumbers</span><span class="o">,</span> <span class="n">bonusNumbers</span><span class="o">)){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="no">BONUS_CANNOT_BE_DUPLICATE_WITH_WINNING_NUMBER</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">bonusNumbers</span> <span class="o">=</span> <span class="n">bonusNumbers</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isBonusNumberDuplicatedWithWinningNumber</span><span class="o">(</span><span class="nc">Lotto</span> <span class="n">winningLottoNumbers</span><span class="o">,</span> <span class="kt">int</span> <span class="n">bonusNumbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>비효율성을 제거하기 위해 위처럼 원시값인 개별 로또 숫자를 LottoNumber로 포장만해 주면 로또 숫자의 확장, 변경에 대해 유연해진다.<br />
Lotto와 WinningLotto는 전혀 바꿀 필요가 없다. 로또 숫자를 포장한 LottoNumver만 수정해주면 되기 때문이다.</p>

<h2 id="자료형에-구애받지-않는다여러-타입의-지원이-가능하다">자료형에 구애받지 않는다.(여러 타입의 지원이 가능하다.)</h2>
<p>점수라는 값을 포장한 Score 클래스가 있다. 현재 점수는 int 값이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Scroe</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">score</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Scroe</span><span class="o">(</span><span class="kt">int</span> <span class="n">score</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">validateScore</span><span class="o">(</span><span class="n">score</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">score</span> <span class="o">=</span> <span class="n">score</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateScore</span><span class="o">(</span><span class="kt">int</span> <span class="n">score</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>점수를 보여주는 역할만 했던 Score 객체에 연산 등의 기능이 추가되어 새로운 자료형의 지원이 필요해졌다면?<br />
기존의 Score 변수를 없앨 필요가 없다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Scroe</span> <span class="o">{</span>
   <span class="kd">private</span> <span class="kt">int</span> <span class="n">score</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kt">double</span> <span class="n">doubleScore</span><span class="o">;</span>

   <span class="kd">public</span> <span class="nf">Scroe</span><span class="o">(</span><span class="kt">int</span> <span class="n">score</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">validateScore</span><span class="o">(</span><span class="n">score</span><span class="o">);</span>
      <span class="k">this</span><span class="o">.</span><span class="na">score</span> <span class="o">=</span> <span class="n">score</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="nf">Scroe</span><span class="o">(</span><span class="kt">double</span> <span class="n">doubleScore</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">validateDobuleScore</span><span class="o">(</span><span class="n">doubleScore</span><span class="o">);</span>
      <span class="k">this</span><span class="o">.</span><span class="na">doubleScore</span> <span class="o">=</span> <span class="n">doubleScore</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateScore</span><span class="o">(</span><span class="kt">int</span> <span class="n">score</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">//...</span>
   <span class="o">}</span>

   <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateDobuleScore</span><span class="o">(</span><span class="kt">double</span> <span class="n">doubleScore</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">//...</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>앞서 말했듯이 유지, 보수에 도움이 되는 점을 이요하면 된다. 기존 Score 클래스를 활용하면 된다.<br />
doubleScore라는 멤버변수를 추가하고, 생성자 오버로딩을 통해 간단히 해결할 수 있다. String 값이 필요하다 해도 마찬가지로 해결이 가능하다.</p>

<h2 id="마무리">마무리</h2>
<p>원시 타입을 포장하게 되면, 그 변수가 의미하는 바를 정확하게 나타낼 수 있다.<br />
책임 관계 또한 명확해지고 코드의 유지, 보수에도 많은 도움이 된다.<br />
실제 프리코스 2주차 자동차 경주게임을 구현해보면서 그 장점을 느껴보고 싶다 !</p>

<h3 id="참고">참고</h3>
<ul>
  <li><a href="https://tecoble.techcourse.co.kr/post/2020-05-29-wrap-primitive-type/">유원시 타입을 포장해야 하는 이유</a></li>
  <li><a href="https://developerfarm.wordpress.com/2012/01/27/object_calisthenics_4/">소트웍스 앤솔러지 - 규칙 3: 원시값과 문자열의 포장</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="java" /><category term="java" /><category term="OOP" /><category term="OBJECT-CALISTHENIC" /><summary type="html"><![CDATA[우아한 테크캠프 Pro 프리코스 2주차 과제에서는 1주차 과제에서 추가로 모든 원시값과 문자열을 포장하라라는 프로그래밍 요구사항이 추가되었다. 2기_오렌지님이 올려주신 원시 타입을 포장해야 하는 이유를 보고 정리한 글입니다.]]></summary></entry><entry><title type="html">[Java] 람다식 문법</title><link href="https://icechoco.github.io/java/2022-04-22-lambda-expression-syntax/" rel="alternate" type="text/html" title="[Java] 람다식 문법" /><published>2022-04-22T00:00:00+09:00</published><updated>2022-04-22T21:05:27+09:00</updated><id>https://icechoco.github.io/java/lambda-expression-syntax</id><content type="html" xml:base="https://icechoco.github.io/java/2022-04-22-lambda-expression-syntax/"><![CDATA[<p>예제로 람다식 문법에 대해 배워보자. 아래 예제는 0부터 9까지의 숫자를 출력하는 2가지 방법에 대해 서술한다.</p>

<h2 id="1-전통적인-방법">1. 전통적인 방법</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>위는 기초 프로그래밍에서 흔히 볼 수 있는 for문을 이욯한 아주 기초적인 코드다.<br />
이는 각각의 요소들을 하나하나 일일이 검증하며 순차적으로 값을 확인하여 조건절이 끝날떄까지 진행되고 있으며, 이러한 코드는 특별한 경우라면 최적화되지 않고 들어오는 순서대로 진행된다.</p>

<h2 id="2-더-나은-방법">2. 더 나은 방법</h2>
<p>그러나 빨리 끝나는 일을 먼저 하거나 한번에 여러가지 일을 하는 것이 당연히 효율적이며 짧은 시간내에 작업을 끝낼 수 있다.<br />
또한 <strong>1부터 10까지 1씩 증가하면서 이 코드를 순차적으로 실행해라</strong>라고 <strong>명령</strong>하는 것 보다는<br />
<strong>여기 있는거 다 해</strong>라고 <strong>설명</strong>하는 것이 더욱 직관적이며 간결하다.</p>

<p>이러한 방식을 <code class="language-plaintext highlighter-rouge">Tell, Don't Ask</code>원칙이라 하며, 우리말로 한다면 <code class="language-plaintext highlighter-rouge">묻지 않고 시키기</code>로 볼 수 있다.
아래는 <code class="language-plaintext highlighter-rouge">Tell, Don't Ask</code>원칙에 따라 람다식으로 재작성한 코드로, 이렇게 할 경우 기초적인 수준에서 생기는 장점은 for문과는 달리 개념적으로 설명이 단순해 이해가 빠르다는 점이며,<br />
여기서는 잘 드러나지 않지만 복잡한 프로그래밍을 할 때 코드가 간결해지는 장점이 있다.
게다가 순수 함수로만 코드를 작성하면 for문과 i등의 변수를 사용하는 방식과 다르게 매번 같은 동작이 보장되서 병렬처리가 보다 수월해진다.</p>

<ul>
  <li>Java 8부터 지원되는 람다식을 사용한 코드
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">10</span><span class="o">).</span><span class="na">forEach</span><span class="o">((</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">value</span><span class="o">));</span>
</code></pre></div>    </div>
  </li>
  <li>컴파일러의 추론을 통해 파라미터의 자료형을 생략한 코드
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">10</span><span class="o">).</span><span class="na">forEach</span><span class="o">((</span><span class="n">value</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">value</span><span class="o">));</span>
</code></pre></div>    </div>
  </li>
  <li>메서드 참조를 사용한 코드
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">10</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="참고">참고</h3>
<ul>
  <li><a href="https://namu.wiki/w/%EB%9E%8C%EB%8B%A4%EC%8B%9D">소트웍스 앤솔러지 - 규칙 8: 일급 콜렉션 사용</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="java" /><category term="java" /><summary type="html"><![CDATA[예제로 람다식 문법에 대해 배워보자. 아래 예제는 0부터 9까지의 숫자를 출력하는 2가지 방법에 대해 서술한다.]]></summary></entry><entry><title type="html">[jekyll] jekyll 실행 시 cannot load such file – webrick (LoadError) 에러 조치 방법</title><link href="https://icechoco.github.io/frontend/2022-04-21-jekyll-error-webrick/" rel="alternate" type="text/html" title="[jekyll] jekyll 실행 시 cannot load such file – webrick (LoadError) 에러 조치 방법" /><published>2022-04-21T00:00:00+09:00</published><updated>2022-04-22T21:38:17+09:00</updated><id>https://icechoco.github.io/frontend/jekyll-error-webrick</id><content type="html" xml:base="https://icechoco.github.io/frontend/2022-04-21-jekyll-error-webrick/"><![CDATA[<p>데스크탑 컴퓨터를 최근에 포맷 후 개발환경 셋팅을 다시 하는 중이다. 포맷 이후 노트북에서만 작업하다가 데탑에서 블로그 포스팅 작업을 하려고 <code class="language-plaintext highlighter-rouge">bundle exec jekyll serve</code>로
로컬에서 jekyll 서버를 구동하려고했다. 근데 아래와 같이 webrick을 로드하지 못했다는 오류가 발생했다.</p>

<p><img src="/assets\img/jekyll-webrick-error.png" alt="jekyll-webrick-error" /></p>

<p>이런 경우 <code class="language-plaintext highlighter-rouge">bundle add webrick</code>으로 webrick을 추가해주고 다시 실행하면 된다.<br />
이유는 ruby 3.0.0부터 webrick이 기본으로 포함된 gem에서 빠졌기 때문이다.</p>

<h3 id="참고">참고</h3>
<ul>
  <li><a href="https://junho85.pe.kr/1850">jekyll 실행 시킬 때 `require’: cannot load such file – webrick (LoadError) 오류가 난다면 bundle add webrick</a></li>
  <li><a href="github.com/jekyll/jekyll/issues/8523">Jekyll serve fails on Ruby 3.0 #8523</a></li>
  <li><a href="https://www.ruby-lang.org/en/news/2020/12/25/ruby-3-0-0-released/">Ruby 3.0.0 Released</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="frontEnd" /><category term="Web" /><category term="jekyll" /><summary type="html"><![CDATA[데스크탑 컴퓨터를 최근에 포맷 후 개발환경 셋팅을 다시 하는 중이다. 포맷 이후 노트북에서만 작업하다가 데탑에서 블로그 포스팅 작업을 하려고 bundle exec jekyll serve로 로컬에서 jekyll 서버를 구동하려고했다. 근데 아래와 같이 webrick을 로드하지 못했다는 오류가 발생했다.]]></summary></entry><entry><title type="html">[우아한 테크캠프 Pro] 우아한 테크캠프 Pro 프리코스 1주차 공통 피드백</title><link href="https://icechoco.github.io/java/2022-04-19-woowa-precourse-week1-common-feedback/" rel="alternate" type="text/html" title="[우아한 테크캠프 Pro] 우아한 테크캠프 Pro 프리코스 1주차 공통 피드백" /><published>2022-04-19T00:00:00+09:00</published><updated>2022-04-22T21:38:17+09:00</updated><id>https://icechoco.github.io/java/woowa-precourse-week1-common-feedback</id><content type="html" xml:base="https://icechoco.github.io/java/2022-04-19-woowa-precourse-week1-common-feedback/"><![CDATA[<p>우아한 테크캠프 Pro 프리코스 1주차 과제를 진행하면서 받은 공통 피드백을 정리해보겠다.</p>

<h2 id="이름을-통해-의도를-드러내라">이름을 통해 의도를 드러내라</h2>
<p>변수 이름, 함수(메소드) 이름, 클ㄹㅐ스 이름을 짓는데 시간을 투자하라.
이름을 통해 변수의 역할, 함수의 역할, 클래스의 역할에 대한 의도를 드러내기위해 노력하라.
연속적인 숫자를 덧붙인 이름(a1, a2, …, aN) 덧붙이거나 불용어(Info, Daa, a, an, the)를 추가하는 방식은 적절하지 못하다.</p>

<h2 id="축약하지마라">축약하지마라</h2>
<p>의도를 드러낼 수 있다면 이름이 길어져도 괜찮다.</p>

<h2 id="개발도구의-code-format-기능을-활용해라">개발도구의 code format 기능을 활용해라</h2>
<p>IntelliJ 또는 Eclipse의 formatting 기능을 활용한다.</p>
<ul>
  <li>IntelliJ : <strong>Ctrl+Alt+L(윈도우)</strong>, Cmd+Alt+L(맥)</li>
  <li>Eclipse : Ctrl+Shift+F(윈도우), Cmd+Shift+F(맥)</li>
</ul>

<h2 id="space공백도-convention이다">space(공백)도 convention이다.</h2>
<p>for, while, if문 사이의 space도 convention이다.</p>

<h2 id="불필요하게-공백-라인을-만들지-않는다">불필요하게 공백 라인을 만들지 않는다.</h2>
<p>공백 라인을 띄우는 것도 코드상에 문맥이 달라지는 부분에 의도를 가지고 띄우면 좋겠다.</p>

<h2 id="구현-순서도-convetion이다">구현 순서도 Convetion이다.</h2>
<p>클래스의 구현 순서에 대한 convetion을 지키는 것도 읽기 좋은 코드를 구현하는데 의미가 있다.
클래스의 구현 순서를 지키면서 프로그래밍한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class A {
상수(static final) 또는 클래스 변수

인스턴스 변수

생성자

메소드
}
</code></pre></div></div>

<h2 id="반복하지마라">반복하지마라</h2>
<p>중복은 소프트웨어에서 모든 악의 근원이다.</p>

<h2 id="space-vs-tab-혼용">space vs tab 혼용</h2>
<p>들여쓰기에 space와 tab을 혼용하지 않는다.
둘중에 하나만 사용한다.
확신이 서지 않으면 pull request를 보낸 후 들여쓰기가 잘 되어 있는지 확인하는 습관을 들인다.</p>

<h2 id="의미없는-주석을-달지-않는다">의미없는 주석을 달지 않는다.</h2>
<p>변수 이름, 함수(메소드) 이름을 통해 어떤 의도인지가 드러난다면 굳이 주석을 달지 않는다.
모든 변수와 함수에 주석을 달기보다는 가능하면 이름을 통해 의도를 드러내고, 의도를 드러내기 힘든 경우 주석을 다는 연습을한다.</p>

<h2 id="값을-하드코딩-하지마라">값을 하드코딩 하지마라.</h2>
<p>문자열 숫자 등의 값을 하드코딩하지 마라.
상수(static final)를 만들고 이름을 부여해 이 변수의 역할이 무엇인지 의도를 드러내라.
구글에서 “java 상수”와 같은 키워드로 검색해 상수 구현 방법을 학습하고 적용해 본다.</p>

<h2 id="git-commit-메시지를-의미있게-작성">git commit 메시지를 의미있게 작성</h2>
<p>commit 메시지에 해당 commit에서 작업한 내용에 대한 이해가 가능하도록 작성한다.</p>

<h2 id="기능-목록-업데이트">기능 목록 업데이트</h2>
<p><code class="language-plaintext highlighter-rouge">README.md</code> 파일에 작성하는 기능 목록은 기능 구현을 하면서 변경될 수 있다.
시작할 때 모든 기능 목록을 완벽하게 정리해야 한다는 부담을 가지기 보다 기능을 구현하면서 문서를 계속 업데이트한다.
죽은 문서가 아니라 살아있는 문서를 만들기 위해 노력한다.</p>

<h2 id="기능-목록-구현을-재검토한다">기능 목록 구현을 재검토한다.</h2>
<p>기능 목록을 클래스 설계와 구현, 함수(메소드) 설계와 구현과 같이 너무 상세하게 적지 않는다.
클래스 이름, 함수(메소드) input/output은 언제든지 변경될 수 있기 때문이다.
너무 세세한 부분까지 정리하기보다 구현해야할 기능 목록을 정리하는데에 집중한다.
<strong>정상적인 경우도 중요하지만 예외적인 상황도 기능 목록에 정리</strong>한다.
특히 예외 상황은 시작 단계에서 모두 찾기 힘들기 때문에 기능을 구현하면서 계속 추가해 나간다.</p>

<h2 id="readmemd를-상세히-작성">README.md를 상세히 작성</h2>
<p>미션 저장소의 README.md는 소스코드에 앞서 해당 프로젝트가 어떠한 프로젝트인지 <strong>마크다운</strong>으로 작성하여 소개하는 문서이다.
해당 프로젝트가 어떠한 프로젝트이며, 어떤 기능을 담고 있는지 기술하기 위해서 마크다운 문법을 검색해서 학습해보고 적용해본다.</p>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="java" /><category term="java" /><summary type="html"><![CDATA[우아한 테크캠프 Pro 프리코스 1주차 과제를 진행하면서 받은 공통 피드백을 정리해보겠다.]]></summary></entry></feed>