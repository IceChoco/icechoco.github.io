<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://icechoco.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://icechoco.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2021-10-11T23:45:43+09:00</updated><id>https://icechoco.github.io/feed.xml</id><title type="html">IceChoco</title><subtitle>Hydejack is a boutique Jekyll theme for hackers, nerds, and academics, with a focus on personal sites that are meant to impress.
</subtitle><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><entry><title type="html">node.js 기초</title><link href="https://icechoco.github.io/server/2021-10-11-node-js-%EA%B8%B0%EC%B4%88/" rel="alternate" type="text/html" title="node.js 기초" /><published>2021-10-11T00:00:00+09:00</published><updated>2021-10-11T20:27:09+09:00</updated><id>https://icechoco.github.io/server/node-js-%EA%B8%B0%EC%B4%88</id><content type="html" xml:base="https://icechoco.github.io/server/2021-10-11-node-js-%EA%B8%B0%EC%B4%88/">&lt;p&gt;node.js를 활용한 서버 구축에 있어 필요한 기본 지식들을 기록해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;nodejs&quot;&gt;node.js&lt;/h2&gt;
&lt;p&gt;우선, node.js가 무엇인지 알아야겠죠? 이전에 자바스크립트는 크롬이나, IE와 같은 익스플로러 상에서만 사용이 가능했습니다. 그런데 node.js가 등장하고 나서 부터 자바스크립트를 서버사이드에서도 자바스크립트 사용이 가능해졌습니다.&lt;/p&gt;

&lt;h2 id=&quot;expressjs&quot;&gt;express.js&lt;/h2&gt;
&lt;p&gt;node.js를 이용해서 웹사이트나 어플리케이션을 쉽게 만들 수 있도록 도와주는 프레임워크입니다.
터미널을 실행하여 아래 명렁어를 실행하면 설치할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install express --save
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets\img/download-express-js.png&quot; alt=&quot;download-express-js&quot; /&gt;&lt;/p&gt;

&lt;p&gt;npm install 명령어 맨 뒤에 –save 명령어를 입력함으로써 package.json 파일의 dependencies 안에 express 버전이 추가된 것을 확인할 수 있습니다. 이렇게 추가를 해둠으로써 다른 사람이 봤을 때 쓰고있구나 하고 알 수 있게 해주는 역할을 합니다.&lt;/p&gt;

&lt;h2 id=&quot;indexjs&quot;&gt;index.js&lt;/h2&gt;
&lt;p&gt;백엔드 서버를 시작하면 index.js 파일에서 시작합니다.&lt;/p&gt;

&lt;h2 id=&quot;node_modules&quot;&gt;node_modules&lt;/h2&gt;
&lt;p&gt;다운받은 dependencies들 즉 라이브러리들이 이 폴더안에 들어가 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;npm-run-scripts&quot;&gt;npm run {scripts}&lt;/h2&gt;
&lt;p&gt;npm run {scripts} 수행 시 package.json 파일 안에 있는 scripts에 적혀있는 대로 수행됩니다. 예를 들어 package.json 파일의 scripts 부분이 아래와 같이 명시되어 있는 상태에서 npm run start를 수행한 경우 루트 경로에 있는 index.js가 수행됩니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;node index.js&quot;,       //npm run start
    &quot;build&quot;: &quot;react-scripts build&quot;, //npm run build
    &quot;test&quot;: &quot;react-scripts test&quot;,   //npm run test
    &quot;eject&quot;: &quot;react-scripts eject&quot;  //npm run eject
  },
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;!--author--&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="server" /><category term="server" /><summary type="html">node.js를 활용한 서버 구축에 있어 필요한 기본 지식들을 기록해보겠습니다.</summary></entry><entry><title type="html">Redux 설치하기</title><link href="https://icechoco.github.io/react/2021-10-11-Settint-Up-Redux/" rel="alternate" type="text/html" title="Redux 설치하기" /><published>2021-10-11T00:00:00+09:00</published><updated>2021-10-11T20:18:26+09:00</updated><id>https://icechoco.github.io/react/Settint-Up-Redux</id><content type="html" xml:base="https://icechoco.github.io/react/2021-10-11-Settint-Up-Redux/">&lt;p&gt;Redux를 자신이 개발할 어플리케이션에 설치하고 설정하는 방법을 기록하겠습니다. 우선 다운 받아야 할 dependency들이 redux, react-redux, redux-promise, redux-thunk까지 총 4개가 있습니다. 이 중에서 redux-promis, redux-thunk는 redux의 미들웨어입니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install redux react-redux redux-promise redux-thunk --save
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;redux-promise-redux-thunk가-필요한-이유&quot;&gt;redux-promise, redux-thunk가 필요한 이유&lt;/h2&gt;
&lt;p&gt;redux-promise, redux-thunk는 redux를 잘 쓸 수 있게 도와주는 역할을 하는 미들웨어입니다. redux는 redux store 안에 모든 state를 관리하고 있습니다. 이 store 안에 있는 state를 변경하기 위해서는 dispatch를 이용해서 action을 통해 변경시킬 수 있습니다. 이렇게 store가 데이터를 받을 때 항상 객체 형식으로 데이터를 받는 것이 아니라 때에 따라 promise, functions 형식으로 받기도 합니다. 그런데, redux 기초편에서 봤듯 우리는 reudx store는 객체 형식으로만 데이터를 받을 수 있다고 배웠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;redux-thunk&lt;/strong&gt;는 dispatch한테 어떻게 function 형식을 받는지 그 방법을 알려주고, &lt;strong&gt;redux-promise&lt;/strong&gt;는 dispatch한테 promise가 왔을 때 어떻게 해야하는지 store에게 알려주는 역할을 합니다. 즉 이 2가지를 다운받지 않고 promise, functions 형식을 받아 redux를 사용하면 에러가 발생합니다.&lt;/p&gt;

&lt;h2 id=&quot;combinereducers가-하는-역할&quot;&gt;combineReducers가 하는 역할&lt;/h2&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets\img/combine-reducer.PNG&quot; height=&quot;300px&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;
&lt;p&gt;store에는 reducer가 여러가지 있을 수 있습니다.이 reducer는 어떻게 state가 변하는 지를 보여준 다음, 변한 마지막 값을 리턴해주는 일을 합니다.
state는 유저, 구독 등 여러가지에 대한 state가 있을 수 있으므로 각각의 state에 따라 reducer도 나눠져 있습니다. redux에 내장되어 있는 combineReducer는 여러개의 reducer들을 Root Reducer에서 하나로 합쳐주는 역할을 합니다.&lt;/p&gt;

&lt;!--author--&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="react" /><category term="Web" /><category term="React" /><category term="Redux" /><summary type="html">Redux를 자신이 개발할 어플리케이션에 설치하고 설정하는 방법을 기록하겠습니다. 우선 다운 받아야 할 dependency들이 redux, react-redux, redux-promise, redux-thunk까지 총 4개가 있습니다. 이 중에서 redux-promis, redux-thunk는 redux의 미들웨어입니다. npm install redux react-redux redux-promise redux-thunk --save redux-promise, redux-thunk가 필요한 이유 redux-promise, redux-thunk는 redux를 잘 쓸 수 있게 도와주는 역할을 하는 미들웨어입니다. redux는 redux store 안에 모든 state를 관리하고 있습니다. 이 store 안에 있는 state를 변경하기 위해서는 dispatch를 이용해서 action을 통해 변경시킬 수 있습니다. 이렇게 store가 데이터를 받을 때 항상 객체 형식으로 데이터를 받는 것이 아니라 때에 따라 promise, functions 형식으로 받기도 합니다. 그런데, redux 기초편에서 봤듯 우리는 reudx store는 객체 형식으로만 데이터를 받을 수 있다고 배웠습니다.</summary></entry><entry><title type="html">CSS Framework, Ant Design을 활용한 효율적인 화면개발하기</title><link href="https://icechoco.github.io/react/2021-10-11-Screen-development-using-ant-design/" rel="alternate" type="text/html" title="CSS Framework, Ant Design을 활용한 효율적인 화면개발하기" /><published>2021-10-11T00:00:00+09:00</published><updated>2021-10-11T16:08:09+09:00</updated><id>https://icechoco.github.io/react/Screen-development-using-ant-design</id><content type="html" xml:base="https://icechoco.github.io/react/2021-10-11-Screen-development-using-ant-design/">&lt;p&gt;원래는 모든 것을 CSS를 활용해서 하나하나 만들 수 있지만, 그렇게 되면 기능을 신경 쓰는 것 이외에 너무 많은 시간을 CSS에 투자해야합니다. 그래서 기능 개발에 초점을 맞추기 위해 CSS 프레임 워크를 사용해보도록 하겠습니다. 요즘 많은 기업들이 실무에서도 CSS 프레임워크가 잘 되어 있어 많이 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;가장 유명한 프레임워크는 Mateiral UI, React Bootstrap, Semantic UI, Ant Design, Materialize가 있습니다. 저는 그 중 Ant Design을 활용해서 개발해보도록 하겠습니다. Ant Design은 중국에서 개발되었으며 많은 기능들이 들어있기 때문에 사이즈가 큰 편입니다. 하지만 스타일이 굉장히 깔끔하고 엔터프라이즈 환경에서도 어울리는 디자인 생성이 가능합니다. 가장 큰 장점은 사용하기가 굉장히 편합니다. Material UI도 좋은 프레임워크지만 처음 사용할 때 어려움이 있습니다.&lt;/p&gt;

&lt;p&gt;가장먼저 npm을 사용하여 Ant Design을 설치합니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install antd --save
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그 다음 사용할 곳에 아래 import문을 추가하면 ant Design을 사용할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import 'antd/dist/antd.css'; // or 'antd/dist/antd.less'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;참고&quot;&gt;참고&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://ant.design/&quot;&gt;Ant Design 공식 홈페이지&lt;/a&gt;&lt;/p&gt;

&lt;!--author--&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="react" /><category term="Web" /><category term="React" /><summary type="html">원래는 모든 것을 CSS를 활용해서 하나하나 만들 수 있지만, 그렇게 되면 기능을 신경 쓰는 것 이외에 너무 많은 시간을 CSS에 투자해야합니다. 그래서 기능 개발에 초점을 맞추기 위해 CSS 프레임 워크를 사용해보도록 하겠습니다. 요즘 많은 기업들이 실무에서도 CSS 프레임워크가 잘 되어 있어 많이 사용하고 있습니다.</summary></entry><entry><title type="html">Concurrently를 이용한 백서버와 클라이언트서버 동시 실행시키기</title><link href="https://icechoco.github.io/server/2021-10-11-Running-server-and-client-at-the-same-time/" rel="alternate" type="text/html" title="Concurrently를 이용한 백서버와 클라이언트서버 동시 실행시키기" /><published>2021-10-11T00:00:00+09:00</published><updated>2021-10-11T15:34:45+09:00</updated><id>https://icechoco.github.io/server/Running-server-and-client-at-the-same-time</id><content type="html" xml:base="https://icechoco.github.io/server/2021-10-11-Running-server-and-client-at-the-same-time/">&lt;p&gt;개발하면서 매번 터미널 두개 켜서 하나는 server run 시키고, 다른 하나는 react run 시키고 두 번 해줘야 하는게 정말 불편했습니다. 그러던 와중에 알게된 것은 바로 &lt;strong&gt;Concurrently&lt;/strong&gt;를 이용해서 백서버와 클라이언트서버를 동시에 실행시키는 것! 그래서 이번 글에서는 어떻게 Concurrently를 활용해서 동시에 실행시킬 수 있는지 알려드리겠습니다. 우선 사용을 위해서는 Concurrently 라이브러리를 다운받으셔야합니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install concurrently --save
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;설치 후 사용방법은 package.json 파일 내 “scripts” 부분에 실행할 명령어를 넣고 concurrenlty를 적은 뒤 켜고 싶은 것들을 차례대로 적어주시면 됩니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;dev&quot;: &quot;concurrently   \&quot;npm run backend\&quot; \&quot;npm run start --prefix client\&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/concurrently&quot;&gt;concurrently-npm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--author--&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="server" /><category term="server" /><summary type="html">개발하면서 매번 터미널 두개 켜서 하나는 server run 시키고, 다른 하나는 react run 시키고 두 번 해줘야 하는게 정말 불편했습니다. 그러던 와중에 알게된 것은 바로 Concurrently를 이용해서 백서버와 클라이언트서버를 동시에 실행시키는 것! 그래서 이번 글에서는 어떻게 Concurrently를 활용해서 동시에 실행시킬 수 있는지 알려드리겠습니다. 우선 사용을 위해서는 Concurrently 라이브러리를 다운받으셔야합니다. npm install concurrently --save 설치 후 사용방법은 package.json 파일 내 “scripts” 부분에 실행할 명령어를 넣고 concurrenlty를 적은 뒤 켜고 싶은 것들을 차례대로 적어주시면 됩니다. &quot;dev&quot;: &quot;concurrently \&quot;npm run backend\&quot; \&quot;npm run start --prefix client\&quot;&quot;</summary></entry><entry><title type="html">Redux 기초</title><link href="https://icechoco.github.io/react/2021-10-11-Redux-Basics/" rel="alternate" type="text/html" title="Redux 기초" /><published>2021-10-11T00:00:00+09:00</published><updated>2021-10-11T19:21:59+09:00</updated><id>https://icechoco.github.io/react/Redux-Basics</id><content type="html" xml:base="https://icechoco.github.io/react/2021-10-11-Redux-Basics/">&lt;p&gt;Redux는 상태관리 라이브러리(predictable state container) 입니다. 그렇다면 여기서 말하는 state가 뭘까요? React에서는 Props와 State가 있습니다. 이 두가지를 비교하면서 state에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;props-vs-state&quot;&gt;Props VS State&lt;/h2&gt;
&lt;h3 id=&quot;props&quot;&gt;Props&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Props는 Properties의 줄임말입니다.&lt;/li&gt;
  &lt;li&gt;부모 컴포넌트와 자식 컴포넌트가 있는 경우 데이터를 서로 주고 받아야겠죠? 두 컴포넌트간의 데이터를 주고 받을 때는 Props를 이용해야 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;단방향 데이터 흐름&lt;/strong&gt;: child component에 전달되는 값 또는 method. 부모 컴포넌트에서 자식 컴포넌트로 즉 위에서 아래로만 데이터 전달이 가능합니다. 반대로 child component에서 parent component로 전달은 불가능합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;read donly&lt;/strong&gt;: child component로 전달받은 props 값은 변하지 않습니다다. 만약 부모로부터 받은 값을 수정하고 싶다면 수정된 값으로 부모 컴포넌트에게서 다시 받아야 합니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;소스코드 예시&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;parent component&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import React, {component} from 'react';
  import Hello from './Hello';

  class App extends Component{
      rendor(){
          return(
              &amp;lt;Hello name=&quot;홍길동&quot;&amp;gt; //Hello라는 자식 컴포넌트에게 name이라는 변수를 전달한다.
          );
      }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;child component&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import React, {component} from 'react';

  class Hello extends Component{
      rendor(){
          return(
              &amp;lt;div&amp;gt;
                  안녕하세요. {this.props.name}님!!
              &amp;lt;/div&amp;gt;
          );
      }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;state&quot;&gt;State&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;컴포넌트가 가지고 있는 값&lt;/strong&gt;: parent component에서 child component로 보내는게 아닌 그 component 자체 안에서 데이터를 전달할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;state는 변할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;state가 변경되면, component가 re-rendering 됩니다. (즉, update 라이프 사이클이 수행됩니다)&lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;state의 변경은 반드시 setState()함수를 이용&lt;/span&gt;해줘야 합니다. 절대 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this.state.term = '검색어'&lt;/code&gt;와 같이 직접 할당할 수 없습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;소스코드 예시&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import React, {Component} from 'react';

class App extends Component{
    constructor(props){
        super(props);

        this.state = { //초기화
            term: &quot;&quot;,
        }
    }

    rendor(){
        return(
            &amp;lt;div&amp;gt;
                &amp;lt;input
                    onchange={(e) =&amp;gt; this.setState({term: e.target.value})} //수정
                &amp;gt;
                &amp;lt;/input&amp;gt;
                &amp;lt;div&amp;gt;InputText1 {this.state.term}&amp;lt;/div&amp;gt; //읽기
            &amp;lt;/div&amp;gt;
        );
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets\img/without-redux.PNG&quot; /&gt;&lt;/p&gt;
&lt;p&gt;그래서 Redux는 이러한 state를 관리해주는 툴입니다. 만약 아래처럼 Comments 라는 컴포넌트 안에 A라는 컴포넌트가 있고, 또 그 안에 B라는 컴포넌트가 있다고 해봅시다.&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets\img/redux-exam.PNG&quot; height=&quot;200px&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;
&lt;p&gt;B 컴포넌트에서 Action이 발생했다면 commments 컴포넌트에 어떤 액션이 일어났는지 알려줘야합니다. 이때 Redux가 없다면 B컴포넌트 → A컴포넌트 → Comments 컴포넌트로 하나하나 단계적으로 타고 올라가야합니다.&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets\img/redux-store.PNG&quot; height=&quot;200px&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;
&lt;p&gt;그런데 이때 상위 컴포넌트로 이동하는게 아니라 Redux 스토어에 저장을 해놓게되면 여러 컴포넌트를 거쳐 올라가지 않아도 B컴포넌트 → Store로 직접 접근이 가능하며, 반대로 store → B컴포넌트로도 직접 접근이 가능합니다. 여러개의 컴포넌트를 왔다갔다 해야하는 과정이 빠지니 훨씬 편하게 State관리를 할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;redux-데이터-flow&quot;&gt;Redux 데이터 Flow&lt;/h2&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets\img/redux-data-flow.PNG&quot; height=&quot;200px&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Redux는 철저하게 한뱡향 데이터 플로우를 가집니다(strict unidirectional data flow). 리액트 컴포넌트에서 시작되어 Action → Reduecer → Store를 거쳐 다시 리액트 컴포넌트로 돌아옵니다.&lt;/p&gt;

&lt;h3 id=&quot;action&quot;&gt;Action&lt;/h3&gt;
&lt;p&gt;Action은 무엇이 일어났는지 설명하는 객체입니다. 형식이 객체여야만 redux store가 내용을 받을 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{type: 'LIKE_ARTICLE', articleId: 42} //articleId 42번을 좋아요 했다.
{type: 'FETCH_USER_SUCCESS', response: {id:3, name: 'Mary'}} //이름이 Mary이고 id가 3번인 유저를 가져오는 것을 성공했다.
{type: 'ADD_TODO', text: 'Read the Redux docs.'} //이 텍스트를 todo List에 add했다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;reducer&quot;&gt;REDUCER&lt;/h3&gt;
&lt;p&gt;이 액션을 함으로 인해서 A였던 값이 B로 변했다는 것을 설명해줍니다. 자세하게는 이전 State와 action object를 받은 후에 next state를 return 해주는 역할을 합니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{previousState, action} =&amp;gt; nextState
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;store&quot;&gt;STORE&lt;/h3&gt;
&lt;p&gt;Application의 state을 감싸주는 역할을 합니다. 이 Store안에는 여러가지의 많은 메소드가 있습니다. 이 메소드를 이용하여 State를 관리할 수 있습니다.&lt;/p&gt;

&lt;!--author--&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="react" /><category term="Web" /><category term="React" /><category term="Redux" /><summary type="html">Redux는 상태관리 라이브러리(predictable state container) 입니다. 그렇다면 여기서 말하는 state가 뭘까요? React에서는 Props와 State가 있습니다. 이 두가지를 비교하면서 state에 대해 알아보겠습니다. Props VS State Props Props는 Properties의 줄임말입니다. 부모 컴포넌트와 자식 컴포넌트가 있는 경우 데이터를 서로 주고 받아야겠죠? 두 컴포넌트간의 데이터를 주고 받을 때는 Props를 이용해야 합니다. 단방향 데이터 흐름: child component에 전달되는 값 또는 method. 부모 컴포넌트에서 자식 컴포넌트로 즉 위에서 아래로만 데이터 전달이 가능합니다. 반대로 child component에서 parent component로 전달은 불가능합니다. read donly: child component로 전달받은 props 값은 변하지 않습니다다. 만약 부모로부터 받은 값을 수정하고 싶다면 수정된 값으로 부모 컴포넌트에게서 다시 받아야 합니다. 소스코드 예시 parent component</summary></entry><entry><title type="html">함수형 컴포넌트 vs 클래스 컴포넌트</title><link href="https://icechoco.github.io/react/2021-10-11-Class-Component-vs-Functional-Component/" rel="alternate" type="text/html" title="함수형 컴포넌트 vs 클래스 컴포넌트" /><published>2021-10-11T00:00:00+09:00</published><updated>2021-10-11T22:25:33+09:00</updated><id>https://icechoco.github.io/react/Class-Component-vs-Functional-Component</id><content type="html" xml:base="https://icechoco.github.io/react/2021-10-11-Class-Component-vs-Functional-Component/">&lt;p&gt;안녕하세요. 오늘은 React Component의 두 종류인 함수형 컴포넌트와 클래스 컴포넌트에 대해서 포스팅하겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;class-component&quot;&gt;Class Component&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets\img/class-component.PNG&quot; alt=&quot;class-component&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;state와 Lifecyle method와 같은 더 많은 기능들을 사용 할 수 있습니다. 다만 코드가 좀 더 길어지고, 복잡해지며, 성능적인 면에서 느립니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;functional-component&quot;&gt;Functional Component&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets\img/functional-component.PNG&quot; alt=&quot;functional-component&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;state와 Lifecyle method를 사용할 수 없어 제공하는 기능들이 한정됩니다. 하지만 v16.8 이후 Hook를 이용하여 보완되었습니다.&lt;/li&gt;
  &lt;li&gt;코드가 짧아지고 간단해져 선언하기가 편합니다.&lt;/li&gt;
  &lt;li&gt;메모리를 클래스 컴포넌트보다 덜 사용해서 성능이 좋고 빠릅니다.&lt;/li&gt;
  &lt;li&gt;배포시, 결과물의 파일크기가 클래스 컴포넌트보다 작습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Class component에서 사용 가능하고 functional Component에서 사용할 수 없는(v16.8 전) 기능에 대해 자세히 알아보기 위해 우선 아래 라이프 사이클 다이어그램을 보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;lifecycle&quot;&gt;Lifecycle&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets\img/React-lifecycle-methods-diagram.PNG&quot; alt=&quot;React-lifecycle-methods-diagram&quot; /&gt;&lt;/p&gt;

&lt;p&gt;class 컴포넌트를 이용하여 구현한 경우, 리액트에서 처음에 페이지를 킬 때 어떤 순서로 시작이 되는지 알려주는 다이어그램입니다. 하지만 functional 컴포넌트의 경우 위 라이프 사이클의 어느 기능도 사용할 수가 없습니다. 그러다보니 functional 컴포넌트는 빠르긴 하지만 너무 많은 기능이 안되다 보니 대부분 class형 컴포넌트를 사용했습니다. 그러다가 리액트 16.8 버전에서 Hook를 발표했습니다. 이 이후부터는 functional 컴포넌트에서도 라이프사이클과 state를 사용할 수 있게 되었습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Class component VS Hook를 활용한 Functional Component&lt;/strong&gt;
&lt;img src=&quot;/assets\img/class-component-vs-functional-component.PNG&quot; alt=&quot;class-component-vs-functional-component&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Constructor: Constructor를 이용하여 state를 부여해줍니다.&lt;/li&gt;
      &lt;li&gt;rendor: Dom에 알맞게 넣어 화면에 렌더링해줍니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;참고&quot;&gt;참고&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;React lifecycle methods diagram&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--author--&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="react" /><category term="Web" /><category term="React" /><summary type="html">안녕하세요. 오늘은 React Component의 두 종류인 함수형 컴포넌트와 클래스 컴포넌트에 대해서 포스팅하겠습니다. Class Component state와 Lifecyle method와 같은 더 많은 기능들을 사용 할 수 있습니다. 다만 코드가 좀 더 길어지고, 복잡해지며, 성능적인 면에서 느립니다.</summary></entry><entry><title type="html">Create-React-App으로 React 시작하기</title><link href="https://icechoco.github.io/react/2021-09-28-Starting-with-Create-React-App/" rel="alternate" type="text/html" title="Create-React-App으로 React 시작하기" /><published>2021-09-28T00:00:00+09:00</published><updated>2021-10-10T23:24:55+09:00</updated><id>https://icechoco.github.io/react/Starting-with-Create-React-App</id><content type="html" xml:base="https://icechoco.github.io/react/2021-09-28-Starting-with-Create-React-App/">&lt;p&gt;기존에는 리액트 앱을 처음 실행하기 위해서는 webpack이나 babel 같은 것들을 설정하기 위해서 굉장히 많은 시간이 소요되었습니다. 하지만 지금은 따로 설정하지 않아도 Create-React-App이라는 Command를 이용하여 react, webpack 등을 바로 설정할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;babel&quot;&gt;babel&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;babel&lt;/strong&gt;이란 자바스크립트 ES6, ES7 등 해마다 새로운 메소드를 추가한 버전이 있습니다. 추가한 메소드들이 최신 브라우저에서는 잘 수행되나 오래된 브라우저에서 수행이 되지 않는 경우가 있습니다. 최신 자바스크립트 문법을 사용하여도 구형 브라우저에서도 수행될 수 있게 ES6문법을 ES5로 바꿔주는 역할을 하는 것이 babel의 역할입니다.&lt;/p&gt;

&lt;h2 id=&quot;webpack&quot;&gt;webpack&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;webpack&lt;/strong&gt;이란 예전에 웹사이트를 만들 때에는 js파일, css, html과 같이 간단하게 만들었으나 점점 웹사이트의 사이즈가 커졌습니다. 그러면서 js, html 파일 뿐만 아니라 라이브러리 및 프레임워크를 많이 사용하면서 구조가 복잡해졌습니다. 복잡해진 구조들을 webpack을 이용해서 bundle(묶어주는) 시켜주는 것이 webpack의 역할입니다.&lt;/p&gt;

&lt;p&gt;webpack은 src 폴더 안의 영역만 관리를 해주며, public 폴더 안의 소스까지 관리를 해주지 않습니다. 그래서 이미지 파일과 같은 특정 파일을 webpack에 넣고 싶을 때는 src 폴더 안에 넣어 webpack이 모아주는 역할을 할 수 있도록 해주면 됩니다.&lt;/p&gt;

&lt;p&gt;터미널에 아래 스크립트를 수행하여 다운을 받을 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npx create-react-app .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;.의 의미는 내가 있는 디렉토리 안에다가 react를 설치하겠다는 의미입니다.&lt;/p&gt;

&lt;h2 id=&quot;create-react-app&quot;&gt;Create-React-app&lt;/h2&gt;
&lt;p&gt;저희는 react를 설치하고자 하는 client 경로에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npx create-react-app .&lt;/code&gt; 명령어를 통해 다운 받았습니다. 하지만 이전에는 아래와 같은 명령어를 통해 컴퓨터 안에 다운을 받았습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install -g create-react-app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그래서 컴퓨터 안에 받은 것을 활용해서 react를 실행했었습니다. 하지만 이제는 global로 다운을 받을 필요가 없이 npx를 이용해서 다운을 받지 않고 노드 레지스트리에 있는 react-creat-app을 가져와서 이용할 수 있습니다. 그럼 npm과 npx의 차이가 뭘까요?&lt;/p&gt;
&lt;h3 id=&quot;npm-node-package-manager&quot;&gt;NPM: node package manager&lt;/h3&gt;
&lt;p&gt;(1) 레지스트리와 같은 저장소 역할을 한다. 라이브러리를 담고 있는 곳이 레지스트리이다.&lt;br /&gt;
(2) npm에 관한 것은 ‘package.json’ 파일에 정의되어 있다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;ex) dependencies는 어떤걸쓰고, 버전은 몇을 쓰고 있는지, script는 어떤 것을 써야하는지 등&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(3) local vs Global&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;npm install을 사용하여 다운받으면 자동적으로 로컬에 다운을 받게 되고, node_modules 폴더에 저장된다.
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  npm install create-react-app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-g&lt;/code&gt;라는 플래그를 함께 사용하면 Global로 다운받게 되고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bin/&lt;/code&gt; 폴더에 저장된다. 리눅스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/usr/local/bin&lt;/code&gt; 폴더 안에, Windows는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%AppData%/npm&lt;/code&gt;에 저장된다
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  npm install -g create-react-app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h3 id=&quot;npx&quot;&gt;NPX&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;장점
    &lt;ol&gt;
      &lt;li&gt;Disk Space를 낭비하지 않을 수 있다.&lt;/li&gt;
      &lt;li&gt;항상 최신 버전을 사용할 수 있다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=P4gXaWZz30Q&quot;&gt;노드 리액트 기초 강의 #16 Create-React-App&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--author--&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="react" /><category term="Web" /><category term="React" /><summary type="html">기존에는 리액트 앱을 처음 실행하기 위해서는 webpack이나 babel 같은 것들을 설정하기 위해서 굉장히 많은 시간이 소요되었습니다. 하지만 지금은 따로 설정하지 않아도 Create-React-App이라는 Command를 이용하여 react, webpack 등을 바로 설정할 수 있습니다.</summary></entry><entry><title type="html">회원가입기능 만들기</title><link href="https://icechoco.github.io/react/2021-09-22-Create-member-registration-function/" rel="alternate" type="text/html" title="회원가입기능 만들기" /><published>2021-09-22T00:00:00+09:00</published><updated>2021-10-11T15:06:40+09:00</updated><id>https://icechoco.github.io/react/Create-member-registration-function</id><content type="html" xml:base="https://icechoco.github.io/react/2021-09-22-Create-member-registration-function/">&lt;p&gt;client에서 이름, e-maile, PW 등을 입력 후 서버에 보내주면 서버에서 그 데이터를 받아야 합니다. 서버에서 클라이언트로 부터 데이터를 받을 때 bodyParser라는 dependencies가 필요합니다. 이 dependencies를 이용하여 Client에서 보내주는 자료들을 이름, e-maile, PW를 받을 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;bodyparser-다운받기&quot;&gt;bodyParser 다운받기&lt;/h2&gt;
&lt;p&gt;아래 명렁어를 터미널에 입력하여 다운받습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install body-parser --save
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;지금은 로그인을 하거나, 회원가입할 때 만들어준 클라이언트가 없습니다. 그러므로 데이터를 클라이언트에 보내줄 수가 없으므로 대처하기 위해 postman을 다운받을 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;cra-살펴보기---디렉토리-구조&quot;&gt;CRA 살펴보기 - 디렉토리 구조&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;client  
├─ node_modules //NPM또는 Yarn을 통해 설치된 여러가지 라이브러리  
├─ public  
├─── src  
│ ├── _actions   //_actions, _reducer: Redux를 위한 폴더 
│ ├── _reducer  
│ ├── components  
│ │ ├─── views     //페이지를 넣을 폴더 
│ │   ├─── LandingPage //처음 홈페이지 접속 시 최초 보여지는 페이지
│ │   ├─── LoginPage   //로그인 페이지
│ │   ├─── NavBar      //사이드바랑 상단바
│ │   ├─── RegisterPage
│ ├── App.js //Routing 관련 일을 처리(로딩페이지에 가고 싶다면 로딩페이지에 가도록 분류해주고, 랜딩페이지에 가고 싶다면 랜딩페이지에 갈 수 있는 분류를 해줌)
│ └── Config.js //환경변수를 정하는 곳
├─ hoc //Higher Order Component의 약자  
├─ utils //여러군데에서 쓰일 수 있는 것들을 이곳에 넣어둬서 어디서든 쓸수 있게 해줌
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;utils&lt;/strong&gt;: Landing 페이지에서 사용하는 소스를 loginPage, RegisterPage에서 쓴다고 하면 loginPage, RegisterPage에 똑같은 소스를 복사하는게 아니라 utils에 넣어두고 Landing, loginPage, RegisterPage 세 군데에서 사용할 수 있게 해줍니다.
    &lt;h3 id=&quot;hoc&quot;&gt;hoc&lt;/h3&gt;
    &lt;p&gt;hoc는 다른 컴포넌트를 갖는 펑션입니다. 예를들어 여러가지 컴포넌트를 넣어 놓고 로직에 의해 해당 컴포넌트에 들어갈 자격이 있는지 판단을 한 후 다음 액션을 취할 수 있도록 해주는 Auth라는 HOC가 있다고 해봅시다. Auth 안에 로그인이 된 사람만 들어갈 수 있는 페이지가 있는 경우, Auth는 해당 유저가 해당 페이지에 들어갈 자격이 되는지를 알아낸 후에 자격이 된다면 Logged IN COMPONENT에 가게 해주고 아니라면 다른 페이지로 보내버립니다. 예시로 든 자격이 아니더라도 다른 기능을 hoc에 넣어놓은 후 많은 컴포넌트들이 이용할 수 있게 된다고 생각하면 됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;cra-살펴보기---srcappjs&quot;&gt;CRA 살펴보기 - src/App.js&lt;/h2&gt;
&lt;p&gt;React에서는 페이지 간의 이동을 할 떄 React Router Dom이라는 것을 사용합니다. 우선 react-router-dom을 설치합니다. 설치 완료 후 App.js 안에서 페이지 이동을 할 수 있도록 라우팅을 구현해줍니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install react-router-dom --save
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;지금까지는 Client를 구현하지 않았기 때문에 postman을 이용해서 backend가 잘 구축되어 있는지 여러 기능들을 테스트해봤습니다. 지금부터는 React.js를 사용해서 Server에 req.를 보내보도록 하겠습니다. 이때 사용할 것이 AXOIS 입니다. AXOIS는 jQuery 사용할 때 AJAX와 같은 개념입니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install axios --save
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;proxy-server가-뭐에요&quot;&gt;Proxy Server가 뭐에요?&lt;/h2&gt;
&lt;p&gt;클라이언트와 서버가 둘이서 요청을 주고 응답을 받는데 이 안에 프록시 서버가 들어갈 수 있습니다. 만약에 유저가 있고 인터넷이 있다고 생각했을 때, 유저가 무언가를 보낸 경우 프록시 서버에서 많은 일들을 할 수 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;요청받은 IP를 Proxy Server에서 임의 변경 가능
      &lt;ul&gt;
        &lt;li&gt;만약에 유저의 아이피가 ‘111.111.111.111’이라고 가정해보죠. 그럼 이때 프록시 서버에서 유저의 아이피를 임의로 변경 할 수 있습니다. 그럼 인터넷에서는 접근하는 사람의 IP를 모르게 되는거죠.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;요청받은 데이터 임의 변경 가능
      &lt;ul&gt;
        &lt;li&gt;IP 뿐만이 아니라 유저에서 보내는 데이터도 중간에서 임의로 바꿀 수 있습니다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;방화벽 기능&lt;/li&gt;
    &lt;li&gt;웹필터 기능&lt;/li&gt;
    &lt;li&gt;캐쉬 데이터, 공유 데이터 제공 기능
      &lt;ul&gt;
        &lt;li&gt;어떤 서버에 들어갔을 때 static한 이미지들을 프록시 서버에 저장 가능합니다. 유저가 무언가를 보고 싶을 떄 인터넷까지 가지않아도 프록시 서버에서 가져와 빠르게 데이터를 볼 수 있습니다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;이처럼 프록시 서버는 다양한 기능들을 수행하고 있습니다. Proxy Serve를 쓰는 이유를 정리해보자면&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;회사에서 직원들이나 집안에서 아이들 인터넷 사이트 접근 제어&lt;/li&gt;
    &lt;li&gt;캐쉬를 이용해 더 빠른 인터넷 제공&lt;/li&gt;
    &lt;li&gt;더 나은 보안 제공&lt;/li&gt;
    &lt;li&gt;이용 제한된 사이트 접근 가능&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;정도가 있습니다.&lt;/p&gt;

&lt;!--author--&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="react" /><category term="Web" /><category term="React" /><summary type="html">client에서 이름, e-maile, PW 등을 입력 후 서버에 보내주면 서버에서 그 데이터를 받아야 합니다. 서버에서 클라이언트로 부터 데이터를 받을 때 bodyParser라는 dependencies가 필요합니다. 이 dependencies를 이용하여 Client에서 보내주는 자료들을 이름, e-maile, PW를 받을 수 있습니다.</summary></entry><entry><title type="html">window 환경에서 ssh-agent 실행 시 git bash 무반응 문제</title><link href="https://icechoco.github.io/git/2021-09-21-Solve-git-bash-problem-when-running-ssh-agent-in-windows/" rel="alternate" type="text/html" title="window 환경에서 ssh-agent 실행 시 git bash 무반응 문제" /><published>2021-09-21T00:00:00+09:00</published><updated>2021-09-23T00:02:45+09:00</updated><id>https://icechoco.github.io/git/Solve-git-bash-problem-when-running-ssh-agent-in-windows</id><content type="html" xml:base="https://icechoco.github.io/git/2021-09-21-Solve-git-bash-problem-when-running-ssh-agent-in-windows/">&lt;p&gt;오늘의 삽질 하나 추가&lt;/p&gt;

&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;p&gt;SSH Agent를 Background에 실행시키기위해 아래 명령어를 입력하였다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eval &quot;$(ssh-agent -s)&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그런데 명렁어를 입력한 다음 줄에 커서가 깜빡이면서 아무런 반응이 일어나지 않았다.&lt;/p&gt;

&lt;h2 id=&quot;시도해본-것들&quot;&gt;시도해본 것들&lt;/h2&gt;
&lt;h3 id=&quot;1-창-종료-후-재시도&quot;&gt;1. 창 종료 후 재시도&lt;/h3&gt;
&lt;p&gt;Git Bash 창 강제 종료 후 새로운 Git Bash 관리자 권한으로 실행 후 다시 입력해보고 계속 반복하였으나 현상은 똑같았다.&lt;/p&gt;

&lt;h3 id=&quot;2-구글링&quot;&gt;2. 구글링&lt;/h3&gt;
&lt;p&gt;그래서 구글에 Gib Bash 멈춤, 무반응, 커서 깜빡임 등 다양하게 쳐보면서 구글링을 계속 이어갔지만 마땅한 해결책을 찾을 수 없었다. 흐아 너무 스트레스,,,,&lt;/p&gt;

&lt;p&gt;그러던 와중에 갑자기 컴퓨터가 너무 느려지다 못해 구글이 강제로 꺼지는 등 이상한 현상을 발견했다. 작업관리자를 켜봤더니 백그라운드에서 ssh-agent 여러개가 이미 실행되고 있었고 CPU가 99%와 100%를 왔다갔다했다ㄷㄷ&lt;/p&gt;

&lt;h3 id=&quot;3-ssh-add-하기&quot;&gt;3. ssh-add 하기&lt;/h3&gt;
&lt;p&gt;이상함을 감지하고 명령어는 정상 실행됐으나 Git bash가 결과를 출력하지 못하는구나 라는 생각이 들면서 다음 스텝인 ssh-add를 실행했다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh-add ~/.ssh/id_ed25519
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 명령어를 사용하던 중에 아래 오류를 만났다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Could not open a connection to your authentication agent.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;위 메시지의 발생 원인은 어떤 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssh-agent&lt;/code&gt;를 사용해야 할 지 모르기 때문이다. 머신에서 한 번도 설정하지 않은 경우에 발생할 수 있다. 그럼 SSH Agent가 Background에서 정상 실행되지 않은거네,,,,? 그럼 이건 패스&lt;/p&gt;

&lt;h2 id=&quot;해결책&quot;&gt;해결책&lt;/h2&gt;
&lt;p&gt;진짜 얻어걸린 해결책,,,&lt;/p&gt;

&lt;p&gt;백그라운드에서 ssh-agent가 1개도 수행되고 있지 않은 클린한 상태에서&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Git Bash에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eval &quot;$(ssh-agent -s)&quot;&lt;/code&gt; 입력하기&lt;/li&gt;
  &lt;li&gt;작업관리자에서 실행중인 ssh-agent 우클릭 후 작업 끝내기&lt;/li&gt;
  &lt;li&gt;Git Bash로 돌아가면 무반응상태에서 나의 ssh-agent pid가 출력된다.&lt;br /&gt;
&lt;img src=&quot;/assets\img/ssh-agent-pid.png&quot; alt=&quot;ssh-agent-pid&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;^^,,,, 이것 때문에 내 소중한 시간을 펑펑썼다니,,, 행복하다^^,,,,&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ohgyun.com/483&quot;&gt;꿀벌개발일지::ssh-add 에서 authentication agent 문제&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- author --&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="git" /><category term="Git" /><category term="ssh-agent" /><category term="git-bash" /><summary type="html">오늘의 삽질 하나 추가</summary></entry><entry><title type="html">Mongo DB란?</title><link href="https://icechoco.github.io/database/2021-09-20-What-is-Mongo-db/" rel="alternate" type="text/html" title="Mongo DB란?" /><published>2021-09-20T00:00:00+09:00</published><updated>2021-09-23T00:02:45+09:00</updated><id>https://icechoco.github.io/database/What-is-Mongo-db</id><content type="html" xml:base="https://icechoco.github.io/database/2021-09-20-What-is-Mongo-db/">&lt;p&gt;회사에서는 주로 oracle을 많이 사용하고, 다른 SQL을 사용할 기회가 오면 PostgreSQL를 잠깐 사용하고 있습니다. 그런데 RDBMS의 경우 저장할 데이터가 정형화되어있어 많은 양, 다양한 종류의 데이터를 저장하기에는 적합하지 않습니다. 그러다보니 네이버와 카카오, NHN 등 국내 140여 기업이 몽고DB 데이터베이스관리시스템(DBMS)을 사용하고 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;mongo-db의-인기&quot;&gt;Mongo DB의 인기&lt;/h2&gt;
&lt;p&gt;Mongo DB는 가장 유명한 No SQL DB입니다. 
&lt;img src=&quot;/assets\img/mongodb-survery.png&quot; alt=&quot;mongodb-survery&quot; /&gt;
스택오버플로우의 설문조사에 의하면, MongoDB는 DB 기술 중 5위로 인기가 좋습니다. 또한, 4위까지는 RDBMS인 점을 감안하면 MongoDB는 No SQL 중 가장 인기가 좋습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets\img/mongodb-survery-most.png&quot; alt=&quot;mongodb-survery-most&quot; /&gt;
가장 원하는 DB 설문조사에서는 Mongo DB가 1위를 차지하였습니다. 앞으로 Mongo DB를 배우고자 하는 사람이 많은 것을 알 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;mongoose&quot;&gt;Mongoose&lt;/h2&gt;
&lt;p&gt;Mongo DB를 편하게 사용할 수 있게 해주는 툴입니다. 설치방법은 터미널에 아래 명령어를 입력하면 됩니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install mongoose --save
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets\img/mongoose-package-json.png&quot; alt=&quot;mongoose-package-json&quot; /&gt;&lt;br /&gt;
위 명령어를 입력함으로써 package.json 파일의 dependencies 안에 mongoose 버전이 추가된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;mongodb-model이란&quot;&gt;MongoDB Model이란?&lt;/h2&gt;
&lt;p&gt;Model은 &lt;strong&gt;스키마를 감싸주는 역할&lt;/strong&gt;을 합니다. 여기서 스키마는 하나하나의 정보들을 지정해주는 역할을 합니다.&lt;br /&gt;
예를 들어 상품 판매 사이트의 경우 글의 작성자, 제목, 상세 설명이 필요할 것입니다.&lt;br /&gt;
그럼 제목과 상세설명의 타입은 String이다, 제목의 최대값은 50이다와 같이 구조를 지정해줄 수 있는데 이것이 바로 스키마입니다.&lt;br /&gt;
→ 업무에서 사용하는 데이터셋인 DVO(Data Value Object)와 비슷해보인다.&lt;/p&gt;

&lt;!--author--&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="database" /><category term="database" /><category term="React" /><summary type="html">회사에서는 주로 oracle을 많이 사용하고, 다른 SQL을 사용할 기회가 오면 PostgreSQL를 잠깐 사용하고 있습니다. 그런데 RDBMS의 경우 저장할 데이터가 정형화되어있어 많은 양, 다양한 종류의 데이터를 저장하기에는 적합하지 않습니다. 그러다보니 네이버와 카카오, NHN 등 국내 140여 기업이 몽고DB 데이터베이스관리시스템(DBMS)을 사용하고 있습니다.</summary></entry></feed>