<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="https://icechoco.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://icechoco.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2021-11-12T18:29:43+09:00</updated><id>https://icechoco.github.io/feed.xml</id><title type="html">IceChoco</title><subtitle>Hydejack is a boutique Jekyll theme for hackers, nerds, and academics, with a focus on personal sites that are meant to impress.
</subtitle><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><entry><title type="html">[JavaScript] 우리는 왜 JavaScript를 공부해야 하는가?</title><link href="https://icechoco.github.io/javascript/2021-11-12-Why-should-we-study-Javascript/" rel="alternate" type="text/html" title="[JavaScript] 우리는 왜 JavaScript를 공부해야 하는가?" /><published>2021-11-12T00:00:00+09:00</published><updated>2021-11-12T18:29:34+09:00</updated><id>https://icechoco.github.io/javascript/Why-should-we-study-Javascript</id><content type="html" xml:base="https://icechoco.github.io/javascript/2021-11-12-Why-should-we-study-Javascript/">&lt;p&gt;&lt;strong&gt;이 글의 목적&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Javascript에 대한 이론에 대해 공부하고 우리가 왜 Javascript에 대해서 공부해야 하는지 그 목적을 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;개요&quot;&gt;개요&lt;/h2&gt;
&lt;p&gt;Java script는 1995년 12월 브렌던 아이크라는 미국의 프로그래머에 의해 개발되어졌다. 브랜던 아이크는 자바스크립트를 넷스케이프를 위해 10일만에 만들었다. 2000년대에 인터넷의 대명사가 익스플로러였다면, 1990년대는 넷스케이프가 그 위치에 있었다. 넷스케이프는 그 당시 굉장히 훌륭한 네비게이터였다. 넷스케이프란 브라우저고, 사람들은 웹사이트들이 좀 더 상호보환적이길 원했다. 왜냐하면 그 당시에는 웹사이트에 HTML과 CSS밖에 없었기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets\img/netscape.png&quot; alt=&quot;SimpleJekyllSearch&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;우리가-javascript를-공부해야하는-이유&quot;&gt;우리가 JavaScript를 공부해야하는 이유&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 자바스크립트는 프론트엔드에 쓸 수 있는 유일한 프로그래밍 언어이다.&lt;/strong&gt;&lt;/p&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="javascript" /><category term="javascript" /><summary type="html">이 글의 목적 Javascript에 대한 이론에 대해 공부하고 우리가 왜 Javascript에 대해서 공부해야 하는지 그 목적을 알 수 있다.</summary></entry><entry><title type="html">[Jekyll] SimpleJekyllSearch를 사용하여 서치바(Search Bar) 구현하기</title><link href="https://icechoco.github.io/jekyll/2021-10-23-Creat-a-serach-bar/" rel="alternate" type="text/html" title="[Jekyll] SimpleJekyllSearch를 사용하여 서치바(Search Bar) 구현하기" /><published>2021-10-23T00:00:00+09:00</published><updated>2021-10-25T22:37:52+09:00</updated><id>https://icechoco.github.io/jekyll/Creat-a-serach-bar</id><content type="html" xml:base="https://icechoco.github.io/jekyll/2021-10-23-Creat-a-serach-bar/">&lt;p&gt;&lt;strong&gt;이 글의 목적&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Hydejack 테마를 사용한 블로그 환경에서 Jekyll SimpleJekyllSearch를 사용하여 서치바(Search Bar)를 구현할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;개요&quot;&gt;개요&lt;/h2&gt;
&lt;p&gt;깃헙 블로그를 시작하기 전에는 엑셀을 통해 개발공부와 관련된 내용들을 기록했었다. 그래서 엑셀을 사용할 때는 Ctrl + F하면 간단하게 찾기를 할 수 있으니 그렇게 썼었다. 그런데 데스크탑, 노트북, 본가 PC를 번갈아서 쓰면서 컴퓨터를 바꿀때마다 가장 최신버전의 엑셀을 옮겨줘야 하는 작업이 불편해졌고, 요즘 개발자들은 GitHub Pages를 통한 개인 블로그 또는 다른 사이트 운영을 통해 자신의 포트폴리오를 생성하는 것은 기본이라는 것을 알게 되었다. 그래서 나는 올 하반기부터 GitHub 블로그를 시작했고 점점 익숙해지고있다!(익숙해진거 맞지?ㅎ)&lt;/p&gt;

&lt;p&gt;무튼… 본론으로 돌아가자면 GitHub 블로그를 시작한지 이제 2달이 막 지났는데 포스트의 양이 늘어나면서 내가 적었던 글을 주변 개발자 친구들한테 공유해줄 때 글 찾기가 힘들어서 매번 “아 이거썼었는데;; 잠깐만 기다려봐!”하고 글을 계속 찾는 내 자신을 발견했다. 아니 서치바 없는 블로그라니 이게 무슨 블로그야! 서치바를 추가해야겠어라고 다짐하고 본격적인 서치바 생성에 들어갔다.&lt;/p&gt;

&lt;p&gt;회사 선배와 개발관련 얘기를 나누다 글을 계속 찾는 나를 보고 SearchBar 추가에 좋은 라이브러리인 &lt;a href=&quot;https://github.com/christian-fei/Simple-Jekyll-Search&quot;&gt;SimpleJekyllSearch&lt;/a&gt;를 추천해주셨다. 정말 너무 좋은 선배님이다^_^ 설치는 라이브러리 제공 사이트 내 &lt;a href=&quot;https://github.com/christian-fei/Simple-Jekyll-Search&quot;&gt;가이드&lt;/a&gt; 파일과 &lt;a href=&quot;https://jamesu.dev/posts/2021/01/03/adding-search-page-on-jekyll/&quot;&gt;Jekyll에 검색 페이지 추가하기&lt;/a&gt; 글을 참조하면서 진행했다.&lt;/p&gt;

&lt;h2 id=&quot;simplejekyllsearch-연동하기&quot;&gt;SimpleJekyllSearch 연동하기&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 연동에 필요한 파일은 총 2개&lt;/strong&gt;&lt;br /&gt;
SimpleJekyllSearch를 블로그에 연동하기 위해 가장 중요한 파일은 아래 2개 파일이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;simple-jekyll-search.min.js&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;simple-jekyll-search.js&lt;/code&gt; &lt;a href=&quot;https://github.com/christian-fei/Simple-Jekyll-Search/tree/master/example/js&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;search.json&lt;/code&gt; &lt;a href=&quot;https://github.com/christian-fei/Simple-Jekyll-Search/blob/master/example/search.json&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;첫번째 파일인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;simple-jekyll-search.min.js&lt;/code&gt; 파일은 검색 데이터로부터 &lt;strong&gt;검색 기능&lt;/strong&gt;을 사용하기 위한 라이브러리 파일이고, 두번째 파일인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;search.json&lt;/code&gt; 파일은 검색 데이터를 &lt;strong&gt;준비&lt;/strong&gt;하기 위한 파일이다.
그렇다면 첫번째 파일인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.min.js&lt;/code&gt; 파일과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.js&lt;/code&gt; 파일의 차이점이 뭘까? &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.min.js&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.js&lt;/code&gt; 파일의 압축버전이라고 생각하면 된다.&lt;/p&gt;

&lt;p&gt;두 파일의 생성 위치는 개발자 나름인데, 사용하는 블로그 테마에 따라서 어느정도의 폴더 역할에 따라 위치는 지켜야 하므로 자신이 생각하는 적당한 곳에 생성하면된다. 나같은 경우는 hydejack 테마를 사용하고 있으며 두 파일을 아래의 경로에 생성했다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;simple-jekyll-search.min.js&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assets/js&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;search.json&lt;/code&gt;:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assets/json&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2. 검색 데이터 준비를 위한 json 파일 만들기&lt;/strong&gt;&lt;br /&gt;
Jekyll로 만든 블로그는 별도의 서버를 갖고 있지 않은 정적 사이트이기 때문에 검색을 하기 위해서는 미리 생성된 데이터가 필요하다. 이 역할을 수행하는 파일이 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;search.json&lt;/code&gt; 파일이다.&lt;/p&gt;
&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;layout:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;site.posts&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;post.title&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;jsonify&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;categories&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{{ post.categories | join: ' &amp;gt; ' }}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;tags&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;       &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{{ post.tags | join: ', ' }}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;date&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;       &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{{ post.date | date: '%Y.%m.%d' }}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;urlString&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{{ post.url }}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;url&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{{ post.url | prepend: site.baseurl }}&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;unless&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;forloop.last&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;endunless&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;endfor&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 파일을 보면 &lt;strong&gt;Jekyll의 Liquid 문법으로 json 데이터를 생성&lt;/strong&gt;하고 있다. 뜻은 전체 포스트를 순회하면서 제목, 카테고리, 태그, url, 날짜 등을 객체로 구성하여 배열로 만든다. 파일 생성 후 데이터가 정상적으로 생성되었는지 확인하기 위해 search.json이 저장된 경로로 접속해보자. 예를 들어 나의 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://localhost:4000/assets/json/search.json&lt;/code&gt;로 접속해서 데이터 정상 생성을 확인할 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.검색 레이아웃 만들기&lt;/strong&gt;&lt;br /&gt;
나는 Nav Bar에 있는 Search버튼을 누르면 서치 홈페이지로 이동 후, 그 홈페이지 내에서 검색기능을 구현하는 페이지를 만들고 싶었다. 그래서 가장 먼저 검색 레이아웃을 만들었다. 경로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_layouts&lt;/code&gt; 폴더 아래에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;search.html&lt;/code&gt;이라는 이름으로 만들었다.&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;common-header search&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;search&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;i&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fas fa-search fa-fw&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/i&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;search-input&quot;&lt;/span&gt; 
      &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;search&quot;&lt;/span&gt; 
      &lt;span class=&quot;na&quot;&gt;tabindex=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt; 
      &lt;span class=&quot;na&quot;&gt;spellcheck=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt; 
      &lt;span class=&quot;na&quot;&gt;placeholder=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Search&quot;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;results-container&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;기본적인 소스는 &lt;a href=&quot;https://github.com/christian-fei/Simple-Jekyll-Search/blob/master/example/_layouts/default.html&quot;&gt;라이브러리 예시&lt;/a&gt;에서 볼 수 있다. 하지만 진짜 못생김ㅎ&lt;br /&gt;
&lt;img src=&quot;/assets\img/simple-jekyll-search-ex.PNG&quot; alt=&quot;simple-jekyll-search-ex&quot; /&gt;&lt;br /&gt;
예시 소스의 기본 레이아웃이다. 입력하는 부분과 그 출력값을 나타내주는 두 부분이 큰 틀인데, 예시에서는 레이아웃이 꾸밈이 없이 최소한으로 되어있다. 그래서 나는 jamesu님의 레이아웃 디자인을 가져왔다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.검색 레이아웃 만들기&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;참고&quot;&gt;참고&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jamesu.dev/posts/2021/01/03/adding-search-page-on-jekyll/&quot;&gt;Jekyll에 검색 페이지 추가하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/christian-fei/Simple-Jekyll-Search&quot;&gt;SimpleJekyllSearch&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://khw11044.github.io/blog/githubpages/2020-12-26-making-blog-05/&quot;&gt;[GithubPages] 하루만에 만드는 깃허브 블로그 05.게시물 검색기능 추가하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="jekyll" /><category term="Blog" /><category term="Jekyll" /><category term="Web" /><category term="Markdown" /><category term="HTML" /><summary type="html">이 글의 목적 Hydejack 테마를 사용한 블로그 환경에서 Jekyll SimpleJekyllSearch를 사용하여 서치바(Search Bar)를 구현할 수 있다.</summary></entry><entry><title type="html">react-redux</title><link href="https://icechoco.github.io/react/2021-10-17-About-useSelector-and-useDispatch/" rel="alternate" type="text/html" title="react-redux" /><published>2021-10-17T00:00:00+09:00</published><updated>2021-10-23T23:35:10+09:00</updated><id>https://icechoco.github.io/react/About-useSelector-and-useDispatch</id><content type="html" xml:base="https://icechoco.github.io/react/2021-10-17-About-useSelector-and-useDispatch/">&lt;p&gt;설치방법 및 redux에 관한 내용은 &lt;a href=&quot;https://icechoco.github.io/react/2021-10-11-Redux-Basics/&quot;&gt;Redux 기초 | IceChoco&lt;/a&gt;글을 참조하세요.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;state 조회하기: useSelector 사용&lt;/li&gt;
  &lt;li&gt;action 발생시키기: useDispatch 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;useselector&quot;&gt;useSelector&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;connect 함수를 이용하지 않고 리덕스의 state를 조회할 수 있다.
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import { useSelector } from &quot;react-redux&quot;;
  const user = useSelector(state =&amp;gt; state.user)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;usedispatch&quot;&gt;useDispatch&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;생성한 action을 useDispatch를 통해 발생시킬 수 있다.&lt;/li&gt;
  &lt;li&gt;만들어둔 액션생성 함수를 import 한다.
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; import { change_user } from '../modules/user' import { useDispatch } from 'react-redux' const User = () =&amp;gt; { ... const dispatch = useDispatch(); dispatch(change_user(user)); ... }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // 위에서 dispatch한 change_user는 아래와 같이 정의된 액션 생성 함수이다. export const change_user = createAction(CHANGE_USER, user =&amp;gt; user);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;참고&quot;&gt;참고&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://juhi.tistory.com/23&quot;&gt;[React] useSelector, useDispatch로 state에 접근하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--author--&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="react" /><category term="Web" /><category term="React" /><summary type="html">설치방법 및 redux에 관한 내용은 Redux 기초 | IceChoco글을 참조하세요. state 조회하기: useSelector 사용 action 발생시키기: useDispatch 사용</summary></entry><entry><title type="html">[React] Attempted import error</title><link href="https://icechoco.github.io/react/2021-10-12-Attempted-import-error/" rel="alternate" type="text/html" title="[React] Attempted import error" /><published>2021-10-12T00:00:00+09:00</published><updated>2021-10-12T14:12:48+09:00</updated><id>https://icechoco.github.io/react/Attempted-import-error</id><content type="html" xml:base="https://icechoco.github.io/react/2021-10-12-Attempted-import-error/">&lt;p&gt;client 폴더 내 index.js 파일에서 하위폴더인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_reducers&lt;/code&gt;에서 데이터를 가져올려고 하자 Attempted import error가 발생했다.
&lt;img src=&quot;/assets\img/attempt-import-error.PNG&quot; alt=&quot;attempt-import-error&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./src/index.js
Attempted import error: 'Reducer' is not exported from './_reducers'.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;프론트엔드 서버의 index.js 파일에서 ‘./_reducers’ 경로에 있는 index.js 파일을 import 하는데에 실패했다는 내용의 에러이다. 에러 발생 원인은 reducers 폴더 내 index.js 파일에서 export 시 default를 붙였기 때문이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;reducers 폴더 내 index.js파일
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import { combineReducers } from &quot;redux&quot;;

  export default rootReducer; //다른 파일에서 리듀서를 쓸 수 있도록 익스포트
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;변경 전 프론트엔드 서버의 index.js
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import { Reducer } from './_reducers';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위와 같은 import 구분을 중괄호를 제거하고 아래와 같이 변경하였더니 정상적으로 import 되었다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import Reducer from './_reducers';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그럼 어떤 경우에 import 할 때 중괄호를 써야하고, 어떤 경우에는 중괄호를 없이 써줘야할까? &lt;strong&gt;이유는 바로 export 방식의 차이이다.&lt;/strong&gt;
export 방식에 따라 {}중괄호를 사용하고, 안하고가 다른데 export 시 default를 붙인 경우 import에 중괄호 없이 써줘야한다. 반대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;export rootReducer;&lt;/code&gt;와 같이 default 없이 export한 경우 import에 중괄호를 제거한 후 써줘야한다.&lt;/p&gt;

&lt;h3 id=&quot;참고&quot;&gt;참고&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://mesonia.tistory.com/135&quot;&gt;react에서 import할때 {}중괄호 유무의 의미&lt;/a&gt;&lt;/p&gt;

&lt;!--author--&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="react" /><category term="Web" /><category term="React" /><summary type="html">client 폴더 내 index.js 파일에서 하위폴더인 _reducers에서 데이터를 가져올려고 하자 Attempted import error가 발생했다. ./src/index.js Attempted import error: 'Reducer' is not exported from './_reducers'. 프론트엔드 서버의 index.js 파일에서 ‘./_reducers’ 경로에 있는 index.js 파일을 import 하는데에 실패했다는 내용의 에러이다. 에러 발생 원인은 reducers 폴더 내 index.js 파일에서 export 시 default를 붙였기 때문이다. reducers 폴더 내 index.js파일 ``` import { combineReducers } from “redux”;</summary></entry><entry><title type="html">[React] TypeError: Cannot read properties of undefined (reading getState)</title><link href="https://icechoco.github.io/react/2021-10-12-cannot-read-properties-of-undefined-error/" rel="alternate" type="text/html" title="[React] TypeError: Cannot read properties of undefined (reading getState)" /><published>2021-10-12T00:00:00+09:00</published><updated>2021-10-12T14:43:50+09:00</updated><id>https://icechoco.github.io/react/cannot-read-properties-of-undefined-error</id><content type="html" xml:base="https://icechoco.github.io/react/2021-10-12-cannot-read-properties-of-undefined-error/">&lt;p&gt;리액트 프론트엔드 서버의 index.js 파일에서 Redux 확장 프로그램인 DevTools extension을 연결하고, 리액트 앱에 store를 연동해주기위해 provider 컴포넌트를 사용하여 설정해줬다. 그랬더니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TypeError: Cannot read properties of undefined (reading 'getState')&lt;/code&gt;에러가 발생했다.
&lt;img src=&quot;/assets\img/typeerror.PNG&quot; alt=&quot;typeerror&quot; /&gt;&lt;/p&gt;

&lt;p&gt;원인이 뭐지? 하고 구글 디버깅을 해봤더니 index.js 파일 내에 오타가 있는 경우 발생하는 에러라는 글을 찾았다. 아래는 변경 전 index.js 파일 소스이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;변경 전 프론트엔드 서버의 index.js&lt;/strong&gt;&lt;br /&gt;
&lt;img src=&quot;/assets\img/typeerror-source.PNG&quot; alt=&quot;typeerror-source&quot; /&gt;&lt;br /&gt;
위 ReactDOM.render의 provider 컴포넌트의 태그 부분을 자세히 보니 provider 시작 태그를 닫기 전에 store를 적어줘야하는데, 태그를 닫은 후 store를 적으면서 발생한 에러였다. store 위치를 procvider 시작 태그 닫기 전에 넣자 에러 없이 수행되었다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;변경 후&lt;/strong&gt;&lt;br /&gt;
&lt;img src=&quot;/assets\img/ok-typeerror-source.PNG&quot; alt=&quot;ok-typeerror-source&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;오늘도 구글신이 날 도왔다!&lt;/p&gt;

&lt;h3 id=&quot;참고&quot;&gt;참고&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://velog.io/@eve1s/react%EC%97%90%EB%9F%ACCannot-read-property-getState-of-undefined&quot;&gt;[react에러]Cannot read property ‘getState’ of undefined&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://redux.vlpt.us/1-8-provider.html&quot;&gt;1-8. Provider 컴포넌트를 사용하여 리액트 앱에 store 연동하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--author--&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="react" /><category term="Web" /><category term="React" /><summary type="html">리액트 프론트엔드 서버의 index.js 파일에서 Redux 확장 프로그램인 DevTools extension을 연결하고, 리액트 앱에 store를 연동해주기위해 provider 컴포넌트를 사용하여 설정해줬다. 그랬더니 TypeError: Cannot read properties of undefined (reading 'getState')에러가 발생했다.</summary></entry><entry><title type="html">node.js 기초</title><link href="https://icechoco.github.io/server/2021-10-11-node-js-%EA%B8%B0%EC%B4%88/" rel="alternate" type="text/html" title="node.js 기초" /><published>2021-10-11T00:00:00+09:00</published><updated>2021-10-11T20:27:09+09:00</updated><id>https://icechoco.github.io/server/node-js-%EA%B8%B0%EC%B4%88</id><content type="html" xml:base="https://icechoco.github.io/server/2021-10-11-node-js-%EA%B8%B0%EC%B4%88/">&lt;p&gt;node.js를 활용한 서버 구축에 있어 필요한 기본 지식들을 기록해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;nodejs&quot;&gt;node.js&lt;/h2&gt;
&lt;p&gt;우선, node.js가 무엇인지 알아야겠죠? 이전에 자바스크립트는 크롬이나, IE와 같은 익스플로러 상에서만 사용이 가능했습니다. 그런데 node.js가 등장하고 나서 부터 자바스크립트를 서버사이드에서도 자바스크립트 사용이 가능해졌습니다.&lt;/p&gt;

&lt;h2 id=&quot;expressjs&quot;&gt;express.js&lt;/h2&gt;
&lt;p&gt;node.js를 이용해서 웹사이트나 어플리케이션을 쉽게 만들 수 있도록 도와주는 프레임워크입니다.
터미널을 실행하여 아래 명렁어를 실행하면 설치할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install express --save
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets\img/download-express-js.png&quot; alt=&quot;download-express-js&quot; /&gt;&lt;/p&gt;

&lt;p&gt;npm install 명령어 맨 뒤에 –save 명령어를 입력함으로써 package.json 파일의 dependencies 안에 express 버전이 추가된 것을 확인할 수 있습니다. 이렇게 추가를 해둠으로써 다른 사람이 봤을 때 쓰고있구나 하고 알 수 있게 해주는 역할을 합니다.&lt;/p&gt;

&lt;h2 id=&quot;indexjs&quot;&gt;index.js&lt;/h2&gt;
&lt;p&gt;백엔드 서버를 시작하면 index.js 파일에서 시작합니다.&lt;/p&gt;

&lt;h2 id=&quot;node_modules&quot;&gt;node_modules&lt;/h2&gt;
&lt;p&gt;다운받은 dependencies들 즉 라이브러리들이 이 폴더안에 들어가 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;npm-run-scripts&quot;&gt;npm run {scripts}&lt;/h2&gt;
&lt;p&gt;npm run {scripts} 수행 시 package.json 파일 안에 있는 scripts에 적혀있는 대로 수행됩니다. 예를 들어 package.json 파일의 scripts 부분이 아래와 같이 명시되어 있는 상태에서 npm run start를 수행한 경우 루트 경로에 있는 index.js가 수행됩니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;node index.js&quot;,       //npm run start
    &quot;build&quot;: &quot;react-scripts build&quot;, //npm run build
    &quot;test&quot;: &quot;react-scripts test&quot;,   //npm run test
    &quot;eject&quot;: &quot;react-scripts eject&quot;  //npm run eject
  },
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;!--author--&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="server" /><category term="server" /><summary type="html">node.js를 활용한 서버 구축에 있어 필요한 기본 지식들을 기록해보겠습니다.</summary></entry><entry><title type="html">Redux 설치하기</title><link href="https://icechoco.github.io/react/2021-10-11-Settint-Up-Redux/" rel="alternate" type="text/html" title="Redux 설치하기" /><published>2021-10-11T00:00:00+09:00</published><updated>2021-10-11T20:18:26+09:00</updated><id>https://icechoco.github.io/react/Settint-Up-Redux</id><content type="html" xml:base="https://icechoco.github.io/react/2021-10-11-Settint-Up-Redux/">&lt;p&gt;Redux를 자신이 개발할 어플리케이션에 설치하고 설정하는 방법을 기록하겠습니다. 우선 다운 받아야 할 dependency들이 redux, react-redux, redux-promise, redux-thunk까지 총 4개가 있습니다. 이 중에서 redux-promis, redux-thunk는 redux의 미들웨어입니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install redux react-redux redux-promise redux-thunk --save
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;redux-promise-redux-thunk가-필요한-이유&quot;&gt;redux-promise, redux-thunk가 필요한 이유&lt;/h2&gt;
&lt;p&gt;redux-promise, redux-thunk는 redux를 잘 쓸 수 있게 도와주는 역할을 하는 미들웨어입니다. redux는 redux store 안에 모든 state를 관리하고 있습니다. 이 store 안에 있는 state를 변경하기 위해서는 dispatch를 이용해서 action을 통해 변경시킬 수 있습니다. 이렇게 store가 데이터를 받을 때 항상 객체 형식으로 데이터를 받는 것이 아니라 때에 따라 promise, functions 형식으로 받기도 합니다. 그런데, redux 기초편에서 봤듯 우리는 reudx store는 객체 형식으로만 데이터를 받을 수 있다고 배웠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;redux-thunk&lt;/strong&gt;는 dispatch한테 어떻게 function 형식을 받는지 그 방법을 알려주고, &lt;strong&gt;redux-promise&lt;/strong&gt;는 dispatch한테 promise가 왔을 때 어떻게 해야하는지 store에게 알려주는 역할을 합니다. 즉 이 2가지를 다운받지 않고 promise, functions 형식을 받아 redux를 사용하면 에러가 발생합니다.&lt;/p&gt;

&lt;h2 id=&quot;combinereducers가-하는-역할&quot;&gt;combineReducers가 하는 역할&lt;/h2&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets\img/combine-reducer.PNG&quot; height=&quot;300px&quot; width=&quot;500px&quot; /&gt;&lt;/p&gt;
&lt;p&gt;store에는 reducer가 여러가지 있을 수 있습니다.이 reducer는 어떻게 state가 변하는 지를 보여준 다음, 변한 마지막 값을 리턴해주는 일을 합니다.
state는 유저, 구독 등 여러가지에 대한 state가 있을 수 있으므로 각각의 state에 따라 reducer도 나눠져 있습니다. redux에 내장되어 있는 combineReducer는 여러개의 reducer들을 Root Reducer에서 하나로 합쳐주는 역할을 합니다.&lt;/p&gt;

&lt;!--author--&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="react" /><category term="Web" /><category term="React" /><category term="Redux" /><summary type="html">Redux를 자신이 개발할 어플리케이션에 설치하고 설정하는 방법을 기록하겠습니다. 우선 다운 받아야 할 dependency들이 redux, react-redux, redux-promise, redux-thunk까지 총 4개가 있습니다. 이 중에서 redux-promis, redux-thunk는 redux의 미들웨어입니다. npm install redux react-redux redux-promise redux-thunk --save redux-promise, redux-thunk가 필요한 이유 redux-promise, redux-thunk는 redux를 잘 쓸 수 있게 도와주는 역할을 하는 미들웨어입니다. redux는 redux store 안에 모든 state를 관리하고 있습니다. 이 store 안에 있는 state를 변경하기 위해서는 dispatch를 이용해서 action을 통해 변경시킬 수 있습니다. 이렇게 store가 데이터를 받을 때 항상 객체 형식으로 데이터를 받는 것이 아니라 때에 따라 promise, functions 형식으로 받기도 합니다. 그런데, redux 기초편에서 봤듯 우리는 reudx store는 객체 형식으로만 데이터를 받을 수 있다고 배웠습니다.</summary></entry><entry><title type="html">CSS Framework, Ant Design을 활용한 효율적인 화면개발하기</title><link href="https://icechoco.github.io/react/2021-10-11-Screen-development-using-ant-design/" rel="alternate" type="text/html" title="CSS Framework, Ant Design을 활용한 효율적인 화면개발하기" /><published>2021-10-11T00:00:00+09:00</published><updated>2021-10-11T16:08:09+09:00</updated><id>https://icechoco.github.io/react/Screen-development-using-ant-design</id><content type="html" xml:base="https://icechoco.github.io/react/2021-10-11-Screen-development-using-ant-design/">&lt;p&gt;원래는 모든 것을 CSS를 활용해서 하나하나 만들 수 있지만, 그렇게 되면 기능을 신경 쓰는 것 이외에 너무 많은 시간을 CSS에 투자해야합니다. 그래서 기능 개발에 초점을 맞추기 위해 CSS 프레임 워크를 사용해보도록 하겠습니다. 요즘 많은 기업들이 실무에서도 CSS 프레임워크가 잘 되어 있어 많이 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;가장 유명한 프레임워크는 Mateiral UI, React Bootstrap, Semantic UI, Ant Design, Materialize가 있습니다. 저는 그 중 Ant Design을 활용해서 개발해보도록 하겠습니다. Ant Design은 중국에서 개발되었으며 많은 기능들이 들어있기 때문에 사이즈가 큰 편입니다. 하지만 스타일이 굉장히 깔끔하고 엔터프라이즈 환경에서도 어울리는 디자인 생성이 가능합니다. 가장 큰 장점은 사용하기가 굉장히 편합니다. Material UI도 좋은 프레임워크지만 처음 사용할 때 어려움이 있습니다.&lt;/p&gt;

&lt;p&gt;가장먼저 npm을 사용하여 Ant Design을 설치합니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install antd --save
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그 다음 사용할 곳에 아래 import문을 추가하면 ant Design을 사용할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import 'antd/dist/antd.css'; // or 'antd/dist/antd.less'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;참고&quot;&gt;참고&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://ant.design/&quot;&gt;Ant Design 공식 홈페이지&lt;/a&gt;&lt;/p&gt;

&lt;!--author--&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="react" /><category term="Web" /><category term="React" /><summary type="html">원래는 모든 것을 CSS를 활용해서 하나하나 만들 수 있지만, 그렇게 되면 기능을 신경 쓰는 것 이외에 너무 많은 시간을 CSS에 투자해야합니다. 그래서 기능 개발에 초점을 맞추기 위해 CSS 프레임 워크를 사용해보도록 하겠습니다. 요즘 많은 기업들이 실무에서도 CSS 프레임워크가 잘 되어 있어 많이 사용하고 있습니다.</summary></entry><entry><title type="html">Concurrently를 이용한 백서버와 클라이언트서버 동시 실행시키기</title><link href="https://icechoco.github.io/server/2021-10-11-Running-server-and-client-at-the-same-time/" rel="alternate" type="text/html" title="Concurrently를 이용한 백서버와 클라이언트서버 동시 실행시키기" /><published>2021-10-11T00:00:00+09:00</published><updated>2021-10-11T15:34:45+09:00</updated><id>https://icechoco.github.io/server/Running-server-and-client-at-the-same-time</id><content type="html" xml:base="https://icechoco.github.io/server/2021-10-11-Running-server-and-client-at-the-same-time/">&lt;p&gt;개발하면서 매번 터미널 두개 켜서 하나는 server run 시키고, 다른 하나는 react run 시키고 두 번 해줘야 하는게 정말 불편했습니다. 그러던 와중에 알게된 것은 바로 &lt;strong&gt;Concurrently&lt;/strong&gt;를 이용해서 백서버와 클라이언트서버를 동시에 실행시키는 것! 그래서 이번 글에서는 어떻게 Concurrently를 활용해서 동시에 실행시킬 수 있는지 알려드리겠습니다. 우선 사용을 위해서는 Concurrently 라이브러리를 다운받으셔야합니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install concurrently --save
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;설치 후 사용방법은 package.json 파일 내 “scripts” 부분에 실행할 명령어를 넣고 concurrenlty를 적은 뒤 켜고 싶은 것들을 차례대로 적어주시면 됩니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;dev&quot;: &quot;concurrently   \&quot;npm run backend\&quot; \&quot;npm run start --prefix client\&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/concurrently&quot;&gt;concurrently-npm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--author--&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="server" /><category term="server" /><summary type="html">개발하면서 매번 터미널 두개 켜서 하나는 server run 시키고, 다른 하나는 react run 시키고 두 번 해줘야 하는게 정말 불편했습니다. 그러던 와중에 알게된 것은 바로 Concurrently를 이용해서 백서버와 클라이언트서버를 동시에 실행시키는 것! 그래서 이번 글에서는 어떻게 Concurrently를 활용해서 동시에 실행시킬 수 있는지 알려드리겠습니다. 우선 사용을 위해서는 Concurrently 라이브러리를 다운받으셔야합니다. npm install concurrently --save 설치 후 사용방법은 package.json 파일 내 “scripts” 부분에 실행할 명령어를 넣고 concurrenlty를 적은 뒤 켜고 싶은 것들을 차례대로 적어주시면 됩니다. &quot;dev&quot;: &quot;concurrently \&quot;npm run backend\&quot; \&quot;npm run start --prefix client\&quot;&quot;</summary></entry><entry><title type="html">Redux 기초</title><link href="https://icechoco.github.io/react/2021-10-11-Redux-Basics/" rel="alternate" type="text/html" title="Redux 기초" /><published>2021-10-11T00:00:00+09:00</published><updated>2021-10-11T19:21:59+09:00</updated><id>https://icechoco.github.io/react/Redux-Basics</id><content type="html" xml:base="https://icechoco.github.io/react/2021-10-11-Redux-Basics/">&lt;p&gt;Redux는 상태관리 라이브러리(predictable state container) 입니다. 그렇다면 여기서 말하는 state가 뭘까요? React에서는 Props와 State가 있습니다. 이 두가지를 비교하면서 state에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;props-vs-state&quot;&gt;Props VS State&lt;/h2&gt;
&lt;h3 id=&quot;props&quot;&gt;Props&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Props는 Properties의 줄임말입니다.&lt;/li&gt;
  &lt;li&gt;부모 컴포넌트와 자식 컴포넌트가 있는 경우 데이터를 서로 주고 받아야겠죠? 두 컴포넌트간의 데이터를 주고 받을 때는 Props를 이용해야 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;단방향 데이터 흐름&lt;/strong&gt;: child component에 전달되는 값 또는 method. 부모 컴포넌트에서 자식 컴포넌트로 즉 위에서 아래로만 데이터 전달이 가능합니다. 반대로 child component에서 parent component로 전달은 불가능합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;read donly&lt;/strong&gt;: child component로 전달받은 props 값은 변하지 않습니다다. 만약 부모로부터 받은 값을 수정하고 싶다면 수정된 값으로 부모 컴포넌트에게서 다시 받아야 합니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;소스코드 예시&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;parent component&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import React, {component} from 'react';
  import Hello from './Hello';

  class App extends Component{
      rendor(){
          return(
              &amp;lt;Hello name=&quot;홍길동&quot;&amp;gt; //Hello라는 자식 컴포넌트에게 name이라는 변수를 전달한다.
          );
      }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;child component&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import React, {component} from 'react';

  class Hello extends Component{
      rendor(){
          return(
              &amp;lt;div&amp;gt;
                  안녕하세요. {this.props.name}님!!
              &amp;lt;/div&amp;gt;
          );
      }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;state&quot;&gt;State&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;컴포넌트가 가지고 있는 값&lt;/strong&gt;: parent component에서 child component로 보내는게 아닌 그 component 자체 안에서 데이터를 전달할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;state는 변할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;state가 변경되면, component가 re-rendering 됩니다. (즉, update 라이프 사이클이 수행됩니다)&lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;state의 변경은 반드시 setState()함수를 이용&lt;/span&gt;해줘야 합니다. 절대 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this.state.term = '검색어'&lt;/code&gt;와 같이 직접 할당할 수 없습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;소스코드 예시&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import React, {Component} from 'react';

class App extends Component{
    constructor(props){
        super(props);

        this.state = { //초기화
            term: &quot;&quot;,
        }
    }

    rendor(){
        return(
            &amp;lt;div&amp;gt;
                &amp;lt;input
                    onchange={(e) =&amp;gt; this.setState({term: e.target.value})} //수정
                &amp;gt;
                &amp;lt;/input&amp;gt;
                &amp;lt;div&amp;gt;InputText1 {this.state.term}&amp;lt;/div&amp;gt; //읽기
            &amp;lt;/div&amp;gt;
        );
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets\img/without-redux.PNG&quot; /&gt;&lt;/p&gt;
&lt;p&gt;그래서 Redux는 이러한 state를 관리해주는 툴입니다. 만약 아래처럼 Comments 라는 컴포넌트 안에 A라는 컴포넌트가 있고, 또 그 안에 B라는 컴포넌트가 있다고 해봅시다.&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets\img/redux-exam.PNG&quot; height=&quot;200px&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;
&lt;p&gt;B 컴포넌트에서 Action이 발생했다면 commments 컴포넌트에 어떤 액션이 일어났는지 알려줘야합니다. 이때 Redux가 없다면 B컴포넌트 → A컴포넌트 → Comments 컴포넌트로 하나하나 단계적으로 타고 올라가야합니다.&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets\img/redux-store.PNG&quot; height=&quot;200px&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;
&lt;p&gt;그런데 이때 상위 컴포넌트로 이동하는게 아니라 Redux 스토어에 저장을 해놓게되면 여러 컴포넌트를 거쳐 올라가지 않아도 B컴포넌트 → Store로 직접 접근이 가능하며, 반대로 store → B컴포넌트로도 직접 접근이 가능합니다. 여러개의 컴포넌트를 왔다갔다 해야하는 과정이 빠지니 훨씬 편하게 State관리를 할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;redux-데이터-flow&quot;&gt;Redux 데이터 Flow&lt;/h2&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets\img/redux-data-flow.PNG&quot; height=&quot;200px&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Redux는 철저하게 한뱡향 데이터 플로우를 가집니다(strict unidirectional data flow). 리액트 컴포넌트에서 시작되어 Action → Reduecer → Store를 거쳐 다시 리액트 컴포넌트로 돌아옵니다.&lt;/p&gt;

&lt;h3 id=&quot;action&quot;&gt;Action&lt;/h3&gt;
&lt;p&gt;Action은 무엇이 일어났는지 설명하는 객체입니다. 형식이 객체여야만 redux store가 내용을 받을 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{type: 'LIKE_ARTICLE', articleId: 42} //articleId 42번을 좋아요 했다.
{type: 'FETCH_USER_SUCCESS', response: {id:3, name: 'Mary'}} //이름이 Mary이고 id가 3번인 유저를 가져오는 것을 성공했다.
{type: 'ADD_TODO', text: 'Read the Redux docs.'} //이 텍스트를 todo List에 add했다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;reducer&quot;&gt;REDUCER&lt;/h3&gt;
&lt;p&gt;이 액션을 함으로 인해서 A였던 값이 B로 변했다는 것을 설명해줍니다. 자세하게는 이전 State와 action object를 받은 후에 next state를 return 해주는 역할을 합니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{previousState, action} =&amp;gt; nextState
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;store&quot;&gt;STORE&lt;/h3&gt;
&lt;p&gt;Application의 state을 감싸주는 역할을 합니다. 이 Store안에는 여러가지의 많은 메소드가 있습니다. 이 메소드를 이용하여 State를 관리할 수 있습니다.&lt;/p&gt;

&lt;!--author--&gt;</content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="react" /><category term="Web" /><category term="React" /><category term="Redux" /><summary type="html">Redux는 상태관리 라이브러리(predictable state container) 입니다. 그렇다면 여기서 말하는 state가 뭘까요? React에서는 Props와 State가 있습니다. 이 두가지를 비교하면서 state에 대해 알아보겠습니다. Props VS State Props Props는 Properties의 줄임말입니다. 부모 컴포넌트와 자식 컴포넌트가 있는 경우 데이터를 서로 주고 받아야겠죠? 두 컴포넌트간의 데이터를 주고 받을 때는 Props를 이용해야 합니다. 단방향 데이터 흐름: child component에 전달되는 값 또는 method. 부모 컴포넌트에서 자식 컴포넌트로 즉 위에서 아래로만 데이터 전달이 가능합니다. 반대로 child component에서 parent component로 전달은 불가능합니다. read donly: child component로 전달받은 props 값은 변하지 않습니다다. 만약 부모로부터 받은 값을 수정하고 싶다면 수정된 값으로 부모 컴포넌트에게서 다시 받아야 합니다. 소스코드 예시 parent component</summary></entry></feed>