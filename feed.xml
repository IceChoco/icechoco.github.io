<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2022-04-25T13:48:12+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">IceChoco</title><subtitle>Hydejack is a boutique Jekyll theme for hackers, nerds, and academics, with a focus on personal sites that are meant to impress.
</subtitle><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><entry><title type="html">[Java] 일급 컬렉션 (First Class Collection)이란?</title><link href="http://localhost:4000/java/2022-04-22-First-Class-Collection/" rel="alternate" type="text/html" title="[Java] 일급 컬렉션 (First Class Collection)이란?" /><published>2022-04-22T00:00:00+09:00</published><updated>2022-04-22T22:37:07+09:00</updated><id>http://localhost:4000/java/First-Class-Collection</id><content type="html" xml:base="http://localhost:4000/java/2022-04-22-First-Class-Collection/"><![CDATA[<p>우아한 테크캠프 Pro 프리코스 2주차 과제에서는 1주차 과제에서 추가로 <strong>일급 콜렉션</strong>을 사용하라는 프로그래밍 요구사항이 추가되었다.
일급 컬렉션이란 무엇인지, 어떤 장점들이 있기에 객체지향적이고 리팩토링하기 쉬운 코드를 짜기위해 필요한지 알아보려한다.</p>

<ul>
  <li><span style="color:grey"><em>향로님이 올려주신 <a href="https://jojoldu.tistory.com/412">일급 컬렉션 (First Class Collection)의 소개와 써야할 이유</a>를 보고 정리한 글입니다.</em> </span></li>
</ul>

<p>우선 일급 컬렉션이라는 단어는 소트웍스 앤솔로지의 객체지향 생활체조 파트에서 언급이 되었다.</p>
<blockquote>
  <p>규칙 8: 일급 콜렉션 사용
이 규칙의 적용은 간단하다.
콜렉션을 포함한 클래스는 반드시 다른 멤버 변수가 없어야 한다.
각 콜렉션은 그 자체로 포장돼 있으므로 이제 콜렉션과 관련된 동작은 근거지가 마련된셈이다.
필터가 이 새 클래스의 일부가 됨을 알 수 있다.
필터는 또한 스스로 함수 객체가 될 수 있다.
또한 새 클래스는 두 그룹을 같이 묶는다든가 그룹의 각 원소에 규칙을 적용하는 등의 동작을 처리할 수 있다.
이는 인스턴스 변수에 대한 규칙의 확실한 확장이지만 그 자체를 위해서도 중요하다.
콜렉션은 실로 매우 유용한 원시 타입이다.
많은 동작이 있지만 후임 프로그래머나 유지보수 담당자에 의미적 의도나 단초는 거의 없다. - 소트웍스 앤솔로지 객체지향 생활체조편</p>

</blockquote>

<p>설명을 보기 전까지는 무슨 의미인지 알겠다. 그런데 소스코드를 봐야 좀 더 확실하게 알 수 있을듯하다. 아래의 코드를 보자.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put("1", "A");
map.put("2", "B");
map.put("3", "C");
</code></pre></div></div>
<p>위와 같은 코드를 아래와 같이 <strong>Wrapping</strong>할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GameRanking</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">ranks</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">GameRanking</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">ranks</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">ranks</span> <span class="o">=</span> <span class="n">ranks</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>Collection을 Wrapping</strong>하면서, <strong>그 외 다른 멤버 변수가 없는 상태</strong>를 일급 컬렉션이라 한다.
Wrapping하면서 얻게되는 이점들은 크게 4가지가 있다.</p>

<ol>
  <li><strong>비즈니스</strong>에 종속적인 <strong>자료구조</strong></li>
  <li>Collection의 <strong>불변성</strong>을 보장</li>
  <li>상태와 행위를 한 곳에서 관리</li>
  <li>이름이 있는 컬렉션</li>
</ol>

<h2 id="1-비즈니스에-종속적인-자료구조">1. 비즈니스에 종속적인 자료구조</h2>
<p>예를 들어 다음과 같은 조건으로 <strong>로또 복권 게임</strong>을 만든다고 가정해보자.
로또복권은 다음과 같은 조건이 있다.</p>
<ul>
  <li>6개의 번호가 존재</li>
  <li>보너스 번호는 이번 예제에서 제외</li>
  <li>6개의 번호를 서로 중복되지 않아야 함</li>
</ul>

<p>일반적으로 이런 일은 <strong>서비스 메소드</strong>에서 진행한다.
그래서 구현을 해보면 아래처럼 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">LOTTO_NUMBERS_SIZE</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createLottoNumber</span><span class="o">(){</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">lottotNumbers</span> <span class="o">=</span> <span class="n">createNonDuplicateNumbers</span><span class="o">();</span>
        <span class="n">validateSize</span><span class="o">(</span><span class="n">lottotNumbers</span><span class="o">);</span>
        <span class="n">validateDuplicate</span><span class="o">(</span><span class="n">lottotNumbers</span><span class="o">);</span>
        
        <span class="c1">//이후 로직 쭉쭉 실행</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="nf">createNonDuplicateNumbers</span><span class="o">()</span> <span class="o">{</span>
     <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="k">new</span> <span class="nc">Long</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateDuplicate</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">lottotNumbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">lottotNumbers</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">!=</span> <span class="no">LOTTO_NUMBERS_SIZE</span><span class="o">){</span>
           <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"로또 번호는 6개만 가능합니다."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateSize</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">lottotNumbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">nonDuplicateNumbers</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;(</span><span class="n">lottotNumbers</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nonDuplicateNumbers</span><span class="o">.</span><span class="na">size</span><span class="o">()!=</span><span class="no">LOTTO_NUMBERS_SIZE</span><span class="o">){</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"로또 번호는 중복될 수 없습니다."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>서비스 메소드에서 비즈니스 로직을 처리했다. 이럴경우 큰 문제가 있다.
<strong>로또 번호가 필요한 모든 장소에선 검증로직</strong>이 들어가야만 한다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">List&lt;Long&gt;</code>으로 된 데이터는 모두 검증로직이 필요할까 ?</li>
  <li>신규 입사자들의 경우 이 검증 로직이 필요한지 알 수 있을까?</li>
</ul>

<p>등등 <strong>모든 코드와 도메인 로직</strong>을 알고 있지 않다면 언제든 문제가 발생할 소지가 있다.
그렇다면 이 문제를 해결하기 위해서는</p>

<ul>
  <li>6개의 숫자로만 이루어져야하고</li>
  <li>6개의 숫자는 서로 중복되지 않아야만 하는</li>
</ul>

<p>이런 자료구조가 없을까? 없으니 만들면된다!
아래와 같이 <strong>해당 조건으로만 생성 할 수 있는 자료구조</strong>를 만들면 위에서 언급한 문제들이 모두 해결된다.
그리고 이런 클래스를 <strong>일급 컬렉션</strong>이라고 부른다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoTicket</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">LOTTO_NUMBERS_SIZE</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
    
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">lottoNumbers</span><span class="o">;</span>
    
    <span class="c1">//6개 / 중복되지 않은 숫자들만 가능한 자료구조</span>
    <span class="kd">public</span> <span class="nf">LottoTicket</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">lottoNumbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">validateSize</span><span class="o">(</span><span class="n">lottoNumbers</span><span class="o">);</span>
        <span class="n">validateDuplicate</span><span class="o">(</span><span class="n">lottoNumbers</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lottoNumbers</span> <span class="o">=</span> <span class="n">lottoNumbers</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateDuplicate</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">lottotNumbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">lottotNumbers</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">!=</span> <span class="no">LOTTO_NUMBERS_SIZE</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"로또 번호는 6개만 가능합니다."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateSize</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">lottotNumbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">nonDuplicateNumbers</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;(</span><span class="n">lottotNumbers</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nonDuplicateNumbers</span><span class="o">.</span><span class="na">size</span><span class="o">()!=</span><span class="no">LOTTO_NUMBERS_SIZE</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"로또 번호는 중복될 수 없습니다."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이제 로또 번호가 필요한 모든 로즉인 이 일급 컬렉션만 있으면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoService2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createLottoNumber</span><span class="o">(){</span>
        <span class="nc">LottoTicket</span> <span class="n">lottoTicket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LottoTicket</span><span class="o">(</span><span class="n">createNonDuplicateNumbers</span><span class="o">());</span>
    
    <span class="c1">//이후 로직 쭉쭉 실행</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="nf">createNonDuplicateNumbers</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="k">new</span> <span class="nc">Long</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span><span class="c1">//로직 구현하기</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>비즈니스에 종속적인 자료구조</strong>가 만들어져, 이후 발생할 문제가 최소화 되었다.</p>

<h2 id="2-불변">2. 불변</h2>
<p>일급 컬렉션은 <strong>컬렉션의 불변을 보장</strong>한다.
불변을 보장하기 위해 final을 사용하면 되는거 아니냐 생각 할 수 있지만 아니다.
자바의 final은 정확히는 불변을 만들어주는게 아니라, <strong>재할당만 금지</strong>한다.</p>

<p>아래의 테스트 코드를 참고해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">finalTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">final도_값변경이_가능하다</span><span class="o">(){</span>
        <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Boolean</span><span class="o">&gt;</span> <span class="n">collection</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        
        <span class="n">collection</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">collection</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"2"</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">collection</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"3"</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">collection</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"4"</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
        
        <span class="n">assertThat</span><span class="o">(</span><span class="n">collection</span><span class="o">.</span><span class="na">size</span><span class="o">()).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이를 실행해보면 collection에 <strong>값이 추가</strong>되는걸 확인할 수 있다.
이미 collection은 <strong>비어 있는 HashMap</strong>으로 선언되었음에도 값이 변경될 수 있다는 것이다.
추가로 테스트해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">finalTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">final은_재할당이_불가능하다</span><span class="o">(){</span>
        <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Boolean</span><span class="o">&gt;</span> <span class="n">collection</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        
        <span class="n">collection</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        
        <span class="n">assertThat</span><span class="o">(</span><span class="n">collection</span><span class="o">.</span><span class="na">size</span><span class="o">()).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 코드는 <code class="language-plaintext highlighter-rouge">collection = new HashMap&lt;&gt;();</code>에서 바로 컴파일 에러가 발생한다. <strong>final로 할당된 코드에 재할당 될 수 없기 때문이다.</strong></p>

<p>위와 같이 Java의 final은 <strong>재할당만 금지</strong>한다.
이외에도 <code class="language-plaintext highlighter-rouge">member.setAge(10)</code>와 같은 코드 역시 작동해버리니 반쪽자리라 할 수 있다.</p>

<p>요즘과 같이 SW 규모가 커지고 있는 상황에서 <strong>불변 객체</strong>는 아주 중요하다.
각각의 객체들이 <strong>절대 값이 바뀔 일이 없다</strong>는게 보장되면 그만큼 코드를 이해하고 수정하는 <strong>사이드 이펙트가 최소화</strong>되기 때문이다.</p>

<p>Java에서는 final로 그 문제를 해결할 수 없기 때문에 <strong>일급 컬렉션</strong>(First Class Collection)과 <strong>래퍼 클래스</strong>(Wrapper class) 등의 방법으로 해결해야만 한다.</p>

<p>그래서 아래와 같이 <strong>컬렉션의 값을 변경할 수 있는 메소드가 없는 컬렉션</strong>을 만들면 <strong>불변 컬렉션</strong>이 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Orders</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">orders</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">Orders</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">orders</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">orders</span> <span class="o">=</span> <span class="n">orders</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getAmountSum</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">orders</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
        <span class="o">.</span><span class="na">mapToLong</span><span class="o">(</span><span class="nl">Order:</span><span class="o">:</span><span class="n">getAmount</span><span class="o">)</span>
        <span class="o">.</span><span class="na">sum</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 클래스는 <strong>생성자와 getAmountSum()</strong>외에 다른 메소드가 없다.
즉, 이 클래스의 사용법은 <strong>새로 만들거나 값을 가져오는 것</strong>뿐이다.
List라는 컬렉션에 접근할 수 있는 방법이 없기 때문에 <strong>값을 변경/추가가 안된다.</strong></p>

<p>이렇게 일급 컬렉션을 사용하면, 불변 컬렉션을 만들 수 있다.</p>

<h2 id="3-상태와-행위를-한곳에서-관리">3. 상태와 행위를 한곳에서 관리</h2>
<p>일급 컬렉션의 세번쨰 장점은 <strong>값과 로직이 함께 존재</strong>한다는 것이다.</p>
<blockquote>
  <p>이 부분은 Enum의 장점과도 일맥상통한다.</p>
</blockquote>

<p>예를들어 여러 Pay들이 모여있고, 이 중 <strong>NaverPay 금액의 합</strong>이 필요하다고 가정해보겠다.
일반적으로는 아래와 같이 작성한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PayTest</span> <span class="o">{</span>
  <span class="nd">@Test</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="n">로직이_밖에_있는_상태</span><span class="o">(){</span>
    <span class="c1">//값은 여기 있는데</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">pays</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
            <span class="k">new</span> <span class="nf">Pay</span><span class="o">(</span><span class="no">NAVER_PAY</span><span class="o">,</span> <span class="mi">1000</span><span class="o">),</span>
            <span class="k">new</span> <span class="nf">Pay</span><span class="o">(</span><span class="no">NAVER_PAY</span><span class="o">,</span> <span class="mi">1500</span><span class="o">),</span>
            <span class="k">new</span> <span class="nf">Pay</span><span class="o">(</span><span class="no">KAKAO_PAY</span><span class="o">,</span> <span class="mi">2000</span><span class="o">),</span>
            <span class="k">new</span> <span class="nf">Pay</span><span class="o">(</span><span class="no">TOSS</span><span class="o">,</span> <span class="mi">3000L</span><span class="o">)</span>
    <span class="o">);</span>

    <span class="c1">//계산은 여기서</span>
    <span class="nc">Long</span> <span class="n">naverPaySum</span> <span class="o">=</span> <span class="n">pays</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">pay</span> <span class="o">-&gt;</span> <span class="n">pay</span><span class="o">.</span><span class="na">getPayType</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="no">NAVER_PAY</span><span class="o">))</span>
            <span class="o">.</span><span class="na">mapToLong</span><span class="o">(</span><span class="nl">Pay:</span><span class="o">:</span><span class="n">getAmount</span><span class="o">)</span>
            <span class="o">.</span><span class="na">sum</span><span class="o">();</span>

    <span class="n">assertThat</span><span class="o">(</span><span class="n">naverPaySum</span><span class="o">).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="mi">2500</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>List에 데이터를 담고</li>
  <li>Service 혹은 Util 클래스에서 필요한 로직 수행</li>
</ul>

<p>이 상황에서는 문제가 있다.<br />
결국 <code class="language-plaintext highlighter-rouge">pays</code>라는 컬렉션과 계산 로직은 <strong>서로 관계</strong>가 있는데, 이를 <strong>코드로 표현이 안된다.</strong></p>

<p>Pay 타입의 <strong>상태에 따라</strong> 지정된 메소드에서만 계산되길 월하는데, 현재 상태로는 강제할 수 있는 수단이 없다.<br />
지금은 <strong>Pay 타입의 List라면</strong> 사용될 수 있기 때문에 히스토리를 모른다면 실수할 여지가 많다.</p>
<ul>
  <li>똑같은 기능을 하는 <strong>메소드를 중복 생성</strong>할 수 있다.
    <ul>
      <li>히스토리가 관리 안된 상태에서 신규 화면이 추가되어야 할 경우 계산 메소드가 있다는 것을 몰라 다시 만드는 경우가 빈번하다.</li>
      <li>만약 기존 화면의 계싼 로직이 변경될 경우, 신규 인력은 2개의 메소드 로직을 다 변경해야하는지, 해당 화면만 변경해야 하는지 알 수 없다.</li>
      <li>관리 포인트가 증가할 확률이 매우 높다.</li>
    </ul>
  </li>
  <li>계산 메소드를 누락할 수 있다.
    <ul>
      <li>리턴 받고자 하는 것이 Long 타입이기 때문에 <strong>꼭 이 계산식을 써야한다고 강제할 수 없다.</strong></li>
    </ul>
  </li>
</ul>

<p>결국에 <strong>네이버페이 총 금액을 뽑을려면 이렇게 해야한다는 계산식을 컬렉션과 함께 두어야</strong> 한다.<br />
만약 네이버페이 외에 카카오 페이의 총금액도 필요하다면 더더욱 <strong>코드가 흩어질 확률이 높다.</strong></p>

<p>그래서 이 문제를 일급 컬렉션으로 해결할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PayGroup</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">pays</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">PayGroup</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">pays</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">pays</span> <span class="o">=</span> <span class="n">pays</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">getNaverPaySum</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">pays</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">pay</span> <span class="o">-&gt;</span> <span class="nc">PayType</span><span class="o">.</span><span class="na">isNaverPay</span><span class="o">(</span><span class="n">pay</span><span class="o">.</span><span class="na">getPayType</span><span class="o">()))</span>
                <span class="o">.</span><span class="na">mapToLong</span><span class="o">(</span><span class="nl">Pay:</span><span class="o">:</span><span class="n">getAmount</span><span class="o">)</span>
                <span class="o">.</span><span class="na">sum</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>만약 <strong>다른 결제 수단들의 합이 필요</strong>하다면 아래와 같이 <strong>람다식으로 리팩토링</strong> 가능하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PayGroups</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">pays</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">PayGroups</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">pays</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">pays</span> <span class="o">=</span> <span class="n">pays</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">getNaverPaySum</span><span class="o">(){</span>
        <span class="k">return</span> <span class="nf">getFilteredPays</span><span class="o">(</span><span class="n">pay</span> <span class="o">-&gt;</span> <span class="nc">PayType</span><span class="o">.</span><span class="na">isNaverPay</span><span class="o">(</span><span class="n">pay</span><span class="o">.</span><span class="na">getPayType</span><span class="o">()));</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">getKakaoPaySum</span><span class="o">(){</span>
        <span class="k">return</span> <span class="nf">getFilteredPays</span><span class="o">(</span><span class="n">pay</span> <span class="o">-&gt;</span> <span class="nc">PayType</span><span class="o">.</span><span class="na">isKakaoPay</span><span class="o">(</span><span class="n">pay</span><span class="o">.</span><span class="na">getPayType</span><span class="o">()));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Long</span> <span class="nf">getFilteredPays</span><span class="o">(</span><span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">){</span>
        <span class="k">return</span> <span class="n">pays</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">pay</span> <span class="o">-&gt;</span> <span class="nc">PayType</span><span class="o">.</span><span class="na">isNaverPay</span><span class="o">(</span><span class="n">pay</span><span class="o">.</span><span class="na">getPayType</span><span class="o">()))</span>
                <span class="o">.</span><span class="na">mapToLong</span><span class="o">(</span><span class="nl">Pay:</span><span class="o">:</span><span class="n">getAmount</span><span class="o">)</span>
                <span class="o">.</span><span class="na">sum</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 PayGroup라는 일급 컬렉션이 생김으로 <strong>상태와 로직이 한곳에서 관리</strong>된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PayTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">로직이_밖에_있는_상태</span><span class="o">(){</span>
        <span class="c1">//값은 여기 있는데</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">pays</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
                <span class="k">new</span> <span class="nf">Pay</span><span class="o">(</span><span class="no">NAVER_PAY</span><span class="o">,</span> <span class="mi">1000</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Pay</span><span class="o">(</span><span class="no">NAVER_PAY</span><span class="o">,</span> <span class="mi">1500</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Pay</span><span class="o">(</span><span class="no">KAKAO_PAY</span><span class="o">,</span> <span class="mi">2000</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Pay</span><span class="o">(</span><span class="no">TOSS</span><span class="o">,</span> <span class="mi">3000L</span><span class="o">)</span>
        <span class="o">);</span>

        <span class="c1">//상태와 로직이 한곳에!</span>
        <span class="nc">PayGroups</span> <span class="n">payGroups</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PayGroups</span><span class="o">(</span><span class="n">pays</span><span class="o">);</span>
        <span class="nc">Long</span> <span class="n">naverPaySum</span> <span class="o">=</span> <span class="n">payGroups</span><span class="o">.</span><span class="na">getNaverPaySum</span><span class="o">();</span>

        <span class="n">assertThat</span><span class="o">(</span><span class="n">naverPaySum</span><span class="o">).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="mi">2500</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="4-이름이-있는-컬렉션">4. 이름이 있는 컬렉션</h2>
<p>마지막 장점은 <strong>컬렉션에 이름을 붙일 수 있다</strong>는 것이다.<br />
<strong>같은 Pay들의 모임이지만 네이버페이의 List와 카카오페이의 List는 다르다.</strong><br />
그렇다면 이 둘을 구분하려면 어떻게 해야할까?<br />
가장 흔한 방법은 변수명을 다르게 하는 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="n">컬렉션을_변수명으로</span><span class="o">(){</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">naverPays</span> <span class="o">=</span> <span class="n">createNaverPays</span><span class="o">();</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">kakakoPays</span> <span class="o">=</span> <span class="n">createKakaoPays</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위와 같이 변수명으로 선언했을 떄의 단점은 뭘까?</p>
<ul>
  <li>검색이 어렵다
    <ul>
      <li>네이버 페이 그룹이 어떻게 사용되는지 검색 시 <strong>변수명으로만 검색할 수 있다.</strong></li>
      <li>이 상황에서 검색은 거의 불가능하다.</li>
      <li><strong>네이버 페이 그룹</strong>이라는 뜻은 <strong>개발자마다 다르게 지을 수 있기 때문</strong>이다.</li>
      <li>네이버 페이 그룹은 어떤 검색어로 검색이 가능할까….?</li>
    </ul>
  </li>
  <li>명확한 표현이 불가능하다.
    <ul>
      <li>변수명에 불과하기 때문에 <strong>의미를 부여하기 어렵다.</strong></li>
      <li>이는 개발팀/운영팀간에 의사소통 시 보편적인 언어로 사용하기가 어려움을 이야기한다.</li>
      <li>중요한 값임에도 <strong>이를 표현할 명확한 단어가 없는 것</strong>이다.</li>
    </ul>
  </li>
</ul>

<p>위 문제 역시 일급 컬렉션으로 쉽게 해결할 수 있다.<br />
네이버 페이 그룹과 카카오 페이 그룹 각각의 일급 컬렉션을 만들면 <strong>이 컬렉션 기반으로 용어사용과 검색</strong>을 하면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">컬렉션을_변수명으로</span><span class="o">(){</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">naverPays</span> <span class="o">=</span> <span class="n">createNaverPays</span><span class="o">();</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Pay</span><span class="o">&gt;</span> <span class="n">kakakoPays</span> <span class="o">=</span> <span class="n">createKakaoPays</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>개발팀/운영팀 내에서 사용될 표현은 이제 이 컬렉션에 맞추면 된다.<br />
검색 역시 이 컬렉션 클래스를 검색하면 모든 사용 코드를 찾아낼 수 있다.</p>

<h2 id="마무리">마무리</h2>
<p>처음에 소트웍스 앤솔로지의 객체지향 생활체조 파트에서 언급된 일급 컬렉션에 대한 설명은 잘 이해가 안갔다.<br />
코드를 직접 보지 않으면 이해가 잘 안가는 스타일이라 그런가보다.<br />
그런데 다행이도 이렇게 너무 자세하게 남겨주신 향로님께 감사의 말씀을 드리고 싶다.<br />
올려주신 글을 보며 같이 타이핑해가면서, 소스 코드를 구현하면서 보니 이해가 더 잘된다.<br />
이제는 왜 일급 컬렉션을 왜 써야하는지 공감이 간다! :D</p>

<h3 id="참고">참고</h3>
<ul>
  <li><a href="https://developerfarm.wordpress.com/2012/02/01/object_calisthenics_/">소트웍스 앤솔러지 - 규칙 8: 일급 콜렉션 사용</a></li>
  <li><a href="https://jojoldu.tistory.com/412">일급 컬렉션 (First Class Collection)의 소개와 써야할 이유</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="java" /><category term="java" /><summary type="html"><![CDATA[우아한 테크캠프 Pro 프리코스 2주차 과제에서는 1주차 과제에서 추가로 일급 콜렉션을 사용하라는 프로그래밍 요구사항이 추가되었다. 일급 컬렉션이란 무엇인지, 어떤 장점들이 있기에 객체지향적이고 리팩토링하기 쉬운 코드를 짜기위해 필요한지 알아보려한다.]]></summary></entry><entry><title type="html">[Java] 원시값과 문자열의 포장</title><link href="http://localhost:4000/java/2022-04-22-wrap-primitive-type/" rel="alternate" type="text/html" title="[Java] 원시값과 문자열의 포장" /><published>2022-04-22T00:00:00+09:00</published><updated>2022-04-22T23:39:54+09:00</updated><id>http://localhost:4000/java/wrap-primitive-type</id><content type="html" xml:base="http://localhost:4000/java/2022-04-22-wrap-primitive-type/"><![CDATA[<p>우아한 테크캠프 Pro 프리코스 2주차 과제에서는 1주차 과제에서 추가로 <strong>모든 원시값과 문자열을 포장하라</strong>라는 프로그래밍 요구사항이 추가되었다.</p>
<ul>
  <li><span style="color:grey"><em>2기_오렌지님이 올려주신 <a href="https://tecoble.techcourse.co.kr/post/2020-05-29-wrap-primitive-type/">원시 타입을 포장해야 하는 이유</a>를 보고 정리한 글입니다.</em> </span></li>
</ul>

<p>우선 소트웍스 앤솔로지의 객체지향 생활체조 파트에서 언급된 내용은 아래와 같다.</p>
<blockquote>
  <p>규칙 3: 원시값과 문자열의 포장
int 값 하나 자체는 그냥 아무 의미 없는 스칼라 값일 뿐이다.<br />
어떤 메서드가 int 값을 매개변수로 받는다면 그 메서드 이름은 해당 매개변수의 의도를 나타내기 위해 모든 수단과 방법을 가리지 않아야 한다.
만약 똑같은 메서드가 시간을 매개변수로 받을 경우, 무슨 일이 생기는지는 훨씬 자명하다.<br />
이런 작은 객체가 프로그램의 유지보수성을 높일 수 있는 것은 시간 값을 매개변수로 받는 메서드에게 연도 값을 넘길 수는 없기 때문이다.<br />
원시형 변수로는 컴파일러가 의미적으로 맞는 프로그램 작성을 안내할 수 없다.<br />
객체로라면 아주 사소하더라도 컴파일러와 프로그래머에게 그 값이 어떤 값이며, 왜 쓰고 있는지에 대한 정보를 전하는 셈이다.</p>

  <p>또한 시간이나 돈과 같은 작은 객체는 행위를 놓을 분명한 곳을 마련해 줘서, 그렇지 않았다면 다른 클래스의 주위를 겉돌았을지도 모르는 사태를 방지한다.
이는 특히 게터와 세터에 관련된 규칙을 적용하고 그런 작은 객체만이 값에 접근할 수 있을 때 그렇다.</p>
</blockquote>

<p>변수를 선언하는 방법에는 두 가지가 있다.</p>
<ul>
  <li>원시타입의 변수를 선언하는 방법</li>
  <li>원시 타입의 변수를 객체로 포장한 변수를 선언하는 방법
(Collection으로 선언한 변수도 포장한다. 이를 일급 컬렉션이라 하며 본 블로그의 <code class="language-plaintext highlighter-rouge">[Java] 일급 컬렉션 (First Class Collection)이란?</code>글을 참고하길 바란다.)
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>
<span class="nc">Age</span> <span class="n">age</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Age</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>이번 글에서는 객체지향 생활 체조에서도 언급된 <strong>원시 타입의 값을 객체로 포장하면 얻을 수 있는 이점</strong>들에 대해 보겠다.</p>

<h2 id="자신의-상태-객체를-스스로-관리할-수-있다">자신의 상태 객체를 스스로 관리할 수 있다.</h2>
<p>User라는 클래스에서, 사용자의 나이를 가지고 있다고 가정해보자.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위의 형태처럼 원시타입인 int로 나이를 가지고 있으면 어떻게 될까? 쉽게 생각해보면 우선, 아래의 소스코드 처럼 나이에 관한 유효성 검사를 User 클래스에서 하게 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="nc">String</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">age</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"나이는 0살부터 시작합니다."</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 예시는 User 클래스의 멤버변수가 나이밖에 없어 문제를 크게 못느낄 수도 있다. 사용자의 이름, 이메일 등 추가적인 값들을 관리하게 된다면 문제가 생길 수 밖에 없다.<br />
두 글자 이상의 이름만을 지원한다고 가정하고, 이름 변수를 추가해보자 !</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="nc">String</span> <span class="n">nameValue</span><span class="o">,</span> <span class="nc">String</span> <span class="n">ageValue</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">ageValue</span><span class="o">);</span>
        <span class="n">validateAge</span><span class="o">(</span><span class="n">age</span><span class="o">);</span>
        <span class="n">validateName</span><span class="o">(</span><span class="n">nameValue</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">nameValue</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">()&lt;</span><span class="mi">2</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"이름은 두 글자 이상이어야 합니다."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">age</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"나이는 0살부터 시작합니다."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>두개의 멤버변수를 선언했을 뿐인데 User 클래스가 할 일이 늘어나 버렸다. <strong>이름</strong> 값에 대한 상태 관리, <strong>나이</strong> 값에 대한 상태 관리를 모두 해야한다.<br />
User 클래스는 분명히</p>
<blockquote>
  <p>아, 나는 사용자 그 자체 상태만 관리하고 싶은데 왜 자잘 자잘 한 것 까지 내가 관리해야돼? 이건 불합리해!</p>
</blockquote>

<p>라고 생가하지 않을까?<br />
그럼, 원시타입 변수를 포장해보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
   <span class="kd">private</span> <span class="nc">Name</span> <span class="n">name</span><span class="o">;</span>
   <span class="kd">private</span> <span class="nc">Age</span> <span class="n">age</span><span class="o">;</span>

   <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="nc">String</span> <span class="n">nameValue</span><span class="o">,</span> <span class="nc">String</span> <span class="n">ageValue</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Name</span><span class="o">(</span><span class="n">nameValue</span><span class="o">);</span>
      <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Age</span><span class="o">(</span><span class="n">ageValue</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Name</span> <span class="o">{</span>
   <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

   <span class="kd">public</span> <span class="nf">Name</span><span class="o">(</span><span class="nc">String</span> <span class="n">nameValue</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">()&lt;</span><span class="mi">2</span><span class="o">){</span>
         <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"이름은 두 글자 이상이어야 합니다."</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Age</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Age</span><span class="o">(</span><span class="nc">String</span> <span class="n">ageValue</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">ageValue</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">age</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"나이는 0살부터 시작합니다."</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>User 클래스가 해방됐다.</p>
<blockquote>
  <p>와! 나 이제 예외 처리 안 해도 돼!</p>
</blockquote>

<p>이름과 나이 값이 각각의 Name, Age가 담당하도록 바뀌었다.<br />
유효성 검증을 비롯한 이름, 나이 값에 대한 상태값을 User에 넘기지 않고 스스로 관리할 수 있게 되었다. 책임이 명확해졌다.</p>

<h2 id="코드의-유지보수에-도움이-된다">코드의 유지보수에 도움이 된다.</h2>
<p>이번엔 다른 예시이다. 다음은 로또 미션의 LottoNumber, Lotto, WinningLotto 클래스의 일부이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoNumber</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="no">MIN_LOTTO_NUMBER</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="no">MAX_LOTTO_NUMBER</span> <span class="o">=</span> <span class="mi">45</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="nc">String</span> <span class="no">OUT_OF_RANGE</span> <span class="o">=</span> <span class="s">"로또번호는 1~45의 범위입니다."</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">LottoNumber</span><span class="o">&gt;</span> <span class="no">NUMBERS</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">lottoNumber</span><span class="o">;</span>

    <span class="kd">static</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="no">MIN_LOTTO_NUMBER</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">MIN_LOTTO_NUMBER</span> <span class="o">+</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="no">NUMBERS</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="k">new</span> <span class="nc">LottoNumber</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">LottoNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">lottoNumber</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lottoNumber</span> <span class="o">=</span> <span class="n">lottoNumber</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">LottoNumber</span> <span class="nf">of</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">){</span>
        <span class="nc">LottoNumber</span> <span class="n">lottoNumber</span> <span class="o">=</span> <span class="no">NUMBERS</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">lottoNumber</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="no">OUT_OF_RANGE</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">lottoNumber</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Lotto</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">LottoNumber</span><span class="o">&gt;</span> <span class="n">lottoNumbers</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Lotto</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">LottoNumber</span><span class="o">&gt;</span> <span class="n">lottoNumbers</span><span class="o">){</span>
        <span class="n">validateDuplication</span><span class="o">(</span><span class="n">lottoNumbers</span><span class="o">);</span>
        <span class="n">validateAmountOfNumbers</span><span class="o">(</span><span class="n">lottoNumbers</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lottoNumbers</span> <span class="o">=</span> <span class="n">lottoNumbers</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateAmountOfNumbers</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">LottoNumber</span><span class="o">&gt;</span> <span class="n">lottoNumbers</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateDuplication</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">LottoNumber</span><span class="o">&gt;</span> <span class="n">lottoNumbers</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WinnigLotto</span> <span class="o">{</span>
    <span class="c1">//...</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">BONUS_CANNOT_BE_DUPLICATE_WITH_WINNING_NUMBER</span> <span class="o">=</span>
            <span class="s">"보너스 넘버는 위닝 넘버와 중복될 수 없습니다."</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">Lotto</span> <span class="n">winningLottoNumbers</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">bonusNumbers</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">WinnigLotto</span><span class="o">(</span><span class="nc">Lotto</span> <span class="n">winningLottoNumbers</span><span class="o">,</span> <span class="kt">int</span> <span class="n">bonusNumbers</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">winningLottoNumbers</span> <span class="o">=</span> <span class="n">winningLottoNumbers</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isBonusNumberDuplicatedWithWinningNumber</span><span class="o">(</span><span class="n">winningLottoNumbers</span><span class="o">,</span> <span class="n">bonusNumbers</span><span class="o">)){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="no">BONUS_CANNOT_BE_DUPLICATE_WITH_WINNING_NUMBER</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">bonusNumbers</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="n">bonusNumbers</span> <span class="o">&gt;</span> <span class="mi">45</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">bonusNumbers</span> <span class="o">=</span> <span class="n">bonusNumbers</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isBonusNumberDuplicatedWithWinningNumber</span><span class="o">(</span><span class="nc">Lotto</span> <span class="n">winningLottoNumbers</span><span class="o">,</span> <span class="kt">int</span> <span class="n">bonusNumbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위의 코드를 살펴보면 Lotto 클래스에서는 int 값인 로또 숫자 하나하나를 <code class="language-plaintext highlighter-rouge">LottoNumber</code>로 포장해서 사용하고 있는 것을 볼 수 있다.<br />
(<code class="language-plaintext highlighter-rouge">List&lt;int&gt;</code>가 아닌 <code class="language-plaintext highlighter-rouge">List&lt;LottoNumber&gt;</code> 사용)</p>

<p>물론 LottoNumber 대신에 Integer, int와 같은 자료형을 사용할 수도 있다.(아마 캐싱은 하지 않았거나, Lotto 클래스 내부에서 이루어졌을 것이다.)<br />
그렇게 되면 위에서 다루었듯이 <strong>개별 로또 숫자</strong>에 관한 관리가 <strong>로또</strong>에서 이루어져 로또가 수행하는 일이 늘어날 수 밖에 없어진다.<br />
자연히 Lotto 클래스의 크기도 커지게 될 것이다. 객체지향과도 작별 인사를 할 수 밖에 없어진다.</p>

<p>또 다른 문제도 있다. 현재는 로또 숫자의 범위가 1~45인데 혹여나 많은 사람들이 당첨되면 좋겠다는 생각을 하는 사람이 나타나서 나는 로또 숫자의 범위를<br />
1-10으로 할거야!라며 <strong>조건을 변경시키고, 추가시킨다면?</strong> 만약 Winning의 예시처럼 로또 숫자가 원시값이라면 같은 조건의 로또 숫자가 사용되는<br />
WinningLotto 클래스의 Lotto 클래스를 모두 고칠 수 밖에 없어진다.</p>
<blockquote>
  <p>정말 비효율적이다.</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WinnigLotto</span> <span class="o">{</span>
    <span class="c1">//...</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">BONUS_CANNOT_BE_DUPLICATE_WITH_WINNING_NUMBER</span> <span class="o">=</span>
            <span class="s">"보너스 넘버는 위닝 넘버와 중복될 수 없습니다."</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">Lotto</span> <span class="n">winningLottoNumbers</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">LottoNumber</span> <span class="n">bonusNumbers</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">WinnigLotto</span><span class="o">(</span><span class="nc">Lotto</span> <span class="n">winningLottoNumbers</span><span class="o">,</span> <span class="nc">LottoNumber</span> <span class="n">bonusNumbers</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">winningLottoNumbers</span> <span class="o">=</span> <span class="n">winningLottoNumbers</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isBonusNumberDuplicatedWithWinningNumber</span><span class="o">(</span><span class="n">winningLottoNumbers</span><span class="o">,</span> <span class="n">bonusNumbers</span><span class="o">)){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="no">BONUS_CANNOT_BE_DUPLICATE_WITH_WINNING_NUMBER</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">bonusNumbers</span> <span class="o">=</span> <span class="n">bonusNumbers</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isBonusNumberDuplicatedWithWinningNumber</span><span class="o">(</span><span class="nc">Lotto</span> <span class="n">winningLottoNumbers</span><span class="o">,</span> <span class="kt">int</span> <span class="n">bonusNumbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>비효율성을 제거하기 위해 위처럼 원시값인 개별 로또 숫자를 LottoNumber로 포장만해 주면 로또 숫자의 확장, 변경에 대해 유연해진다.<br />
Lotto와 WinningLotto는 전혀 바꿀 필요가 없다. 로또 숫자를 포장한 LottoNumver만 수정해주면 되기 때문이다.</p>

<h2 id="자료형에-구애받지-않는다여러-타입의-지원이-가능하다">자료형에 구애받지 않는다.(여러 타입의 지원이 가능하다.)</h2>
<p>점수라는 값을 포장한 Score 클래스가 있다. 현재 점수는 int 값이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Scroe</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">score</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Scroe</span><span class="o">(</span><span class="kt">int</span> <span class="n">score</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">validateScore</span><span class="o">(</span><span class="n">score</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">score</span> <span class="o">=</span> <span class="n">score</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateScore</span><span class="o">(</span><span class="kt">int</span> <span class="n">score</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>점수를 보여주는 역할만 했던 Score 객체에 연산 등의 기능이 추가되어 새로운 자료형의 지원이 필요해졌다면?<br />
기존의 Score 변수를 없앨 필요가 없다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Scroe</span> <span class="o">{</span>
   <span class="kd">private</span> <span class="kt">int</span> <span class="n">score</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kt">double</span> <span class="n">doubleScore</span><span class="o">;</span>

   <span class="kd">public</span> <span class="nf">Scroe</span><span class="o">(</span><span class="kt">int</span> <span class="n">score</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">validateScore</span><span class="o">(</span><span class="n">score</span><span class="o">);</span>
      <span class="k">this</span><span class="o">.</span><span class="na">score</span> <span class="o">=</span> <span class="n">score</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="nf">Scroe</span><span class="o">(</span><span class="kt">double</span> <span class="n">doubleScore</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">validateDobuleScore</span><span class="o">(</span><span class="n">doubleScore</span><span class="o">);</span>
      <span class="k">this</span><span class="o">.</span><span class="na">doubleScore</span> <span class="o">=</span> <span class="n">doubleScore</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateScore</span><span class="o">(</span><span class="kt">int</span> <span class="n">score</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">//...</span>
   <span class="o">}</span>

   <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateDobuleScore</span><span class="o">(</span><span class="kt">double</span> <span class="n">doubleScore</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">//...</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>앞서 말했듯이 유지, 보수에 도움이 되는 점을 이요하면 된다. 기존 Score 클래스를 활용하면 된다.<br />
doubleScore라는 멤버변수를 추가하고, 생성자 오버로딩을 통해 간단히 해결할 수 있다. String 값이 필요하다 해도 마찬가지로 해결이 가능하다.</p>

<h2 id="마무리">마무리</h2>
<p>원시 타입을 포장하게 되면, 그 변수가 의미하는 바를 정확하게 나타낼 수 있다.<br />
책임 관계 또한 명확해지고 코드의 유지, 보수에도 많은 도움이 된다.<br />
실제 프리코스 2주차 자동차 경주게임을 구현해보면서 그 장점을 느껴보고 싶다 !</p>

<h3 id="참고">참고</h3>
<ul>
  <li><a href="https://tecoble.techcourse.co.kr/post/2020-05-29-wrap-primitive-type/">유원시 타입을 포장해야 하는 이유</a></li>
  <li><a href="https://developerfarm.wordpress.com/2012/01/27/object_calisthenics_4/">소트웍스 앤솔러지 - 규칙 3: 원시값과 문자열의 포장</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="java" /><category term="java" /><category term="OOP" /><category term="OBJECT-CALISTHENIC" /><summary type="html"><![CDATA[우아한 테크캠프 Pro 프리코스 2주차 과제에서는 1주차 과제에서 추가로 모든 원시값과 문자열을 포장하라라는 프로그래밍 요구사항이 추가되었다. 2기_오렌지님이 올려주신 원시 타입을 포장해야 하는 이유를 보고 정리한 글입니다.]]></summary></entry><entry><title type="html">[Java] 람다식 문법</title><link href="http://localhost:4000/java/2022-04-22-lambda-expression-syntax/" rel="alternate" type="text/html" title="[Java] 람다식 문법" /><published>2022-04-22T00:00:00+09:00</published><updated>2022-04-22T21:05:27+09:00</updated><id>http://localhost:4000/java/lambda-expression-syntax</id><content type="html" xml:base="http://localhost:4000/java/2022-04-22-lambda-expression-syntax/"><![CDATA[<p>예제로 람다식 문법에 대해 배워보자. 아래 예제는 0부터 9까지의 숫자를 출력하는 2가지 방법에 대해 서술한다.</p>

<h2 id="1-전통적인-방법">1. 전통적인 방법</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>위는 기초 프로그래밍에서 흔히 볼 수 있는 for문을 이욯한 아주 기초적인 코드다.<br />
이는 각각의 요소들을 하나하나 일일이 검증하며 순차적으로 값을 확인하여 조건절이 끝날떄까지 진행되고 있으며, 이러한 코드는 특별한 경우라면 최적화되지 않고 들어오는 순서대로 진행된다.</p>

<h2 id="2-더-나은-방법">2. 더 나은 방법</h2>
<p>그러나 빨리 끝나는 일을 먼저 하거나 한번에 여러가지 일을 하는 것이 당연히 효율적이며 짧은 시간내에 작업을 끝낼 수 있다.<br />
또한 <strong>1부터 10까지 1씩 증가하면서 이 코드를 순차적으로 실행해라</strong>라고 <strong>명령</strong>하는 것 보다는<br />
<strong>여기 있는거 다 해</strong>라고 <strong>설명</strong>하는 것이 더욱 직관적이며 간결하다.</p>

<p>이러한 방식을 <code class="language-plaintext highlighter-rouge">Tell, Don't Ask</code>원칙이라 하며, 우리말로 한다면 <code class="language-plaintext highlighter-rouge">묻지 않고 시키기</code>로 볼 수 있다.
아래는 <code class="language-plaintext highlighter-rouge">Tell, Don't Ask</code>원칙에 따라 람다식으로 재작성한 코드로, 이렇게 할 경우 기초적인 수준에서 생기는 장점은 for문과는 달리 개념적으로 설명이 단순해 이해가 빠르다는 점이며,<br />
여기서는 잘 드러나지 않지만 복잡한 프로그래밍을 할 때 코드가 간결해지는 장점이 있다.
게다가 순수 함수로만 코드를 작성하면 for문과 i등의 변수를 사용하는 방식과 다르게 매번 같은 동작이 보장되서 병렬처리가 보다 수월해진다.</p>

<ul>
  <li>Java 8부터 지원되는 람다식을 사용한 코드
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">10</span><span class="o">).</span><span class="na">forEach</span><span class="o">((</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">value</span><span class="o">));</span>
</code></pre></div>    </div>
  </li>
  <li>컴파일러의 추론을 통해 파라미터의 자료형을 생략한 코드
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">10</span><span class="o">).</span><span class="na">forEach</span><span class="o">((</span><span class="n">value</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">value</span><span class="o">));</span>
</code></pre></div>    </div>
  </li>
  <li>메서드 참조를 사용한 코드
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">10</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="참고">참고</h3>
<ul>
  <li><a href="https://namu.wiki/w/%EB%9E%8C%EB%8B%A4%EC%8B%9D">소트웍스 앤솔러지 - 규칙 8: 일급 콜렉션 사용</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="java" /><category term="java" /><summary type="html"><![CDATA[예제로 람다식 문법에 대해 배워보자. 아래 예제는 0부터 9까지의 숫자를 출력하는 2가지 방법에 대해 서술한다.]]></summary></entry><entry><title type="html">[jekyll] jekyll 실행 시 cannot load such file – webrick (LoadError) 에러 조치 방법</title><link href="http://localhost:4000/frontend/2022-04-21-jekyll-error-webrick/" rel="alternate" type="text/html" title="[jekyll] jekyll 실행 시 cannot load such file – webrick (LoadError) 에러 조치 방법" /><published>2022-04-21T00:00:00+09:00</published><updated>2022-04-22T21:38:17+09:00</updated><id>http://localhost:4000/frontend/jekyll-error-webrick</id><content type="html" xml:base="http://localhost:4000/frontend/2022-04-21-jekyll-error-webrick/"><![CDATA[<p>데스크탑 컴퓨터를 최근에 포맷 후 개발환경 셋팅을 다시 하는 중이다. 포맷 이후 노트북에서만 작업하다가 데탑에서 블로그 포스팅 작업을 하려고 <code class="language-plaintext highlighter-rouge">bundle exec jekyll serve</code>로
로컬에서 jekyll 서버를 구동하려고했다. 근데 아래와 같이 webrick을 로드하지 못했다는 오류가 발생했다.</p>

<p><img src="/assets\img/jekyll-webrick-error.png" alt="jekyll-webrick-error" /></p>

<p>이런 경우 <code class="language-plaintext highlighter-rouge">bundle add webrick</code>으로 webrick을 추가해주고 다시 실행하면 된다.<br />
이유는 ruby 3.0.0부터 webrick이 기본으로 포함된 gem에서 빠졌기 때문이다.</p>

<h3 id="참고">참고</h3>
<ul>
  <li><a href="https://junho85.pe.kr/1850">jekyll 실행 시킬 때 `require’: cannot load such file – webrick (LoadError) 오류가 난다면 bundle add webrick</a></li>
  <li><a href="github.com/jekyll/jekyll/issues/8523">Jekyll serve fails on Ruby 3.0 #8523</a></li>
  <li><a href="https://www.ruby-lang.org/en/news/2020/12/25/ruby-3-0-0-released/">Ruby 3.0.0 Released</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="frontEnd" /><category term="Web" /><category term="jekyll" /><summary type="html"><![CDATA[데스크탑 컴퓨터를 최근에 포맷 후 개발환경 셋팅을 다시 하는 중이다. 포맷 이후 노트북에서만 작업하다가 데탑에서 블로그 포스팅 작업을 하려고 bundle exec jekyll serve로 로컬에서 jekyll 서버를 구동하려고했다. 근데 아래와 같이 webrick을 로드하지 못했다는 오류가 발생했다.]]></summary></entry><entry><title type="html">[우아한 테크캠프 Pro] 우아한 테크캠프 Pro 프리코스 1주차 - TDD로 숫자 야구게임 구현</title><link href="http://localhost:4000/java/2022-04-19-woowa-precourse-week1-TDD/" rel="alternate" type="text/html" title="[우아한 테크캠프 Pro] 우아한 테크캠프 Pro 프리코스 1주차 - TDD로 숫자 야구게임 구현" /><published>2022-04-19T00:00:00+09:00</published><updated>2022-04-22T21:38:17+09:00</updated><id>http://localhost:4000/java/woowa-precourse-week1-TDD</id><content type="html" xml:base="http://localhost:4000/java/2022-04-19-woowa-precourse-week1-TDD/"><![CDATA[<p>우아한 테크캠프 Pro 프리코스 1주차 과제 완료 후 2차 과제와 함께 1주차 과제인 숫자 야구 게임을 TDD로 구현하는 방법에 대한 동영상 강의가 제공되었다.
이 포스팅에서는 해당 강의에 대한 내용을 정리하고자 한다.</p>

<h2 id="test-driven-development테스트-주도-개발-tdd">Test Driven Development(테스트 주도 개발, TDD)</h2>
<h3 id="용어-정리">용어 정리</h3>
<ul>
  <li>Prodiction code: 실제 배포하는 서비스 코드</li>
  <li>Test code: production code에 대한 테스트를 구현하는 코드</li>
</ul>

<h3 id="tdd란">TDD란?</h3>
<ul>
  <li>TDD = TFD(Test First Development) + 리팩토링</li>
  <li>단위테스트와 TDD를 같다고 생각하는 사람이 있으나, Nope! 이 둘은 엄연히 다르다.</li>
  <li>단위테스트 : Production Code 구현 → 단위 Test Code 구현</li>
  <li>TDD: Production Code를 추가하기 전 단위 Test Code를 먼저 추가하는 것</li>
  <li>그럼 그냥 TFD(Test First Development)로 말하면되는데 왜 TDD라고 할까?</li>
  <li>이유: TDD의 과정에 리팩토링이 포함되어 있기 때문</li>
  <li>TDD는 리팩토링을 한 번에 하는 것이 아닌 작은 단위로 쪼개서 하는 것이다.</li>
  <li>ex) 기능이 추가 될 때 마다 설계를 계속 변경하는 것</li>
  <li><strong>리팩토링은 TDD 사이클에서 상당히 중요하다.</strong>
    <blockquote>
      <p><strong>리팩토링이란?</strong>
리팩토링은 설계의 활동이다.
기능에 대한 변경은 없으면서 클래스의 구조, 메서드 분리</p>
    </blockquote>
  </li>
  <li>TDD란 프로그래밍 의사결정과 피드백 사이의 간극을 의식하고 이를 제어하는 기술이다. - 켄트백, Test Driven Development by Example 중</li>
  <li>TDD의 아이러니 중 하나는 <strong>테스트</strong> 기술이 아니라는 점이다. TDD는 <strong>분석</strong> 기술이며, <strong>설계</strong> 기술이기도 하다. - 켄트벡, Test Driven Development by Example 중</li>
</ul>

<p>TDD를 잘하기 위해서는 요구사항 분석을 잘하여 To Do List를 작성해놔야 한다.</p>

<h3 id="tdd를-하는-이유">TDD를 하는 이유</h3>
<ul>
  <li>디버깅 시간을 줄여준다.</li>
  <li>동작하는 문서 역할을 한다.</li>
  <li>변화에 대한 두려움을 줄여준다.</li>
</ul>

<h3 id="tdd-사이클">TDD 사이클</h3>
<p>아래 싸이클을 유지하면서 프로그래밍 하는 것을 TDD 사이클이라 한다.</p>
<ol>
  <li>Test fails: 실패하는 Test를 구현한다.</li>
  <li>Test passes: 테스트가 성공하도록 Production Code를 구현한다. 즉, 실패하는 테스트를 최대한 빠르게 패스한다.</li>
  <li>Refactoring: Production Code와 Test Code를 리팩토링 한다.</li>
</ol>

<h3 id="tdd-원칙">TDD 원칙</h3>
<ol>
  <li>실패하는 단위 테스트를 작성할 때까지 Production code를 작성하지 않는다.</li>
  <li>컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위테스트를 작성한다.</li>
  <li>현재 실패하는 Test를 통과할 정도로만 실제 코드를 작성한다.</li>
</ol>

<p>즉, 너무 많은 부분을 예측해서 개발하지 말고 현재 TestCase를 만족할 수 있는 수준으로만 Proction code를 작성해라.</p>

<h2 id="tdd로-숫자-야구게임-구현">TDD로 숫자 야구게임 구현</h2>
<h3 id="기능-요구사항">기능 요구사항</h3>
<ul>
  <li>기본적으로 1부터 9까지 서로 다른 수로 이루어진 3자리의 수를 맞추는 게임이다.</li>
  <li>스트라이크: 같은 수가 같은 자리에 있는 경우</li>
  <li>볼: 같은 수가 다른 자리에 있는 경우</li>
  <li>낫싱: 같은 수가 전혀 없음</li>
</ul>

<h3 id="1단계---util-성격의-기능이-tdd로-도전하기-좋음">1단계 - Util 성격의 기능이 TDD로 도전하기 좋음</h3>
<ul>
  <li>사용자로부터 입력받는 3개의 숫자 예외처리
    <ul>
      <li>1~9의 숫자인가?</li>
      <li>중복 값이 있는가?</li>
      <li>3자리인가?</li>
    </ul>
  </li>
</ul>

<p>1.Test fails: 실패하는 Test를 구현한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ValidationUtilsTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"야구 숫자 1부터 9까지 검증"</span><span class="o">)</span>
    <span class="kt">void</span> <span class="nf">Baseball_Number_1_9_Verification</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">VlidationUtils</span><span class="o">.</span><span class="na">validNo</span><span class="o">(</span><span class="mi">9</span><span class="o">);</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="n">result</span><span class="o">).</span><span class="na">isTrue</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>2.Test passes: 테스트가 성공하도록 Production Code를 구현한다. 즉, 실패하는 테스트를 최대한 빠르게 패스한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ValidationUtilsTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"야구 숫자 1부터 9까지 검증"</span><span class="o">)</span>
    <span class="kt">void</span> <span class="nf">Baseball_Number_1_9_Verification</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">VlidationUtils</span><span class="o">.</span><span class="na">validNo</span><span class="o">(</span><span class="mi">9</span><span class="o">);</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="n">result</span><span class="o">).</span><span class="na">isTrue</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">VlidationUtils</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">validNo</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="mi">9</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>3.Refactoring: Production Code와 Test Code를 리팩토링 한다.</p>
<ul>
  <li>1차 리펙토링</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ValidationUtilsTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"야구 숫자 1부터 9까지 검증"</span><span class="o">)</span>
    <span class="kt">void</span> <span class="nf">Baseball_Number_1_9_Verification</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="nc">VlidationUtils</span><span class="o">.</span><span class="na">validNo</span><span class="o">(</span><span class="mi">9</span><span class="o">)).</span><span class="na">isTrue</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">VlidationUtils</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">validNo</span><span class="o">(</span><span class="kt">int</span> <span class="n">no</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">no</span><span class="o">&lt;=</span><span class="mi">9</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>2차 리펙토링</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ValidationUtilsTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"야구 숫자 1부터 9까지 검증"</span><span class="o">)</span>
    <span class="kt">void</span> <span class="nf">Baseball_Number_1_9_Verification</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="nc">VlidationUtils</span><span class="o">.</span><span class="na">validNo</span><span class="o">(</span><span class="mi">9</span><span class="o">)).</span><span class="na">isTrue</span><span class="o">();</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="nc">VlidationUtils</span><span class="o">.</span><span class="na">validNo</span><span class="o">(</span><span class="mi">1</span><span class="o">)).</span><span class="na">isTrue</span><span class="o">();</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="nc">VlidationUtils</span><span class="o">.</span><span class="na">validNo</span><span class="o">(</span><span class="mi">0</span><span class="o">)).</span><span class="na">isFalse</span><span class="o">();</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="nc">VlidationUtils</span><span class="o">.</span><span class="na">validNo</span><span class="o">(</span><span class="mi">10</span><span class="o">)).</span><span class="na">isFalse</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">VlidationUtils</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MIN_NO</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MAX_NO</span> <span class="o">=</span> <span class="mi">9</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">validNo</span><span class="o">(</span><span class="kt">int</span> <span class="n">no</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">no</span> <span class="o">&gt;=</span> <span class="no">MIN_NO</span> <span class="o">&amp;&amp;</span> <span class="n">no</span><span class="o">&lt;=</span> <span class="no">MAX_NO</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2단계---테스트-가능한-부분에-대해-tdd로-도전">2단계 - 테스트 가능한 부분에 대해 TDD로 도전</h3>
<ul>
  <li>스트라이크: 같은 수가 같은 자리에 있는 경우</li>
  <li>볼: 같은 수가 다른 자리에 있는 경우</li>
  <li>낫싱: 같은 수가 전혀 없음</li>
</ul>

<p>테스팅이 가능한 부분 → 랜덤, UI, 날짜 데이터가 있으면 Test가 하기 힘든데 그런것들이 없는 것을 말함.</p>

<h4 id="첫번쨰-방법">첫번쨰 방법</h4>
<hr />
<p>com / user<br />
123, 456 → nothing<br />
123, 245 → 1 ball<br />
123, 145 → 1 strike</p>

<p>PlayResult result = play(Arrays.asList(1,2,3), Arrays.asList(4,5,6))</p>

<hr />
<p>위치값을 모르고 각 수만 아는 경우 ball인지 strike인지 알 수가 없다. 따라서 위치값을 넣어줘야한다.
아래에서는 ‘위치값, 숫자’와 같은 형태로 표현했다. TDD를 할 때는 위와 같은 형태보다 작은 형태로 쪼갠 아래와 같은 형태가 더 쉽다.</p>

<p>com / user<br />
1 1 , 1 1 → 1 strike<br />
1 4 , 2 4 → 1 ball<br />
1 4 , 2 5 → nothing</p>

<p><span style="color:red">문제를 작은 단위로 쪼갠 뒤 TDD 구현을 도전하라</span></p>

<h4 id="난이도를-높여서-두-번쨰-방법">난이도를 높여서, 두 번쨰 방법</h4>
<p>com / user<br />
123 / 1 4 → nothing<br />
123 / 1 2 → ball<br />
123 / 1 1 → strike</p>

<p>도메인 로직에서 객체에 접근해 Getter를 이용하여 데이터를 가져와 비교하지 말고, <span style="color:red">객체 내에 판단 로직을 만들어 객체가 일하게 만들어라.</span></p>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="java" /><category term="java" /><summary type="html"><![CDATA[우아한 테크캠프 Pro 프리코스 1주차 과제 완료 후 2차 과제와 함께 1주차 과제인 숫자 야구 게임을 TDD로 구현하는 방법에 대한 동영상 강의가 제공되었다. 이 포스팅에서는 해당 강의에 대한 내용을 정리하고자 한다.]]></summary></entry><entry><title type="html">[우아한 테크캠프 Pro] 우아한 테크캠프 Pro 프리코스 1주차 공통 피드백</title><link href="http://localhost:4000/java/2022-04-19-woowa-precourse-week1-common-feedback/" rel="alternate" type="text/html" title="[우아한 테크캠프 Pro] 우아한 테크캠프 Pro 프리코스 1주차 공통 피드백" /><published>2022-04-19T00:00:00+09:00</published><updated>2022-04-22T21:38:17+09:00</updated><id>http://localhost:4000/java/woowa-precourse-week1-common-feedback</id><content type="html" xml:base="http://localhost:4000/java/2022-04-19-woowa-precourse-week1-common-feedback/"><![CDATA[<p>우아한 테크캠프 Pro 프리코스 1주차 과제를 진행하면서 받은 공통 피드백을 정리해보겠다.</p>

<h2 id="이름을-통해-의도를-드러내라">이름을 통해 의도를 드러내라</h2>
<p>변수 이름, 함수(메소드) 이름, 클ㄹㅐ스 이름을 짓는데 시간을 투자하라.
이름을 통해 변수의 역할, 함수의 역할, 클래스의 역할에 대한 의도를 드러내기위해 노력하라.
연속적인 숫자를 덧붙인 이름(a1, a2, …, aN) 덧붙이거나 불용어(Info, Daa, a, an, the)를 추가하는 방식은 적절하지 못하다.</p>

<h2 id="축약하지마라">축약하지마라</h2>
<p>의도를 드러낼 수 있다면 이름이 길어져도 괜찮다.</p>

<h2 id="개발도구의-code-format-기능을-활용해라">개발도구의 code format 기능을 활용해라</h2>
<p>IntelliJ 또는 Eclipse의 formatting 기능을 활용한다.</p>
<ul>
  <li>IntelliJ : <strong>Ctrl+Alt+L(윈도우)</strong>, Cmd+Alt+L(맥)</li>
  <li>Eclipse : Ctrl+Shift+F(윈도우), Cmd+Shift+F(맥)</li>
</ul>

<h2 id="space공백도-convention이다">space(공백)도 convention이다.</h2>
<p>for, while, if문 사이의 space도 convention이다.</p>

<h2 id="불필요하게-공백-라인을-만들지-않는다">불필요하게 공백 라인을 만들지 않는다.</h2>
<p>공백 라인을 띄우는 것도 코드상에 문맥이 달라지는 부분에 의도를 가지고 띄우면 좋겠다.</p>

<h2 id="구현-순서도-convetion이다">구현 순서도 Convetion이다.</h2>
<p>클래스의 구현 순서에 대한 convetion을 지키는 것도 읽기 좋은 코드를 구현하는데 의미가 있다.
클래스의 구현 순서를 지키면서 프로그래밍한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class A {
상수(static final) 또는 클래스 변수

인스턴스 변수

생성자

메소드
}
</code></pre></div></div>

<h2 id="반복하지마라">반복하지마라</h2>
<p>중복은 소프트웨어에서 모든 악의 근원이다.</p>

<h2 id="space-vs-tab-혼용">space vs tab 혼용</h2>
<p>들여쓰기에 space와 tab을 혼용하지 않는다.
둘중에 하나만 사용한다.
확신이 서지 않으면 pull request를 보낸 후 들여쓰기가 잘 되어 있는지 확인하는 습관을 들인다.</p>

<h2 id="의미없는-주석을-달지-않는다">의미없는 주석을 달지 않는다.</h2>
<p>변수 이름, 함수(메소드) 이름을 통해 어떤 의도인지가 드러난다면 굳이 주석을 달지 않는다.
모든 변수와 함수에 주석을 달기보다는 가능하면 이름을 통해 의도를 드러내고, 의도를 드러내기 힘든 경우 주석을 다는 연습을한다.</p>

<h2 id="값을-하드코딩-하지마라">값을 하드코딩 하지마라.</h2>
<p>문자열 숫자 등의 값을 하드코딩하지 마라.
상수(static final)를 만들고 이름을 부여해 이 변수의 역할이 무엇인지 의도를 드러내라.
구글에서 “java 상수”와 같은 키워드로 검색해 상수 구현 방법을 학습하고 적용해 본다.</p>

<h2 id="git-commit-메시지를-의미있게-작성">git commit 메시지를 의미있게 작성</h2>
<p>commit 메시지에 해당 commit에서 작업한 내용에 대한 이해가 가능하도록 작성한다.</p>

<h2 id="기능-목록-업데이트">기능 목록 업데이트</h2>
<p><code class="language-plaintext highlighter-rouge">README.md</code> 파일에 작성하는 기능 목록은 기능 구현을 하면서 변경될 수 있다.
시작할 때 모든 기능 목록을 완벽하게 정리해야 한다는 부담을 가지기 보다 기능을 구현하면서 문서를 계속 업데이트한다.
죽은 문서가 아니라 살아있는 문서를 만들기 위해 노력한다.</p>

<h2 id="기능-목록-구현을-재검토한다">기능 목록 구현을 재검토한다.</h2>
<p>기능 목록을 클래스 설계와 구현, 함수(메소드) 설계와 구현과 같이 너무 상세하게 적지 않는다.
클래스 이름, 함수(메소드) input/output은 언제든지 변경될 수 있기 때문이다.
너무 세세한 부분까지 정리하기보다 구현해야할 기능 목록을 정리하는데에 집중한다.
<strong>정상적인 경우도 중요하지만 예외적인 상황도 기능 목록에 정리</strong>한다.
특히 예외 상황은 시작 단계에서 모두 찾기 힘들기 때문에 기능을 구현하면서 계속 추가해 나간다.</p>

<h2 id="readmemd를-상세히-작성">README.md를 상세히 작성</h2>
<p>미션 저장소의 README.md는 소스코드에 앞서 해당 프로젝트가 어떠한 프로젝트인지 <strong>마크다운</strong>으로 작성하여 소개하는 문서이다.
해당 프로젝트가 어떠한 프로젝트이며, 어떤 기능을 담고 있는지 기술하기 위해서 마크다운 문법을 검색해서 학습해보고 적용해본다.</p>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="java" /><category term="java" /><summary type="html"><![CDATA[우아한 테크캠프 Pro 프리코스 1주차 과제를 진행하면서 받은 공통 피드백을 정리해보겠다.]]></summary></entry><entry><title type="html">[AssertJ] AssertJ란?</title><link href="http://localhost:4000/java/2022-04-12-Introduction-To-AssertJ/" rel="alternate" type="text/html" title="[AssertJ] AssertJ란?" /><published>2022-04-12T00:00:00+09:00</published><updated>2022-04-23T03:18:22+09:00</updated><id>http://localhost:4000/java/Introduction-To-AssertJ</id><content type="html" xml:base="http://localhost:4000/java/2022-04-12-Introduction-To-AssertJ/"><![CDATA[<p>오늘의 목표: 공식문서를 보고 Junit과 AssertJ를 직접 사용하며 사용법 익히기!</p>

<p>새로운걸 배우니 심장이 두근두근하다. 실제 업무에서 Junit을 이용해 테스트 코드를 작성하는 사람도 있을텐데 난 너무 늦은게 아닌가… 싶으면서 조급한 마음도 든다. 쫄리는 마음 드는 시간에 하나라도 더 배우자 :)</p>

<h2 id="assertj란">AssertJ란?</h2>
<ul>
  <li>Java 테스트에서 능숙하고 풍부한 Assertions을 작성하는 데 사용되는 오픈 소스 커뮤니티 기반 라이브러리
    <ul>
      <li>Junit과 함께 편리하게 사용하게 해주는 라이브러리로, 테스트코드 작성을 훨씬 편리하게 도와준다.</li>
    </ul>
  </li>
  <li>이 글은 <strong>AssertJ-core</strong>라는 기본 AssertJ 모듈에서 사용할 수 있는 툴에 초점을 맞추고 있다.</li>
  <li>Assertions
    <ul>
      <li>사전적 의미: 사실임을 주장하는 것</li>
      <li>표명, 가정 설정문, 어서션이라고도 함</li>
      <li>프로그램 안에 추가하는 <strong>참 거짓을 미리 가정하는 문</strong></li>
    </ul>
  </li>
</ul>

<h3 id="1-gradle-dependencies">1. Gradle Dependencies</h3>
<p>assetJ를 사용하기 위해서는 build.gradle 파일에 있는 <code class="language-plaintext highlighter-rouge">dependency</code> 부분에 아래와 같은 코드를 추가해줘야 한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependencies {
    testImplementation "org.assertj:assertj-core:3.20.2"
}
</code></pre></div></div>
<p>위 디펜던시는 오직 기본 Java assertions만 제공한다. 따라서 만약 advanced assertions를 사용하고 싶다면, 추가로 별개의 모듈을 디펜던시에 추가해줘야한다.<br />
Java 7 이전 버전의 경우 Assertj-core version 2.x.x를 사용해야 한다. 최신 버전은 <a href="https://search.maven.org/search?q=a:assertj-core">여기</a>에서 찾을 수 있다.</p>

<h3 id="2-소개">2. 소개</h3>
<p>AssertJ는 여러 클래스들의 집합과 풍부하고 아름다운 assertions을 쉽게 작성할 수 있는 유틸리티 메소드를 제공한다.</p>
<ul>
  <li>사용 가능한 언어
    <ul>
      <li>Standard Java</li>
      <li>Java 8</li>
      <li>Guava</li>
      <li>Joda Time</li>
      <li>Neo4J and</li>
      <li>Swing components</li>
    </ul>
  </li>
</ul>

<p>사용 가능한 모든 언어들은 프로젝트 <a href="https://joel-costigliola.github.io/assertj/">웹사이트</a>에서 확인 가능하다.<br />
몇 개의 예시를 갖고 시작해보자. AssertJ의 문서에서 바로 다음 내용을 확인할 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>assertThat(frodo)
  .isNotEqualTo(sauron)
  .isIn(fellowshipOfTheRing);

assertThat(frodo.getName())
  .startsWith("Fro")
  .endsWith("do")
  .isEqualToIgnoringCase("frodo");

assertThat(fellowshipOfTheRing)
  .hasSize(9)
  .contains(frodo, sam)
  .doesNotContain(sauron);
</code></pre></div></div>
<p>위의 예들은 빙산의 일각에 불과하지만, 이 라이브러리로 Assertions를 쓰는 것이 어떤식으로 사용되는지에 대한 예시를 보여준다.</p>

<h3 id="3-assertj-실행하기">3. AssertJ 실행하기</h3>
<p>이 섹션에서는 AssertJ를 설정하고 이를 통해 무엇을 할 수 있는지에 대해 알아본다.</p>
<h4 id="31-시작하기">3.1 시작하기</h4>
<p>클래스패스에 있는 라이브러리의 jar을 사용하면, 테스트 클래스에 하나의 static import를 추가하여 쉽게 활성화가 가능하다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import static org.assertj.core.api.Assertions.*;
</code></pre></div></div>
<h4 id="32-assertions-작성하기">3.2 Assertions 작성하기</h4>
<p>asssertion을 작성하기 위해서는, 항상 객체를 <code class="language-plaintext highlighter-rouge">Assertions.assertThat()</code> 메서드에 전달하는 것부터 시작해야한다. 그런 다음 실제로 assertions를 수행한다.<br />
일부 다른 라이브러리와는 달리 아래 코드는 실제로 아무것도 참이라고 주장하지 않으며, <strong>절대로</strong> 테스트를 실패하지 않습니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>assertThat(anyRefenceOrValue);
</code></pre></div></div>
<p>IDE의 코드완성기능을 사용하면 AssertJ Assertions를 쉽게 작성 가능하다. 인텔리제이 IDEA 2021.3 버전에서는 아래처럼 나온다.
<img src="/assets\img/assertJ_IntelliJ.png" alt="assertJ_IntelliJ" /></p>

<p>위처럼 상황별로 선택할 수 있는 다양한 메소드가 제공되며, 이 메소드들은 String 타입에만 사용이 가능하다.<br />
이 API에 대해 자세히 살펴보고 특정 Assertion에 대해 알아보자.</p>

<h4 id="33-object-assertions">3.3 Object Assertions</h4>
<p>Object는 두 객체가 동일한지를 결정하거나 객체의 필드를 조사하기 위해 다양한 방법으로 비교할 수 있다.<br />
2개의 Object가 동일한지에 대해 비교할 수 있는 두가지 방법을 보자.<br />
다음은 Dog 타입인 fido, fidosClone 2가지 객체가 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Float</span> <span class="n">weight</span><span class="o">;</span>

    <span class="c1">//Getter, Setter, Constructor</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DogTest</span> <span class="o">{</span>
    <span class="nc">Dog</span> <span class="n">fido</span>       <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">"Fido"</span><span class="o">,</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="mf">5.25</span><span class="o">);</span>
    <span class="nc">Dog</span> <span class="n">fidosClone</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">"Fido"</span><span class="o">,</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="mf">5.25</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>아래와 같은 assertion을 통해 쉽게 두 객체를 비교할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">isEqualTo</span><span class="o">(){</span>
    <span class="n">assertThat</span><span class="o">(</span><span class="n">fido</span><span class="o">).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="n">fidosClone</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위를 실행하면 <code class="language-plaintext highlighter-rouge">isEqualTo</code> 메소드는 두 객체의 참조를 비교하므로 fail을 반환한다.<br />
그 대신 내용을 자체를 비교하려면 다음과 같이 <code class="language-plaintext highlighter-rouge">isEqualToComparingFieldByFieldRecursively()</code> 메소드를 사용하면 된다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">isEqualToComparingFieldByFieldRecursively</span><span class="o">(){</span>
    <span class="n">assertThat</span><span class="o">(</span><span class="n">fido</span><span class="o">).</span><span class="na">isEqualToComparingFieldByFieldRecursively</span><span class="o">(</span><span class="n">fidosClone</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Fido랑 FidosClone 객체는 필드와 필드를 재귀적으로 비교할때 똑같다. 왜냐하면 한 객체의 필드를 다른 객체의 필드와 비교하기 때문이다.<br />
이 밖에도 객체의 필드들에 대해 비교하고, 축소하고, 조사하는 다양한 assertion 메소드가 있다. 모든 메소드를 확인하려면 공식 <a href="https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractObjectAssert.html">AbstractObjectAssert docs</a>를 참조하자.</p>

<h4 id="34-boolean-assertions">3.4 Boolean Assertions</h4>
<p>참거짓 테스트를 위한 간단한 메소드들이 있다.</p>
<ul>
  <li>isTrue()</li>
  <li>isFalse()
예시 소스코드를 보자
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">isTrue</span><span class="o">(){</span>
  <span class="n">assertThat</span><span class="o">(</span><span class="s">""</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()).</span><span class="na">isTrue</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="35-iterablearray-assertions">3.5 Iterable/Array Assertions</h4>
<p>Iterable 또는 Array의 경우 내용이 존재하는지에 대해 asserting 할 수 있는 다양한 방법이 있다. 가장 일반적인 assertions 중 하나는 <code class="language-plaintext highlighter-rouge">Iterable</code> 또는 <code class="language-plaintext highlighter-rouge">Array</code>에 주어진 element가 포함되어 있는지 확인 하는 것이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">arrayContain</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span><span class="s">"2"</span><span class="o">,</span><span class="s">"3"</span><span class="o">);</span>
    <span class="n">assertThat</span><span class="o">(</span><span class="n">list</span><span class="o">).</span><span class="na">contains</span><span class="o">(</span><span class="s">"1"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>List가 비어있지 않은지 검사하기</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">arrayIsNotEmpty</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span><span class="s">"2"</span><span class="o">,</span><span class="s">"3"</span><span class="o">);</span>
    <span class="n">assertThat</span><span class="o">(</span><span class="n">list</span><span class="o">).</span><span class="na">isNotEmpty</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>주어진 문자로 시작하는지 검사하기 ex) “1”</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">arrayStartsWith</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span><span class="s">"2"</span><span class="o">,</span><span class="s">"3"</span><span class="o">);</span>
    <span class="n">assertThat</span><span class="o">(</span><span class="n">list</span><span class="o">).</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"1"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>동일한 개체에 대해 둘 이상의 Assertion을 작성하려는 경우 체이닝을 통해 쉽게 결합할 수 있다.<br />
제공된 list가 비어 있지 않은지, “1” 원소를 포함하는지, null을 포함하지 않는지, 원소 “2”, “3”을 순서대로 포함하는지를 확인하는 Assertion의 예는 다음과 같다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">arrayTotalCheck</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span><span class="s">"2"</span><span class="o">,</span><span class="s">"3"</span><span class="o">);</span>
    <span class="n">assertThat</span><span class="o">(</span><span class="n">list</span><span class="o">).</span><span class="na">isNotEmpty</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="s">"1"</span><span class="o">).</span><span class="na">doesNotContainNull</span><span class="o">().</span><span class="na">containsSequence</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span><span class="s">"2"</span><span class="o">);</span>
    <span class="c1">//containsSequence("1","2"): 원소 "2", "3"을 순서대로 포함하는지</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="36-character-assertions">3.6 Character Assertions</h4>
<p>character에 대한 Asssertions는 비교 대상 문자가 유니코드 테이블에 있는지 확인하는 작업을 포함한다.</p>
<ul>
  <li>문자가 ‘a’가 아니고 유니코드 테이블에 있는지, ‘b’보가 같거나 크고, 소문자인지 확인하는 assertion
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">characterTest</span><span class="o">(){</span>
  <span class="kt">char</span> <span class="n">someCharacter</span> <span class="o">=</span> <span class="sc">'b'</span><span class="o">;</span>
  <span class="n">assertThat</span><span class="o">(</span><span class="n">someCharacter</span><span class="o">)</span>
          <span class="o">.</span><span class="na">isNotEqualTo</span><span class="o">(</span><span class="sc">'a'</span><span class="o">)</span>
          <span class="o">.</span><span class="na">inUnicode</span><span class="o">()</span>
          <span class="o">.</span><span class="na">isGreaterThanOrEqualTo</span><span class="o">(</span><span class="sc">'b'</span><span class="o">)</span>
          <span class="o">.</span><span class="na">isLowerCase</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="36-class-assertions">3.6 Class Assertions</h4>
<p>해당 필드, 클래스 유형, annotations의 존재 등을 체크한다.</p>
<ul>
  <li>Runnable 클래스가 인터페이스인지 확인
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">chkIsInterface</span><span class="o">(){</span>
  <span class="n">assertThat</span><span class="o">(</span><span class="nc">Runnable</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">isInterface</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>A 클래스에 B 클래스를 할당할 수 있는지 확인
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">IsAssignableFrom</span><span class="o">(){</span>
  <span class="c1">//assertThat(A.class).isAssignableFrom(B.class);</span>
  <span class="n">assertThat</span><span class="o">(</span><span class="nc">Exception</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">isAssignableFrom</span><span class="o">(</span><span class="nc">NoSuchElementException</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="37-file-assertions">3.7 File Assertions</h4>
<p>지정된 File 인스턴스가 존재하는지, 디렉토리 또는 파일인지, 특정 콘텐츠가 있는지, 읽을 수 있는지, 확장명이 있는지 등을 확인할 수 있다.</p>
<ul>
  <li>파일이 존재하고, 디렉토리가 아닌 파일이며, Read&amp;Write가 가능한지 확인
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">chkFile</span><span class="o">(){</span>
  <span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:\\github\\java-baseball-precourse\\src\\main\\java\\study\\Dog.java"</span><span class="o">);</span>
  <span class="n">assertThat</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
          <span class="o">.</span><span class="na">exists</span><span class="o">()</span>
          <span class="o">.</span><span class="na">isFile</span><span class="o">()</span>
          <span class="o">.</span><span class="na">canRead</span><span class="o">()</span>
          <span class="o">.</span><span class="na">canWrite</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="38-double--float--integer-assertions">3.8 Double / Float / Integer Assertions</h4>
<p>Numeric assertions는 주어진 오프셋을 포함하고 있는지 또는 포함하고 있지 않은지 모든 숫자값에 대해 비교하는 것이다.</p>
<ul>
  <li><strong>오프셋(offset)</strong>
    <ul>
      <li>컴퓨터 과학에서 배열이나 자료 구조 오브젝트 내의 오프셋(offset)은 일반적으로 동일 오브젝트 안에서 오브젝트 처음부터 주어진 요소나 지점까지의 변위차를 나타내는 정수형</li>
      <li>이를테면, 문자 A의 배열이 abcdef를 포함한다면 ‘c’ 문자는 A 시작점에서 <strong>2의 오프셋</strong>을 지님.</li>
      <li>어셈블리어와 같은 저급 프로그래밍 언어에서 오프셋은 상대 주소(relative address)로 부름.</li>
    </ul>
  </li>
</ul>

<p>예를들어, 만약 주어진 Precision에 따라 두 값이 동일한지 체크를 하고 싶다면 아래처럼 하면 된다.</p>
<ul>
  <li>Precision: 몇 자리 갭을 허용할거냐로 해석할건지 정확도를 지정하는 것. 0.123 이랑 0.124 같게 보려면 precision에 0.001d를 줘야함.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">chkNumeric</span><span class="o">(){</span>
    <span class="n">assertThat</span><span class="o">(</span><span class="mf">5.123</span><span class="o">).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="mf">5.124</span><span class="o">,</span> <span class="n">withPrecision</span><span class="o">(</span><span class="mf">0.001d</span><span class="o">));</span><span class="c1">//같음</span>
    <span class="c1">//assertThat(5.123).isEqualTo(5.124, withPrecision(0.0001d));//다름</span>
    <span class="c1">//assertThat(6.1).isEqualTo(5, withPrecision(1d));//다름</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="39-inputstream-assertions">3.9 InputStream Assertions</h4>
<p>InputStream Assertion은 1가지만 있다.</p>
<ul>
  <li>hasSameContentAs(InputStream expected)
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">testHasSomeContentAs</span><span class="o">(){</span>
  <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="o">};</span>
  <span class="nc">InputStream</span> <span class="n">given</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayInputStream</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>

  <span class="kt">byte</span><span class="o">[]</span> <span class="n">oneBytes</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="o">};</span>
  <span class="nc">InputStream</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayInputStream</span><span class="o">(</span><span class="n">oneBytes</span><span class="o">);</span>

  <span class="n">assertThat</span><span class="o">(</span><span class="n">given</span><span class="o">).</span><span class="na">hasSameContentAs</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="310-map-assertions">3.10 Map Assertions</h4>
<p>맵에 특정 항목, entry, key/value 값이 포함되어 있는지 확인한다.</p>
<ul>
  <li>맵이 비어있지 않고, Key 2 포함, Key 10 미포함, (2,”a”)를 포함하는지 확인
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">chkMap</span><span class="o">(){</span>
  <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;();</span>
  <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="s">"a"</span><span class="o">);</span>
<span class="c1">//  map.put(10,"b");</span>

  <span class="n">assertThat</span><span class="o">(</span><span class="n">map</span><span class="o">).</span><span class="na">isNotEmpty</span><span class="o">()</span>
          <span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
          <span class="o">.</span><span class="na">doesNotContainKey</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
          <span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">entry</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="s">"a"</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="311-throwable-assertions">3.11 Throwable Assertions</h4>
<p>Exception 메시지, stacktraces, 익셉션이 throw 되었는지 원인 확인 또는 검증할 때 사용</p>
<ul>
  <li>주어진 예외가 발생했는지 확인하고 “c”로 끝나는 메시지가 있는지 확인
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="n">ex</span><span class="o">).</span><span class="na">hasNoCause</span><span class="o">().</span><span class="na">hasMessageEndingWith</span><span class="o">(</span><span class="s">"c"</span><span class="o">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">assertThatThrownBy</code>와 <code class="language-plaintext highlighter-rouge">assertThatExceptionOfType</code> 두 가지 방법으로 에외를 발생시켰는지 확인이 가능하다.</p>
<ul>
  <li>assertThatThrownBy(): Java 8 Exception assertion 표준 스타일</li>
  <li>assertThatExeptionOfType(): 예외 클래스 넣기</li>
</ul>

<hr />

<h2 id="학습-테스트">학습 테스트</h2>
<h3 id="string-클래스에-대한-학습-테스트">String 클래스에 대한 학습 테스트</h3>
<h4 id="요구사항-1">요구사항 1</h4>
<ul>
  <li>“1,2”을 <code class="language-plaintext highlighter-rouge">,</code>로 split 했을 때 1과 2로 잘 분리되는지 확인하는 학습 테스트를 구현한다.</li>
  <li>“1”을 <code class="language-plaintext highlighter-rouge">,</code>로 split 했을 때 1만을 포함하는 배열이 반환되는지에 대한 학습 테스트를 구현한다.</li>
</ul>

<h5 id="힌트">힌트</h5>
<ul>
  <li>배열로 반환하는 값의 경우 assertj의 contatins()를 활용해 반환 값이 맞는지 검증한다.</li>
  <li>배열로 반환하는 값의 경우 assertj의 contains Exactly()를 활용해 반환값이 맞는지 검증한다.</li>
</ul>

<h5 id="테스트">테스트</h5>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">split</span><span class="o">(){</span>
    <span class="nc">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">"1,2"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="s">"1"</span><span class="o">;</span>

    <span class="nc">String</span><span class="o">[]</span> <span class="n">strArray1</span> <span class="o">=</span> <span class="n">str1</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">strArray2</span> <span class="o">=</span> <span class="n">str2</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>

    <span class="c1">//"1,2"를 ,로 split 했을 때 1과 2로 잘 분리되는지 확인</span>
    <span class="n">assertThat</span><span class="o">(</span><span class="n">strArray1</span><span class="o">).</span><span class="na">contains</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span><span class="s">"2"</span><span class="o">);</span>

    <span class="c1">//"1"을 ,로 split 했을 때 "1만을" 포함하는 배열이 반환되는지 확인</span>
    <span class="n">assertThat</span><span class="o">(</span><span class="n">strArray1</span><span class="o">).</span><span class="na">containsExactly</span><span class="o">(</span><span class="s">"1"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li><strong>assertJ의 contains와 containsExactly의 차이</strong>
    <ul>
      <li>contains: 순서와 상관 없이 실제 그룹이 주어진 값들을 포함하고 있는지를 테스트</li>
      <li>containsExactly: 순서까지 고려해서 실제 그룹이 주어진 값들을 포함하고 있는지를 테스트</li>
    </ul>
  </li>
</ul>

<h4 id="요구사항-2">요구사항 2</h4>
<ul>
  <li>“1,2” 값이 주어졌을 때 String의 substring() 메소드를 활용해 ()을 제거하고 “1,2”를 반환하도록 구현한다.</li>
</ul>

<h5 id="테스트-1">테스트</h5>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">subString</span><span class="o">(){</span>
    <span class="nc">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">"(1,2)"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">str1</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>

    <span class="n">assertThat</span><span class="o">(</span><span class="n">result</span><span class="o">).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="s">"1,2"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="요구사항-3">요구사항 3</h4>
<ul>
  <li>“abc” 값이 주어졌을 때 String의 charAt() 메소드를 활용해 특정 위치의 문자를 가져오는 학습 테스트를 구현한다.</li>
  <li>String의 charAt() 메소드를 활용해 특정 위치의 문자를 가져올 때 위치 값을 벗어나면 <code class="language-plaintext highlighter-rouge">StringIndexOutOfBoundException</code>이 발생하는 부분에 대한 학습 테스트를 구현한다.</li>
  <li>JUnit의 <code class="language-plaintext highlighter-rouge">@DisplayName</code>을 활용해 테스트 메소드의 의도를 드러낸다.</li>
</ul>

<h5 id="힌트-1">힌트</h5>
<ul>
  <li><a href="https://joel-costigliola.github.io/assertj/assertj-core-features-highlight.html#exception-assertion">AssertJ Exception Assertions</a> 문서 참고</li>
</ul>

<h5 id="테스트-2">테스트</h5>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"특정 위치의 문자를 가져온다."</span><span class="o">)</span>
<span class="kt">void</span> <span class="nf">charAt</span><span class="o">(){</span>
    <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
    <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
<span class="o">}</span>

<span class="nd">@Test</span>
<span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"charAt - assertThatThrownBy()를 사용하여 Exception 처리"</span><span class="o">)</span>
<span class="kt">void</span> <span class="nf">chatAtException</span><span class="o">(){</span>
    <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>

    <span class="n">assertThatThrownBy</span><span class="o">(()-&gt;{</span>
       <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
    <span class="o">}).</span><span class="na">isInstanceOf</span><span class="o">(</span><span class="nc">StringIndexOutOfBoundsException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
            <span class="o">.</span><span class="na">hasMessageContaining</span><span class="o">(</span><span class="s">"%d"</span><span class="o">,</span> <span class="n">idx</span><span class="o">);</span>
<span class="o">}</span>

<span class="nd">@Test</span>
<span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"charAt - assertThatExceptionOfType()를 사용하여 Exception 처리"</span><span class="o">)</span>
<span class="kt">void</span> <span class="nf">chatAtException2</span><span class="o">(){</span>
    <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>

    <span class="n">assertThatExceptionOfType</span><span class="o">(</span><span class="nc">StringIndexOutOfBoundsException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
            <span class="o">.</span><span class="na">isThrownBy</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
            <span class="o">}).</span><span class="na">withMessageContaining</span><span class="o">(</span><span class="s">"%d"</span><span class="o">,</span> <span class="n">idx</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="참조">참조</h2>
<ul>
  <li><a href="https://www.baeldung.com/introduction-to-assertj">Introduction to AssertJ</a></li>
  <li><a href="https://blog.naver.com/kunjalan/222622885642">Assertion의 기본 지식</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="java" /><category term="java" /><category term="AssertJ" /><summary type="html"><![CDATA[오늘의 목표: 공식문서를 보고 Junit과 AssertJ를 직접 사용하며 사용법 익히기! 새로운걸 배우니 심장이 두근두근하다. 실제 업무에서 Junit을 이용해 테스트 코드를 작성하는 사람도 있을텐데 난 너무 늦은게 아닌가… 싶으면서 조급한 마음도 든다. 쫄리는 마음 드는 시간에 하나라도 더 배우자 :)]]></summary></entry><entry><title type="html">[CS] 기술면접 예상 질문 - 자바</title><link href="http://localhost:4000/cs/2022-03-02-Technical-Interview-Expected-Questions-Java/" rel="alternate" type="text/html" title="[CS] 기술면접 예상 질문 - 자바" /><published>2022-03-02T00:00:00+09:00</published><updated>2022-04-22T21:38:17+09:00</updated><id>http://localhost:4000/cs/Technical-Interview-Expected-Questions-Java</id><content type="html" xml:base="http://localhost:4000/cs/2022-03-02-Technical-Interview-Expected-Questions-Java/"><![CDATA[<p>기술면접 단골질문</p>

<h3 id="1객체-지향-프로그래밍-oopobject-oriented-programming">1.객체 지향 프로그래밍 OOP(Object Oriented Programming)?</h3>
<p>Object를 기준으로 코드를 나누어 구현하는 프로그래밍(Java는 구분 단위가 class)</p>
<ul>
  <li>장점: 재사용성이 좋고, 협업하기가 좋다 (캡슐화, 추상화 때문에 쓰기 좋음)</li>
</ul>

<p>1) <strong>캡슐화</strong>: 비슷한 역할을 하는 속성과 메소드들을 하나의 클래스로 모은 것<br />
2) <strong>추상화</strong>: 어떤 실체로부터 공통적인 부분이나 관심있는 특성들만 한곳에 모은 것<br />
  ex) 어떤 하위 클래스들에 존재하는 공통적인 메서드를 인터페이스로 정의하는 것<br />
3) <strong>상속</strong>: 클래스를 재사용하는 것, 상속이 있기 때문에 코드를 재활용 할 수 있고 그렇기 때문에 생산성이 높고 유지보수하기 좋음<br />
4) <strong>다형성</strong></p>

<h3 id="2오버로딩과-오버라이딩의-차이">2.오버로딩과 오버라이딩의 차이</h3>
<p>1) 오버라이딩</p>
<ul>
  <li>부모 클래스에게 상속받은 메소드를 자식클래스에서 재정의 하는 것</li>
</ul>

<p>2) 오버로딩</p>
<ul>
  <li>한 클래스내에 이름이 같은 여러개의 메서드를 재정의하는 것</li>
  <li>메서드 시그니처가 다름</li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="cs" /><category term="cs" /><summary type="html"><![CDATA[기술면접 단골질문]]></summary></entry><entry><title type="html">[Effective Java] Day 33 - Item 66 :: 네이티브 메서드는 신중히 사용하라</title><link href="http://localhost:4000/java/2022-03-01-Effective-java-Day33-item66/" rel="alternate" type="text/html" title="[Effective Java] Day 33 - Item 66 :: 네이티브 메서드는 신중히 사용하라" /><published>2022-03-01T00:00:00+09:00</published><updated>2022-04-22T21:38:17+09:00</updated><id>http://localhost:4000/java/Effective-java-Day33-item66</id><content type="html" xml:base="http://localhost:4000/java/2022-03-01-Effective-java-Day33-item66/"><![CDATA[<p><strong>Java Native Interface(자바 네이티브 인터페이스, JNI)</strong>: 자바 프로그램이 네이티브 메서드를 호출하는 기술</p>

<h2 id="native-method네이티브-메서드">Native method(네이티브 메서드)</h2>
<p>C나 c++같은 네이티브 프로그래밍 언어로 작성한 메서드</p>
<h3 id="주요쓰임">주요쓰임</h3>
<ol>
  <li>레지스트리 같은 플랫폼 특화 기능을 사용함</li>
  <li>네이티브 코드로 작성된 기존 라이브러리 사용
    <ul>
      <li>레거시 데이터를 사용하는 레거시 라이브러리</li>
      <li>대체할 만한 Java 라이브러리가 없는 경우 네이티브 라이브러리를 사용함</li>
    </ul>
  </li>
  <li>성능개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성</li>
</ol>

<h3 id="성능-개선-목적의-네이티브-메서드-사용은-권장하지-않는다">성능 개선 목적의 네이티브 메서드 사용은 권장하지 않는다.</h3>
<ul>
  <li>자바 3 이전의 초기시절이라면 얘기가 다르지만, JVM은 그동안 빠른 속도로 발전해왔다.</li>
  <li>대부분 작업에서 지금의 자바는 다른 플랫폼에 견줄만한 성능을 보인다.
    <ul>
      <li>ex) BigInteger
        <ul>
          <li>Java.math가 추가된 자바 1.1때: C로 작성한 고성능 라이브러리에 의존</li>
          <li>Java 3: 순수 자바로 다시 구현되면서 원래의 네이티브 구현보다 더 빨라짐</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>네이티브 라이브러리는 GNU 다중 정밀 연산 라이브러리(GMP)를 필두로 개선작업이 계속돼왔다.
    <ul>
      <li>그러므로 고성능의 다중 정밀 연산이 필요하다면 네이티브 메서드를 통해 GMP를 사용하는 것을 고려해보자.</li>
    </ul>
  </li>
</ul>

<h3 id="단점">단점</h3>
<ul>
  <li>네이티브 언어가 안전하지 않으므로(item 50) 네이티브 메서드를 사용하는 다른 애플리케이션도 메모리 훼손 오류로 부터 불안전하다.</li>
  <li>네이티브 언어는 자바보다 플랫폼을 많이 타 이식성이 낮다.</li>
  <li>디버깅이 어렵다</li>
  <li>주의하지 않으면 오히려 속도가 더 느려진다</li>
  <li>네이티브 메모리는 가비지 컬렉터가 자동 회수하지 못하며, 추적도 불가능하다(ITEM 8)</li>
  <li>자바 코드와 네이티브 코드의 경계를 넘나들 때 비용이 발생한다.</li>
  <li>네이티브 코드와 자바 코드 사이 접착코드(glue code)를 작성해야하나, 귀찮고 가독성도 떨어진다.</li>
</ul>

<h3 id="정리">정리</h3>
<ul>
  <li>네이티브 메서드를 사용하려거든 한번 더 생각해라</li>
  <li>네이티브 메서드가 성능을 개선해주는 일은 많지 않다.</li>
  <li>저수준 자원이나 네이티브 라이브러리를 사용해야만 해서 어쩔 수 없다면, 최소한만 사용하고 철저하게 테스트해라</li>
  <li>네이티브 코드 안에 숨은 하나의 버그가 어플리케이션 전체에 영향을 줄 수도 있다.</li>
</ul>

<h3 id="참고">참고</h3>
<ul>
  <li>네이티브 메서드를 작성하여 dll 파일에 접근하는 예
    <ul>
      <li><a href="https://www.geeksforgeeks.org/native-keyword-java/">Native Keyword in Java</a></li>
    </ul>
  </li>
  <li>네이티브 메서드를 가져다 쓰는 예
    <ul>
      <li><a href="https://blog.silentsoft.org/archives/5">Java에서 관리자 권한으로 실행하기</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="java" /><category term="java" /><summary type="html"><![CDATA[Java Native Interface(자바 네이티브 인터페이스, JNI): 자바 프로그램이 네이티브 메서드를 호출하는 기술]]></summary></entry><entry><title type="html">[CS] FTP(File Transfer Protocol) Active와 Passive의 차이</title><link href="http://localhost:4000/cs/2022-02-25-File-transfer-protocol/" rel="alternate" type="text/html" title="[CS] FTP(File Transfer Protocol) Active와 Passive의 차이" /><published>2022-02-25T00:00:00+09:00</published><updated>2022-04-22T21:38:17+09:00</updated><id>http://localhost:4000/cs/File-transfer-protocol</id><content type="html" xml:base="http://localhost:4000/cs/2022-02-25-File-transfer-protocol/"><![CDATA[<p>오늘은 FTP Active와 Passive의 차이에 대해서 정리해보려 한다.</p>

<h2 id="ftpfile-transfer-protocol란">FTP(File Transfer Protocol)란?</h2>
<ul>
  <li>File Transfer Protocol의 약자로 파일을 전송하는 통신 규약
    <ul>
      <li>FTP 서버에 파일들을 업로드, 다운로드 할 수 있도록 해주는 프로콜</li>
      <li>FTP 서버와 FTP 클라이언트 간의 통신에서 이루어짐</li>
    </ul>
  </li>
  <li>FTP는 Actvie, Passive 2개의 모드가 존재
    <ul>
      <li>각각의 모드에서는 2개 또는 2개 이상의 포트가 연결을 맺고 데이터를 전송하는데 사용됨</li>
      <li>기본 동작모드로 Active 모드를 사용</li>
      <li>사용되는 포트의 종류는 2개가 있음
        <ul>
          <li>Command(명령) 포트: 연결 제어하는 역할, 접속 시에 사용됨 ex) 21 port</li>
          <li>Data 포트: 데이터를 전송하는 역할 ex) Active:20 port, Passive:1024~65535 port</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>FTP는 TCP 기반으로 만들어져 있음</li>
  <li>ack(Acknoledement)
    <ul>
      <li>어떠한 컴퓨터가 네트워크를 통해 일련의 자료를 다른 컴퓨터로 성공적으로 전송했을 때, 전송을 받은 컴퓨터가 전송을 해 준 컴퓨터에게 보내는 신호.</li>
      <li>이는 수신측 컴퓨터가 “준비 완료”의 뜻을 알리는 신호이기도 함.</li>
      <li>긍정 응답 문자라고도 하며, 이와의 반대로는 부정 응답 문자(negative acknowledgement code, NACK)라고 부름</li>
    </ul>
  </li>
</ul>

<h2 id="active-모드">Active 모드</h2>
<ul>
  <li>아래 사용된 명령(Command)포트와 Data 포트는 <strong>서버의 설정에서 임의 수정하여 사용 가능</strong></li>
  <li>Acitve 모드는 클라이언트가 서버에 접속을 하는 것이 아닌 <strong>서버가 클라이언트에 접속하는 것</strong>
<img src="/assets\img/ftp_actvie.PNG" alt="ftp_actvie.PNG" />
    <h3 id="동작방식">동작방식</h3>
    <ol>
      <li>Client는 Server의 21번 포트로 접속 → <strong>자신이 사용할 두번째 포트(5151 port)를 서버에 미리</strong> 알려준다.</li>
      <li>서버는 클라이언트의 요청에 응답(acks)</li>
      <li>Server의 20번 Data Port는 Client가 알려준 두번째 포트(5151 Port)로의 접속을 시도</li>
      <li>Client가 Server의 요청에 응답(acks)</li>
    </ol>
  </li>
</ul>

<h3 id="주의사항">주의사항</h3>
<ul>
  <li>FTP Client에 방화벽이 설치되어 있어 외부에서의 접속을 허용하지 않는다면, FTP 접속이 정상적으로 이루어지지 않음. 접속이 되더라도 데이터 목록을 받아오지 못할 수 있음.
    <ul>
      <li>즉, Client 측의 방화벽에 20 port가 차단되어 있는 경우, 데이터 채널 연결 불가능</li>
    </ul>
  </li>
  <li>Server와 Client에 <strong>방화벽 설정 필요</strong>
    <ul>
      <li>Server: 20 Port에 대한 아웃바운드 허용(OutBound, 내 서버→외부서버로 보내는 요청)</li>
      <li>Client: 20 Port에 대한 인바운드 허용(InBound, 외부 서버→내서버로 들어오는 요청)</li>
    </ul>
  </li>
</ul>

<h2 id="passive-모드">Passive 모드</h2>
<ul>
  <li>Active 모드의 단점을 해결하기 위해 등장</li>
  <li>아래 사용된 명령(Command)포트와 Data 포트는 <strong>서버의 설정에서 임의 수정하여 사용 가능</strong>
    <ul>
      <li>Data Port 번호를 지정하지 않은 경우 1024~65535 Port 중에서 사용 가능한 임의의 포트를 사용함</li>
      <li>포트의 번호를 지정할 때는 10001 ~ 10005와 같이 범위 지정도 가능
<img src="/assets\img/ftp_passive.PNG" alt="ftp_passive.PNG" />
        <h3 id="동작방식-1">동작방식</h3>
        <ol>
          <li>Client가 Command Port(21)로 접속을 시도(Passvie Mode로 연결)</li>
          <li>Server에서는 <strong>사용할 두번째 포트(1234 Port)를 Client에게 알려줌</strong></li>
          <li>Client는 다른 Port(5151)를 열어 서버가 알려준 포트(1234)로 접속 시도</li>
          <li>Server가 Client의 요청에 응답(acks)</li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<p>Active Mode와의 차이점 - 데이터채널 연결 요청 시 Active Mode에서 사용했던 20번 port가 아닌 1024번 이후의 임의의포트를 데이터 채널 포트로 사용됨(여기서는 5151 Port로 사용)</p>

<h3 id="주의사항-1">주의사항</h3>
<ul>
  <li>Server측의 Data 채널 포트가 막혀있는 경우 데이터 채널 연결 불가
    <ul>
      <li>데이터 채널 포트의 범위는 지정할 수 있고, 별도로 지정하지 않은 경우 1024~65535번의 포트를 사용하게 됨</li>
    </ul>
  </li>
  <li>Server에 INBOUND 모두 허용하는 <strong>방화벽 설정 필요</strong>
    <ul>
      <li>Server 측에서 Data 채널 Port 범위를 지정하여 특정 범위의 Port만 허용해주면, 모든 포트를 허용해야하는 문제를 어느정도 해결할 수 있음</li>
    </ul>
  </li>
</ul>

<h3 id="참고">참고</h3>
<ul>
  <li><a href="https://ko.wikipedia.org/wiki/%EC%9D%91%EB%8B%B5_%EB%AC%B8%EC%9E%90">응답 문자</a></li>
  <li><a href="https://milhouse93.tistory.com/168">[IT 기초 지식] FTP(File Transfer Protocol) 정리</a></li>
  <li><a href="https://madplay.github.io/post/ftp-active-passive">FTP Active와 Passive 차이</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="cs" /><category term="cs" /><summary type="html"><![CDATA[오늘은 FTP Active와 Passive의 차이에 대해서 정리해보려 한다.]]></summary></entry></feed>