<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://icechoco.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://icechoco.github.io/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2022-06-10T16:10:52+09:00</updated><id>https://icechoco.github.io/feed.xml</id><title type="html">IceChoco</title><subtitle>Hydejack is a boutique Jekyll theme for hackers, nerds, and academics, with a focus on personal sites that are meant to impress.
</subtitle><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><entry><title type="html">[Spring] Spring Security란?</title><link href="https://icechoco.github.io/java,/spring/2022-05-25-spring-security/" rel="alternate" type="text/html" title="[Spring] Spring Security란?" /><published>2022-05-25T00:00:00+09:00</published><updated>2022-06-10T14:04:26+09:00</updated><id>https://icechoco.github.io/java,/spring/spring-security</id><content type="html" xml:base="https://icechoco.github.io/java,/spring/2022-05-25-spring-security/"><![CDATA[<p><strong>이 글을 쓰는 이유</strong></p>

<blockquote>
  <p>Spring Security는 복잡하고 방대한 내용을 알아야 한다. OAuth2를 활용한 로그인을 구현하다 보니 Spring Security에 대한 기본기를 다지고 가야겠다 생각되어 이 글을 쓰게 되었다.</p>

  <p>참고로, 구글링 중 너무 글로 잘 정리해주신 <a href="https://dingue.tistory.com/5">딩규님의 글</a>을 찾아서 이 글을 기반으로 추가로 공부한 내용을 더해 작성하였다. 좋은 글을 정리해주신 딩규님에게 감사 말씀을 드린다.</p>
</blockquote>

<hr />

<p>우선 Spring Secuiry가 무엇인가?</p>
<ul>
  <li><strong>강력하면서 높은 수준의 커스터마이징 가능한 인증을 제공하고, 필터를 통한 접근 제어를 허용하는 프레임 워크</strong></li>
  <li>Spring 기반 애플리케이션의 보안에서는 표준</li>
</ul>

<p>현재 가장 최신 버전은 5.7.1이나 이 글을 5.1.4 버전을 기반으로 작성해보았다.</p>

<h2 id="filter">Filter</h2>
<p><img src="/assets\img/spring/spring_security_filter.png" alt="" /></p>
<ul>
  <li>spring security에서는 애플리케이션에 대한 모든 요청을 필터로 감싼뒤 처리</li>
  <li>Filter들은 chain 형식이며, 각각의 순서를 갖고 있음</li>
  <li>필터 체인의 제일 마지막에 위치한 FilterSecurityInterceptor는 앞에 지나온 모든 필터들의 정보를 토대로 최종 결정</li>
  <li>자동 설정 시 10개의 필터가 적용됨</li>
</ul>

<h2 id="authentication인증-authorization권한">Authentication(인증), Authorization(권한)</h2>
<ul>
  <li>Authentication: 애플리케이션에서 사용자가 이 애플리케이션을 사용할 자격이 있는지 확인하는 과정
    <ul>
      <li>인증을 성공적으로 마치면 사용자에게 설정된 권한을 할당</li>
      <li>ex) 로그인</li>
    </ul>
  </li>
  <li>Authorization: 접근하는 사용자가 해당 로직 및 url에 접근할 권한을 가지고 있는지 확인하는 과정(접근제어 및 권한 관리)
    <ul>
      <li>웹 요청, url, 도메인 인스턴스에 대한 접근을 관리</li>
      <li>만약 접근한 사용자가 권한이 없거나 낮으면(ex 관리자 요청인데 일반 유저가 요청한 경우) 요청을 거부함</li>
    </ul>
  </li>
</ul>

<p>즉, Spring Security는 <strong>Filter로 이루어진 시스템</strong>이고, Filter를 이용한 Authentication, Authorization으로 유저 관리 및 접근 제어를 수행하는 보안 프레임워크이다.</p>

<h2 id="authentication인증">Authentication(인증)</h2>
<h3 id="1-인증-관련-핵심-용어">1. 인증 관련 핵심 용어</h3>
<ul>
  <li>Principal: 서비스에 접근하는 유저를 가리킴(일반적으로 username, userId로 생각해도 무방함)</li>
  <li>Authentication 객체
    <ul>
      <li>Spring Security에서 한 유저의 인증 정보를 가지고 있는 객체</li>
      <li>사용자가 인증 과정을 성공적으로 마치면, Spring security는 사용자의 정보 및 인증 성공여부를 가지고 Authentication 객체를 생성한 후 보관함</li>
    </ul>
  </li>
  <li>SecurityContextHolder: Authentication 객체를 보관하는 곳. 애플리케이션 어디에서든지 접근할 수 있음
    <ul>
      <li>ex) Obeject principal = SecurityContextHolder.getContext().getAuthentication().getPrinciPal();</li>
    </ul>
  </li>
  <li>UserDetails: 일반 서비스의 사용자 객체를 Spring security에서 사용하는 사용자 객체와 호환해주는 어댑터</li>
  <li>UserDetailsService: spring security에서 로그인할 때 전달된 정보를 기반으로 DB에서 유저를 가져오는 책임을 가지는 인터페이스</li>
  <li>GrantedAuthority: 사용자에게 주어진 애플리케이션 사용 권한 객체</li>
  <li>PasswordEncoder
    <ul>
      <li>DB에 사용자의 정보 저장 시 비밀번호를 암호화</li>
      <li>인증 시 입력된 비밀번호와 저장된 비밀번호를 matching 해주는 객체</li>
    </ul>
  </li>
</ul>

<h3 id="2-인증-과정">2. 인증 과정</h3>
<p>아이디 비밀번호를 입력하는 폼 기반 로그인이라고 가정했을 떄 아래와 같은 과정을 거친다.
1) 유저가 입력한 아이디, 비밀번호를 Spring Security가 사용하는 유저의 객체로 변환시킴(UserDetails 이용)
2) 유저가 입력한 정보(예: id)를 기반으로 DB에서 사용자 정보를 가져옴(UserDtailsService 인터페이스가 하는 역할)
3) 유저가 입력한 정보와 DB에서 가져온 사용자 정보를 기반으로 인증 진행 (아래에서 설명할 AuthenticationManager 인터페이스의 authenticate() 메소드)
4) 만약에 인증에 성공했다면 유저에게 설정된 권한을 부여</p>

<h3 id="3-인증-관련-세부-내용">3. 인증 관련 세부 내용</h3>
<h4 id="authenticationmanager">AuthenticationManager</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AuthenticationManager</span> <span class="o">{</span>
    <span class="nc">Authentication</span> <span class="nf">authenticate</span><span class="o">(</span><span class="nc">Authentication</span> <span class="n">authentication</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">AuthenticationException</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">authenticate</code> 메소드를 하나 가지고 있는 인터페이스</li>
  <li>이 메소드는 Spring security에서 인증을 담당</li>
</ul>

<h4 id="providermanager">ProviderManager</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProviderManager</span> <span class="kd">implements</span> <span class="nc">AuthenticationManager</span><span class="o">,</span> <span class="nc">MessageSourceAware</span><span class="o">,</span> <span class="nc">InitializingBean</span> <span class="o">{</span>
    <span class="c1">//....</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>Spring Security에서 AuthenticationManager의 기본 구현체</li>
  <li>이 클래스는 자신이 가지고 있는 여러 AuthenticationProvider 들에게 인증 처리를 위임함</li>
</ul>

<h4 id="authenticationprovider">AuthenticationProvider</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProviderManager</span> <span class="kd">implements</span> <span class="nc">AuthenticationManager</span><span class="o">,</span> <span class="nc">MessageSourceAware</span><span class="o">,</span> <span class="nc">InitializingBean</span> <span class="o">{</span>
  <span class="c1">//...</span>
    <span class="kd">public</span> <span class="nf">ProviderManager</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">AuthenticationProvider</span><span class="o">&gt;</span> <span class="n">providers</span><span class="o">,</span> <span class="nc">AuthenticationManager</span> <span class="n">parent</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">eventPublisher</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ProviderManager</span><span class="o">.</span><span class="na">NullEventPublisher</span><span class="o">();</span>
      <span class="k">this</span><span class="o">.</span><span class="na">providers</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">emptyList</span><span class="o">();</span>
      <span class="k">this</span><span class="o">.</span><span class="na">messages</span> <span class="o">=</span> <span class="nc">SpringSecurityMessageSource</span><span class="o">.</span><span class="na">getAccessor</span><span class="o">();</span>
      <span class="k">this</span><span class="o">.</span><span class="na">eraseCredentialsAfterAuthentication</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
      <span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">providers</span><span class="o">,</span> <span class="s">"providers list cannot be null"</span><span class="o">);</span>
      <span class="k">this</span><span class="o">.</span><span class="na">providers</span> <span class="o">=</span> <span class="n">providers</span><span class="o">;</span>
      <span class="k">this</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">;</span>
      <span class="k">this</span><span class="o">.</span><span class="na">checkState</span><span class="o">();</span>
    <span class="o">}</span>
<span class="c1">//...</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>실질적으로 인증을 처리하는 클래스 (authentication 메소드를 구현한 클래스)</li>
  <li>UserDetails와 UserDetailsService 그리고 PasswordEncoder를 이용해서 인증을 처리</li>
  <li>ProviderManager는 여러개의 AuthenticationProvider를 가질 수 있음</li>
  <li>여러개의 AuthenticationProvider를 가지고 있는 경우 각 순서대로 인증을 진행하거나, skip함</li>
  <li>만약 모든 AuthenticationProvider가 null을 반환(인증을 skip 하는 것)</li>
  <li>Spring Security에서 구현한 여러 AuthenticationProvider 구현체들이 있음
    <ul>
      <li>DaoAuthenticationProvider, LdapAuthenticationProvider: from 기반 로그인이나, HTTP Bagic authentication 인증을 구현한 구현체</li>
    </ul>
  </li>
</ul>

<h4 id="daoauthenticationprovider">DaoAuthenticationProvider</h4>
<ul>
  <li>유저가 입력한 username, password를 DB에서 가져온 유저정보와 비교하여 인증을 처리하는 구현체</li>
  <li>password를 비교하기 위해서 PasswordEncoder를 설정해주어야 함</li>
  <li>DB에서 유저 정보를 가져오기 위해서 UserDetailsService를 설정해 주어야 함</li>
</ul>

<h4 id="userdetailsservice">UserDetailsService</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserDetailsService</span> <span class="o">{</span>
	<span class="nc">UserDetails</span> <span class="nf">loadUserByUsername</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">UsernameNotFoundException</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>사용자가 입력한 username을 기반으로 저장된 유저정보를 가져와서 UserDetails 객체로 변환하여 돌려주는 메소드</li>
  <li><code class="language-plaintext highlighter-rouge">loadUserByUsername</code> 메소드를 하나 가지고 있는 인터페이스</li>
  <li>Spring Security에서 관련 구현체로 In-Memory Authentication, JdbcDaoImpl이 있음</li>
</ul>

<h5 id="in-memory-authentication">In-Memory Authentication</h5>
<p>Example. <user-service> {noop} XML Configuration</user-service></p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;user-service&gt;</span>
	<span class="nt">&lt;user</span> <span class="na">name=</span><span class="s">"user"</span>
		<span class="na">password=</span><span class="s">"{noop}password"</span>
		<span class="na">authorities=</span><span class="s">"ROLE_USER"</span> <span class="nt">/&gt;</span>
	<span class="nt">&lt;user</span> <span class="na">name=</span><span class="s">"admin"</span>
		<span class="na">password=</span><span class="s">"{noop}password"</span>
		<span class="na">authorities=</span><span class="s">"ROLE_USER,ROLE_ADMIN"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/user-service&gt;</span>
</code></pre></div></div>
<ul>
  <li>애플리케이션 메모리 안에 유저 정보를 저장해두고, 인증 요청이 왔을 때 이 정보들 중에서 입력된 정보와 일치하는 유저를 반환해주는 구현체</li>
  <li>프로토타입용으로만 사용하는 것이 좋음(절대 실무에서는 사용하면 안됨)</li>
</ul>

<h5 id="jdbcdaoimpl">JdbcDaoImpl</h5>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JdbcDaoImpl</span> <span class="kd">extends</span> <span class="nc">JdbcDaoSupport</span> <span class="kd">implements</span> <span class="nc">UserDetailsService</span><span class="o">,</span> <span class="nc">MessageSourceAware</span> <span class="o">{</span>
    <span class="c1">//...</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>ORM을 사용하고 있지 않다면, 이 구현체를 사용해서 DB에서 쉽게 입력된 사용자 정보를 가져올 수 있음</li>
  <li>하지만 ORM을 사용하고 있다면 굳이 이런 구현체를 사용하는 것보다, 직접 UserDetailsService 인터페이스를 구현하여 사용하느 ㄴ것이 좋음</li>
</ul>

<h4 id="userdetails">UserDetails</h4>
<ul>
  <li>Spring Security에서는 사용자 객체가 필요하지만, 모든 서비스마다 사용자 정의가 다르기 때문에 서비스와 Spring security의 사용자 객체를 호환해주는 어댑터가 필요</li>
  <li>그 어댑터의 역할을 UserDetails가 수행</li>
  <li>Spring security를 사용하는 애플리케이션에서는 이 인터페이스를 구현해야함</li>
</ul>

<h4 id="passwordencoder">PasswordEncoder</h4>
<p>패스워드 암호화의 발전 과정</p>
<ol>
  <li>초기에 password는 암호화 되지 않음
    <ul>
      <li>DB 인증을 통해서 데이터를 접근하는데 다시 password를 암호화 할 필요성을 느끼지 못함</li>
    </ul>
  </li>
  <li>SQL Injection 같은 공격을 통해 password가 털림. password 암호화의 필요성을 느낌</li>
  <li>개발자들은 SHA-256과 같은 한방향 hash 암호화를 이용하여 password 암호화를 시작</li>
  <li>공격자들은 rainbowTable이라는 것을 생성하여 한방향 hash 암호화를 무력화시킴</li>
  <li>이에 개발자들은 랜덤 바이트를 비밀번호에 섞어서 ranbowTable을 무력화 시킴</li>
  <li>현대 HW가 좋아지고, 해쉬함수가 빠르다는 것을 공격자들이 이용(1초에 10억건씩 비밀번호를 체크)</li>
  <li>이에 개발자들은 해시 암호화 알고리즘이 내부 리소스들을 엄청나게 사용하도록 변경(암호화가 1초 이상 걸리도록 설정)
    <ul>
      <li>이게 바로 로그인이 오래걸리는 이유</li>
    </ul>
  </li>
</ol>

<p>Spring Security에서는 work factor 조정을 통해 암호화 알고리즘의 속도를 설정할 수 있다.<br />
이런 work factor를 사용하는 암호화 알고리즘은 bcrypt, PBKDF2, scrypt, 그리고 Argon2가 있다.</p>

<h4 id="delegatingpasswordencoder">DelegatingPasswordEncoder</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nc">String</span> <span class="n">idForEncode</span> <span class="o">=</span> <span class="s">"bcrypt"</span><span class="o">;</span>
 <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">PasswordEncoder</span><span class="o">&gt;</span> <span class="n">encoders</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
 <span class="n">encoders</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">idForEncode</span><span class="o">,</span> <span class="k">new</span> <span class="nc">BCryptPasswordEncoder</span><span class="o">());</span>
 <span class="n">encoders</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"noop"</span><span class="o">,</span> <span class="nc">NoOpPasswordEncoder</span><span class="o">.</span><span class="na">getInstance</span><span class="o">());</span>
 <span class="n">encoders</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"pbkdf2"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Pbkdf2PasswordEncoder</span><span class="o">());</span>
 <span class="n">encoders</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"scrypt"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">SCryptPasswordEncoder</span><span class="o">());</span>
 <span class="n">encoders</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"sha256"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">StandardPasswordEncoder</span><span class="o">());</span>

 <span class="nc">PasswordEncoder</span> <span class="n">passwordEncoder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DelegatingPasswordEncoder</span><span class="o">(</span><span class="n">idForEncode</span><span class="o">,</span> <span class="n">encoders</span><span class="o">);</span>
</code></pre></div></div>
<p>Spring Security 5.0 이전에는 암호화를 하지 않고 default PasswordEncoder가 평문 패스워드였다.<br />
Spring Security에서는 하위 호환성을 위하여 그동안 이를 업그레이드하지 않다가 <code class="language-plaintext highlighter-rouge">DelegatingPasswordEncoder</code>라는 구현체를 개발하였다.</p>
<ul>
  <li>이전의 포맷이나, 현재 포맷을 같이 사용할 수 있다.</li>
  <li>미래에 쉽게 passwordEncoding 방식을 업그레이드 할 수 있다.</li>
</ul>

<h4 id="spring-security-저장-포맷">Spring security 저장 포맷</h4>
<p>일반적으로 저장 포맷은 아래와 같다</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{id}encodePassword
</code></pre></div></div>
<p>여기서 id는 어떤 passwordEncoder가 사용되었는지 볼 수 있는 식별자이고, encodedPassword는 선택된 PasswordEncoder가 원래 passwrod를 인코딩한 것이다.<br />
id는 password 시작에 있어야 하며 {로 시작해서 }로 끝난다. id를 찾을 수 없으면 id는 null이 된다.<br />
아래는 <code class="language-plaintext highlighter-rouge">password</code>라는 String을 passwordEncoder로 인코딩한 예이다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> {bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG
 {noop}password
 {pbkdf2}5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc
 {scrypt}$e0801$8bWJaSu2IKSn9Z9kM+TPXfOc/9bdYSrN1oD9qfVThWEwdRTnO7re7Ei+fUZRJ68k9lTyuTeUp4of4g24hHnazw==$OAOec05+bXxvuu/1qZ6NUR+xQYvYv7BeL1QxwRpY5Pc=
 {sha256}97cde38028ad898ebc02e690819fa220e88c62e0699403e94fff291cfffaf8410849f27605abcbc0
</code></pre></div></div>

<p>이런 식으로 변했기 때문에 기존에 password에 id가 달려있지 않았다면 아래와 같이 업그레이드 시켜주어야 한다.
아래는 bycrypt 암호화 알고리즘을 사용한 예시이다</p>
<ul>
  <li>기존
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG
</code></pre></div>    </div>
  </li>
  <li>변경
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="4-인증-아키텍처">4. 인증 아키텍처</h3>
<p><img src="/assets\img/spring/spring_security_autehntication.png" alt="" /></p>

<h2 id="spring-security-자바-설정">Spring Security 자바 설정</h2>
<h3 id="1-springsecurityfilterchain-생성">1. SpringSecurityFilterChain 생성</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableWebSecurity</span> <span class="c1">//Spring Security 설정 활성화</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringSecurityConfig</span> <span class="kd">extends</span> <span class="nc">WebSecurityConfigurerAdapter</span> <span class="o">{</span>

  <span class="nd">@Autowired</span>
  <span class="kd">private</span> <span class="nc">UserDetailsService</span> <span class="n">jwtUserDetailsService</span><span class="o">;</span>

  <span class="nd">@Autowired</span>
  <span class="kd">private</span> <span class="nc">PasswordEncoder</span> <span class="n">passwordEncoder</span><span class="o">;</span>

  <span class="nd">@Autowired</span>
  <span class="kd">private</span> <span class="nc">JwtRequestFilter</span> <span class="n">jwtRequestFilter</span><span class="o">;</span>

  <span class="c1">//...</span>
<span class="o">}</span>    
</code></pre></div></div>

<p>위 소스를 보면 클래스 위에 <code class="language-plaintext highlighter-rouge">@EnableWebSecurity</code>라는 어노테이션이 달려있는 것을 볼 수 있다. 이 어노테이션을 사용하면 SpringSecurityFilterChain이 자동으로 생성 된다.</p>

<h4 id="1-1-springsecurityfilterchain의-효과">1-1. SpringSecurityFilterChain의 효과</h4>
<ul>
  <li>애플리케이션의 모든 URL에 인증을 적용할 수 있다.</li>
  <li>기본 로그인 폼을 제공한다.</li>
  <li>폼 기반 인증을 통해 username과 password 인증을 할 수 있게 해준다.</li>
  <li>유저에게 로그아웃 기능을 제공한다.</li>
  <li>CSRF 공격을 방어해준다.</li>
  <li>세션 고정 공격을 방어해준다.</li>
  <li>통합 Security Header를 제공한다.
    <ul>
      <li>보안 요청을 위한 HTTP Strict Transport Security 제공</li>
      <li>통합 X-Context-Type-Options 제공</li>
      <li>통합 X-XSS-Protection 제공</li>
      <li>Clickjacking 방어를 도와주는 통합 X-Frame-Options 제공</li>
    </ul>
  </li>
</ul>

<h3 id="2-spring-mvc에서-abstractsecuritywebapplicationinitializer를-통한-spring-security-등록">2. Spring MVC에서 AbstractSecurityWebApplicationInitializer를 통한 Spring Security 등록</h3>
<blockquote>
  <p>jar의 경우 스프링부트에서 자동 구성을 해주기 때문에 위 설정이 따로 필요 없다. 그 이유가 궁금하다면 아래 2-4를 참조하길 바란다.<br />
war로 생성하려는 경우에는 아래와 같이 직접 구현을 해주어야 한다.</p>
</blockquote>

<h4 id="2-1-abstractsecuritywebapplicationinitializer-without-spring">2-1. AbstractSecurityWebApplicationInitializer without Spring</h4>
<p>스프링이나 스프링 MVC를 사용하고 있지 않다면, <code class="language-plaintext highlighter-rouge">WebSecurityConfig</code>를 사용할 수 있도록 이 클래스를 상위로 넘겨야 한다. 예시는 아래에 있다:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.springframework.security.web.context.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecurityWebApplicationInitializer</span>
    <span class="kd">extends</span> <span class="nc">AbstractSecurityWebApplicationInitializer</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nf">SecurityWebApplicationInitializer</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="nc">WebSecurityConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">AbstractSecurityWebApplicationInitializer</code>는 다음과 같은 일을 한다.</p>
<ul>
  <li>어플리케이션의 모든 URL에 자동으로 springSecurityFilterChain 필터를 등록한다.</li>
  <li><code class="language-plaintext highlighter-rouge">WebSecurityConfig</code>를 로드하는 ContexLoaderListner를 추가한다.</li>
</ul>

<h4 id="2-2-abstractsecuritywebapplicationinitializer-with-spring-mvc">2-2. AbstractSecurityWebApplicationInitializer with Spring MVC</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.springframework.security.web.context.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecurityWebApplicationInitializer</span>
        <span class="kd">extends</span> <span class="nc">AbstractSecurityWebApplicationInitializer</span> <span class="o">{</span>

<span class="o">}</span>
</code></pre></div></div>

<p>이 이후에 WebSecurityConfig가 ApplicationInitializer로 로드되도록 설정해야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MvcWebApplicationInitializer</span> <span class="kd">extends</span>
        <span class="nc">AbstractAnnotationConfigDispatcherServletInitializer</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">getRootConfigClasses</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Class</span><span class="o">[]</span> <span class="o">{</span> <span class="nc">WebSecurityConfig</span><span class="o">.</span><span class="na">class</span> <span class="o">};</span>
    <span class="o">}</span>

    <span class="c1">// ... other overrides ...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이렇게 하면 기존 ApplicationInitializer에 <code class="language-plaintext highlighter-rouge">WebSecurityConfig</code>를 로드한다.
예를 들어 스프링 MVC를 사용하고 있다면 <code class="language-plaintext highlighter-rouge">getRootConfigClasses()</code>안에 추가된다.</p>

<hr />

<p>그런데 내가 개발중인 프로젝트는 AbstractSecurityWebApplicationInitializer를 직접 구현한 적이 없는데 스프링 세큐리티를 적용하여 사용중이다.<br />
엥 그럼 필수가 아니란 말인가? AbstractSecurityWebApplicationInitializer를 구현하지 않았을 때는 어떻게 동작할까?<br />
그 궁금증을 해결하기 위해 아래 2가지의 스택오버플로우 글을 읽어 보았다.</p>

<h4 id="2-3-abstractsecuritywebapplicationinitializer-vs-abstractannotationconfigdispatcherservletinitializer">2-3 AbstractSecurityWebApplicationInitializer vs. AbstractAnnotationConfigDispatcherServletInitializer</h4>
<details>
<summary>[질문 상세 내용]</summary>
<div>

    <p>3.2.8 버전의 순수 자바 어플리케이션에 세큐리티를 적용하려한다. 나는 <a href="http://docs.spring.io/spring-security/site/docs/3.2.2.RELEASE/reference/htmlsingle/#jc">스프링 세큐리티 docs</a>를 참조하고 있다.</p>

    <p>3.1 섹션을 완료했다. 그리고 문서에서는 모든 url에 authentication(인증)이 필요하지만, 세큐리티 적용안하면 모든 URL을 로드할 수 있다.<br />
문서에서는 서블릿 필터 등을 생성한다고 한다.</p>

    <p>WebSecurityConfigurerAdapter 하위 클래스만으로는 충분하지 않다. 그래서 <strong>WAR 사용 시</strong> springSecurityFilterChain을 등록에 관한 3.1.1 섹션을 보았다.<br />
이 섹션에서는 Servlet 3+ 환경에서 어떻게 사용해야하는지 설명한다. 난 <code class="language-plaintext highlighter-rouge">AbstractSecurityWebApplication</code>를 구현한 하위 클래스가 필요하다.<br />
하지만 난 이미 <code class="language-plaintext highlighter-rouge">AbstractAnnotationConfigDispatcherServletInitializer</code>에 대한 하위 클래스를 구현했다.<br />
나는 각각 하나씩 하위클래스를 갖고 있어야 할까? AbstractSecurityWebApplicationInitializer JavaDoc에 순서 지정에 대한 몇가지 논의가 있다.<br />
여기서는 내가 한 개 이상의 initializer 클래스를 갖고 있어야 함을 의미한다.</p>
  </div>
</details>

<p><strong>[정리]</strong></p>

<p>AbstractAnnotationConfigDispatcherServletInitializer에 대한 하위클래스를 이미 구현해놓은 상태인데 스프링 세큐리티 적용하려고 보니까 AbstractSecurityWebApplicationInitializer 얘도 하위클래스 확장하라고 하는데 나는 각각 둘다 확장해야되냐?는 질문이며,
답변은 맞다 AbstractSecurityWebApplicationInitializer 이것도 확장해야한다 라는 내용이다.</p>

<p>내가 궁금했던 케이스랑은 다르긴 한데 위 글의 질문자가 올린 코멘트를 통해서 docs는 <strong>War로 생성한다는 가정하에</strong> AbstractSecurityWebApplicationInitializer를 직접 구현하라고 되어있는 것을 알게 되었다.
자 그럼 다음 글을 읽어보자.</p>

<h4 id="2-4-websecurityconfigureradapter-and-abstractsecuritywebapplicationinitializer-absent">2-4. WebSecurityConfigurerAdapter and AbstractSecurityWebApplicationInitializer absent</h4>
<details>
<summary>[질문 상세 내용]</summary>
<div>

    <p>내가 본 대부분의 예시는<br />
1) Configuration 설정을 위한 WebSecurityConfigurerAdapter<br />
2) 세큐리티 필터 초기화를 위한 AbstractSecurityWebApplicationInitializer</p>

    <p>직장 내 프로젝트에서 스프링 세큐리티를 쓰고있는데 위에서 언급된 클래스 중 어떤 것도 사용할 수 없었다.</p>

    <blockquote>
      <p>그럼 어떻게 내 프로젝트에서 스프링세큐리티를 초기화하고 구성할 수 있을까?</p>
    </blockquote>

    <p>이 프로젝트는 스프링부트를 사용하며 아래 클래스/인터페이스들을 상속/구현하고있다.<br />
a) AuthenticationProvider<br />
b) Authentication<br />
c) Filter</p>

  </div>
</details>

<p><strong>[정리]</strong><br />
jar를 이용한 스프링부트의 자동 구성에 의해 정의가 된다. 전체 workflow는:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">WebSecurityConfigurerAdapter</code> 빈을 등록하지 않았다면, <code class="language-plaintext highlighter-rouge">SpringBootWebSecurityConfiguration</code>이 자동으로 생성해준다.</li>
  <li><code class="language-plaintext highlighter-rouge">WebSecurityEnablerConfiguration</code>은 @EnableWebSecurity가 항상 존재하는지 확인한다.</li>
  <li>@EnableWebSecurity는 스프링 세큐리티 디폴트 구성정보인 WebSecurityConfiguration을 임포트한다. 이 구성정보는 springSecurityFilterChain을 bean을 정의하고 있다.</li>
  <li>SecurityFilterAutoConfiguration은 내장 서버에 springSecurityFilterChain을 등록해준다(FilterRegistrationBean 정의를 통해).<br />
이것은 AbstractSecurityWebApplicationInitializer가 동작하는 방식과 동일하지만 스프링부트 내장형 서버의 방식이다.</li>
</ol>

<p>단, war 이용시 위와 같은 자동 구성이 되지 않으니 <code class="language-plaintext highlighter-rouge">AbstractSecurityWebApplicationInitializer</code>를 직접 구현해야 한다.</p>

<h3 id="3-httpsecurity">3. HTTPSecurity</h3>
<p>WebSecurityConfigurerAdapter에서 configure(HttpSecurity http) 메소드를 제공한다.</p>

<p>이 메소드에서 URL 및 로그인 설정을 함으로써 Spring Security가 어떤 URL에 인증이 필요하고, 어떤 로그인 인증 과정을 사용하는지 알 수 있게 된다.</p>

<p>이 메소드를 통해서 자신만의 인증 메커니즘을 만들 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableWebSecurity</span> <span class="c1">//Spring Security 설정 활성화</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringSecurityConfig</span> <span class="kd">extends</span> <span class="nc">WebSecurityConfigurerAdapter</span> <span class="o">{</span>
    <span class="c1">//...</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">configure</span><span class="o">(</span><span class="nc">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">http</span><span class="o">.</span><span class="na">addFilterBefore</span><span class="o">(</span><span class="n">jwtRequestFilter</span><span class="o">,</span> <span class="nc">UsernamePasswordAuthenticationFilter</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
            <span class="o">.</span><span class="na">formLogin</span><span class="o">().</span><span class="na">disable</span><span class="o">()</span>
            <span class="o">.</span><span class="na">csrf</span><span class="o">().</span><span class="na">disable</span><span class="o">()</span> <span class="c1">//csrf 공격으로부터 안전하고 매번 api 요청으로부터 csrf 토큰을 받지 않아도 되므로 disable 처리함</span>
            <span class="o">.</span><span class="na">cors</span><span class="o">().</span><span class="na">configurationSource</span><span class="o">(</span><span class="n">source</span><span class="o">()).</span><span class="na">and</span><span class="o">()</span>
            <span class="o">.</span><span class="na">authorizeHttpRequests</span><span class="o">()</span> <span class="c1">//인가에 대한 설정</span>
            <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="s">"/api/oauth/**"</span><span class="o">).</span><span class="na">permitAll</span><span class="o">()</span>
            <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="s">"/api/token/**"</span><span class="o">).</span><span class="na">permitAll</span><span class="o">()</span>
            <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="s">"/h2-console/**"</span><span class="o">).</span><span class="na">permitAll</span><span class="o">()</span>
            <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="s">"/swagger-resources/**"</span><span class="o">).</span><span class="na">permitAll</span><span class="o">()</span> <span class="c1">// swagger 관련 리소스 시큐리티 필터 제거</span>
            <span class="o">.</span><span class="na">anyRequest</span><span class="o">().</span><span class="na">authenticated</span><span class="o">()</span>
    <span class="o">;</span>
  <span class="o">}</span>
  
  <span class="c1">//...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>antMatchers를 이용하여 URL을 매치하고, access 및 hasRole 메소드를 이용해 URL에 권한을 부여할 수 있다.</p>

<ul>
  <li>HTTPSecurity 메소드 일부</li>
</ul>

<table>
  <thead>
    <tr>
      <th>메소드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>annonymous()</td>
      <td>인증 없이 접근 가능한 URL을 정의한다.</td>
    </tr>
    <tr>
      <td>authenticated()</td>
      <td>인증된 사용자만 접근 가능한 URL을 정의한다.</td>
    </tr>
    <tr>
      <td>fullyAuthenticated()</td>
      <td>완전히 인증된 사용자만 접근할 수 있다.</td>
    </tr>
    <tr>
      <td>hasRole() or hasAnyRole()</td>
      <td>인증된 사용자가 주어진 역할을 가지고 있으면 접근 가능한 URL을 정의한다.</td>
    </tr>
    <tr>
      <td>hasAuthority() or hasAnyAuthority()</td>
      <td>특정 권한을 가지는 사용자만 접근할 수 있다.</td>
    </tr>
    <tr>
      <td>hasIpAddress()</td>
      <td>특정 아이피 주소를 가지는 사용자만 접근할 수 있다.</td>
    </tr>
    <tr>
      <td>access()</td>
      <td>SpEL 표현식에 의한 결과에 따라 접근할 수 있다.</td>
    </tr>
    <tr>
      <td>not()</td>
      <td>접근 제한 기능을 해제한다.</td>
    </tr>
    <tr>
      <td>permitAll() or denyAll()</td>
      <td>접근을 전부 허용하거나 제한한다.</td>
    </tr>
  </tbody>
</table>

<p>Role은 역할이고, Authority는 권한이이지만 표현의 차이일 뿐이다.<br />
Role은 “ADMIN”으로 표현하고 Authority는 “ROLE_ADMIN”으로 표현하는 것에 차이가 있다.</p>

<h3 id="4-authenticationmanagerbuilder">4. AuthenticationManagerBuilder</h3>

<p>WebSecurityConfigureAdapter에서 아래 예제의 메소드를 통해서 인증 객체를 설정할 수 있다.</p>
<ul>
  <li>Authentication을 사용한 예</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableWebSecurity</span> <span class="c1">//Spring Security 설정 활성화</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringSecurityConfig</span> <span class="kd">extends</span> <span class="nc">WebSecurityConfigurerAdapter</span> <span class="o">{</span>
  <span class="c1">//...</span>
  <span class="nd">@Autowired</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">configureGlobal</span><span class="o">(</span><span class="nc">AuthenticationManagerBuilder</span> <span class="n">auth</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="n">auth</span><span class="o">.</span><span class="na">userDetailsService</span><span class="o">(</span><span class="n">jwtUserDetailsService</span><span class="o">).</span><span class="na">passwordEncoder</span><span class="o">(</span><span class="n">passwordEncoder</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="c1">//...</span>
<span class="o">}</span>

<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserDetailsService</span> <span class="kd">implements</span> <span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">security</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">userdetails</span><span class="o">.</span><span class="na">UserDetailsService</span> <span class="o">{</span>

  <span class="nd">@Autowired</span>
  <span class="kd">private</span> <span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="nc">UserDetails</span> <span class="nf">loadUserByUsername</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">UsernameNotFoundException</span> <span class="o">{</span>
    <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="n">user</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="nc">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">username</span><span class="o">));</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">user</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">UsernameNotFoundException</span><span class="o">(</span><span class="s">"404 - User Not Found"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="k">new</span> <span class="n">yapp</span><span class="o">.</span><span class="na">bestFriend</span><span class="o">.</span><span class="na">service</span><span class="o">.</span><span class="na">user</span><span class="o">.</span><span class="na">UserDetails</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>
<hr />
<h3 id="참고">참고</h3>
<ul>
  <li><a href="https://dingue.tistory.com/5">Spring Security 개요 및 인증 과정</a></li>
  <li><a href="https://docs.spring.io/spring-security/reference/servlet/authentication/passwords/in-memory.html">In-Memory Authentication</a></li>
  <li><a href="https://stackoverflow.com/questions/22447603/abstractsecuritywebapplicationinitializer-vs-abstractannotationconfigdispatcher">AbstractSecurityWebApplicationInitializer vs. AbstractAnnotationConfigDispatcherServletInitializer</a></li>
  <li><a href="https://stackoverflow.com/questions/56064735/websecurityconfigureradapter-and-abstractsecuritywebapplicationinitializer-absen">WebSecurityConfigurerAdapter and AbstractSecurityWebApplicationInitializer absent</a></li>
  <li><a href="https://godekdls.github.io/Spring%20Security/javaconfiguration/#1613-abstractsecuritywebapplicationinitializer-with-spring-mvc">토리맘의 한글라이즈 프로젝트 - Spring Security Java Configuration</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="java," /><category term="spring" /><category term="java" /><summary type="html"><![CDATA[이 글을 쓰는 이유]]></summary></entry><entry><title type="html">[CS] 기술면접 예상 질문 - Spring</title><link href="https://icechoco.github.io/cs/2022-05-24-Technical-Interview-Expected-Questions-spring/" rel="alternate" type="text/html" title="[CS] 기술면접 예상 질문 - Spring" /><published>2022-05-24T00:00:00+09:00</published><updated>2022-05-24T13:54:41+09:00</updated><id>https://icechoco.github.io/cs/Technical-Interview-Expected-Questions-spring</id><content type="html" xml:base="https://icechoco.github.io/cs/2022-05-24-Technical-Interview-Expected-Questions-spring/"><![CDATA[<p>기술면접 단골질문</p>

<h3 id="1-spring-diioc는-어떻게-동작하나요">1. Spring DI/IoC는 어떻게 동작하나요?</h3>

<h2 id="참고">참고</h2>
<ul>
  <li><a href="https://github.dev/ksundong/backend-interview-question">백엔드 개발자로 입사를 준비하며 받았던 질문, 예상했던 질문, 인터넷 참고한 질문(CC BY-NC)</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="cs" /><category term="cs" /><summary type="html"><![CDATA[기술면접 단골질문]]></summary></entry><entry><title type="html">[MSA] Netflix 스택 &amp;amp; K8s 스택</title><link href="https://icechoco.github.io/server/2022-05-24-MSA/" rel="alternate" type="text/html" title="[MSA] Netflix 스택 &amp;amp; K8s 스택" /><published>2022-05-24T00:00:00+09:00</published><updated>2022-05-24T11:58:17+09:00</updated><id>https://icechoco.github.io/server/MSA</id><content type="html" xml:base="https://icechoco.github.io/server/2022-05-24-MSA/"><![CDATA[<p>Netfilix OSS 그리고 Spring Cloud 기반으로 구현해 왔던 방식이 쿠버네티스에서는 아래와 같이 맵핑된다.</p>

<table>
  <thead>
    <tr>
      <th>Component</th>
      <th>Description</th>
      <th>Spring Cloud &amp; Netflix OSS</th>
      <th>Kubernetes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>API Gateway</td>
      <td>API 호출을 관장</td>
      <td>Zuul</td>
      <td>Istio, Kong 등</td>
    </tr>
    <tr>
      <td>Discovery Service</td>
      <td>내부 DNS 서비스</td>
      <td>Eureka</td>
      <td>Service</td>
    </tr>
    <tr>
      <td>Circuit Breaker</td>
      <td>장애 전파 방지</td>
      <td>Hystrix</td>
      <td>Health Check 또는 Service Mesh</td>
    </tr>
    <tr>
      <td>Load Balancer</td>
      <td>부하 분산</td>
      <td>Ribbon</td>
      <td>Service</td>
    </tr>
    <tr>
      <td>Monitoring</td>
      <td>집계 및 모니터링</td>
      <td>Turbine, Hystrix Dashboard</td>
      <td>- EFK <br /> - Prometheus &amp; Granfana : k8s Node나 pod 정보를 자동으로 수집하여 애플리케이션 코드 수정이 필요하지 않음</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="server" /><category term="server" /><summary type="html"><![CDATA[Netfilix OSS 그리고 Spring Cloud 기반으로 구현해 왔던 방식이 쿠버네티스에서는 아래와 같이 맵핑된다.]]></summary></entry><entry><title type="html">[Server] 전세계에서 가장 유명한 캐싱 솔루션, Redis</title><link href="https://icechoco.github.io/server/2022-05-21-Redis/" rel="alternate" type="text/html" title="[Server] 전세계에서 가장 유명한 캐싱 솔루션, Redis" /><published>2022-05-21T00:00:00+09:00</published><updated>2022-06-10T15:38:48+09:00</updated><id>https://icechoco.github.io/server/Redis</id><content type="html" xml:base="https://icechoco.github.io/server/2022-05-21-Redis/"><![CDATA[<p>오늘은 전세계에서 가장 유명한 캐싱 솔루션인 Redis에 대해 알아보는 시간을 가지고자 한다.</p>

<h2 id="redis">Redis</h2>
<p>오픈소스 인 메모리 데이터 구조 저장소로서 in memory DB, 캐시, 메시지 브로커로 역할을 수행한다.<br />
전세계에서 가장 유명한 <strong>캐싱 솔루션</strong>이기도 하다.</p>
<ul>
  <li>support data structure
    <ul>
      <li>String, hash, list, sets, sorted sets(정렬이 되는 집합), bitmaps, streams 등을 지원한다.</li>
    </ul>
  </li>
  <li>cache의 정의
    <ul>
      <li>나중에 요청된 결과를 미리 저장해뒀다가 빠르게 쓰기 위한 임시 데이터 저장소</li>
      <li>캐시에 접근 하는 것이 원본에 접근 하는 것보다 빨라야 함</li>
      <li>데이터의 재사용 횟수가 한 번 이상이어야 캐쉬가 의미 있음</li>
    </ul>
  </li>
  <li>Redis의 경우는 자료구조가 Atomic하다.
    <ul>
      <li>Atomic Operatio이 필요한 부분은 멀티스레드 프로그램에서 공유 자원들에 대해 여러 스레드가 서로 동시에 액세스하는 상태(race condition)을 막기 위한 하나의 방법.</li>
      <li>쉽게 말해 동기화를 위한 하나의 방법임</li>
    </ul>
  </li>
  <li>Redis as a cache
    <ul>
      <li>단순한 key-value 구조</li>
    </ul>
  </li>
  <li><strong>캐싱 전략</strong></li>
</ul>
<p align="center"><img src="/assets\img/Server/Look-Aside(Lazy Loading).png" height="150px" width="450px" /></p>
<ul>
  <li>읽기전략 - <strong>lazy loading(Look-Aside)</strong>: Redis에 찾는 데이터가 없으면 DB에서 조회해 온 뒤 Redis에 저장해야 한다.</li>
</ul>

<h3 id="redis-사용처">Redis 사용처</h3>
<ul>
  <li>Remote Data Store
    <ul>
      <li>여러대의 서버에서 같은 데이터를 쓰고싶을 때 보통 사용함</li>
    </ul>
  </li>
  <li>인증 토큰을 저장 시 주로 많이 사용</li>
</ul>

<h2 id="참고">참고</h2>
<ul>
  <li>[[NHN FORWARD 2021] Redis 야무지게 사용하기https://www.youtube.com/watch?v=92NizoBL4uA)</li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="server" /><category term="server" /><summary type="html"><![CDATA[오늘은 전세계에서 가장 유명한 캐싱 솔루션인 Redis에 대해 알아보는 시간을 가지고자 한다.]]></summary></entry><entry><title type="html">[CS] 기술면접 예상 질문 - 클라우드</title><link href="https://icechoco.github.io/cs/2022-05-21-Technical-Interview-Expected-Questions-Cloud/" rel="alternate" type="text/html" title="[CS] 기술면접 예상 질문 - 클라우드" /><published>2022-05-21T00:00:00+09:00</published><updated>2022-05-24T11:37:59+09:00</updated><id>https://icechoco.github.io/cs/Technical-Interview-Expected-Questions-Cloud</id><content type="html" xml:base="https://icechoco.github.io/cs/2022-05-21-Technical-Interview-Expected-Questions-Cloud/"><![CDATA[<p>기술면접 대비 클라우드 관련 개념 정리</p>

<h3 id="1-cni">1. CNI</h3>
<p>CNI란 <strong>컨테이너 간의 네트워킹을 제어할 수 있는 플러그인을 만들기 위한 표준</strong>이다. 다양한 형태의 컨테이너 런타임과 오케스트레이터 사이의 네트워크 계층을 구현하는 방식이 다양하게 분리되어 각자만의 방식으로 발전하게 되는 것을 방지하고 공통된 인터페이스를 제공하기 만들어 졌다. 쿠버네티스에서는 Pod 간의 통신을 위해서 CNI 를 사용한다.</p>

<p>쿠버네티스 뿐만 아니라 Amazon ECS, Cloud Foundry 등 컨테이너 런타임을 포함하고 있는 다양한 플랫폼들은 CNI를 사용하고 있다. 쿠버네티스는 기본적으로 ‘kubenet’ 이라는 자체적인 CNI 플러그인을 제공하지만 네트워크 기능이 매우 제한적인 단점이 있다.</p>

<p>그 단점을 보완하기 위해, 3rd-party 플러그인을 사용하는데 그 종류에는 Flannel, Calico, Weavenet, NSX 등 다양한 종류의 3rd-party CNI 플러그인들이 존재한다.</p>

<h3 id="2-calico">2. Calico</h3>
<p>Calico란, <strong>컨테이너, 가상 머신 및 기본 호스트 기반 워크로드를 위한 오픈 소스 네트워킹 및 네트워크 보안 솔루션</strong>이다. Kubernetes, OpenShift, Mirantis Kubernetes Engine(MKE), OpenStack 및 베어메탈 서비스를 포함한 광범위한 플랫폼을 지원한다. Calico의 eBPF 데이터 플레인을 사용하든 Linux의 표준 네트워킹 파이프라인을 사용하든 Calico는 진정한 클라우드 네이티브 확장성과 함께 놀랍도록 빠른 성능을 제공한다.</p>

<p>Calico는 공용 클라우드나 온프레미스, 단일 노드 또는 수천 개의 노드 클러스터에서 실행되는지 여부에 관계없이 개발자와 클러스터 운영자에게 일관된 경험과 기능 세트를 제공한다.</p>

<h3 id="3service-mesh">3.Service Mesh</h3>
<p>MSA를 적용한 시스템의 내부 통신이 Mesh 네트워크의 형태를 띠는 것에 빗대어 Service Mesh로 명명되었다.
Service Mesh 는 서비스 간 통신을 추상화하여 안전하고, 빠르고, 신뢰할 수 있게 만드는 <strong>전용 InfraStructure Layer</strong>이다.
추상화를 통해 복잡한 <strong>내부 네트워크를 제어</strong>하고, 추적하고, 내부 네트워크 관련 로직을 추가함으로써 안정성, 신뢰성, 탄력성, 표준화, 가시성, 보안성 등을 확보한다.</p>

<p>Service Mesh 는 URL 경로, 호스트 헤더, API 버전 또는 기타 응용 프로그램 수준 규칙을 기반으로하는 <strong>7 계층 네트워크 Layer</strong> 이다.
Service Mesh 의 구현체인 경량화 Proxy를 통해 다양한 Routing Rules, circuit breaker 등 공통기능을 설정할 수 있다. 이는 서비스 간 통신에 연관된 기능 뿐만 아니라, 서비스의 배포 전략에도 도움을 준다.</p>

<h3 id="4-istio">4. istio</h3>
<ul>
  <li>Google, IBM, Lyft가 함께 기여하고 있는 오픈소스 Service Mesh 구현체</li>
  <li>kubernetes를 기본으로 지원하며 Control Plane — Data Plane 구조로 동작한다</li>
  <li>Envoy를 기본 Proxy로 wrapping하여 사용하지만 nginx나 linkerd 등으로 대체할 수 있다.
    <ul>
      <li>Envoy: connection 풀 동작 방식이나 어디서에서 connection이 끊겼는지도 통계로 확인 가능</li>
    </ul>
  </li>
</ul>

<p>service에 sidecar를 붙여서 실행되고 iptable을 통해 모든 트래픽을 제어한다. 제어된 모든 트래픽은 istio-proxy를 통해 나가고 받는다.</p>

<ul>
  <li>1% Canary 가능
    <ul>
      <li>istio route weight로 1% canary 배포 가능</li>
      <li>인스턴스 단위로 canary를 하면 세밀한 트래픽 조절이 힘듬. 10개 인스턴스에서 1개의 카나리가 나가면 10% 카나리가 됨. 하지만 istio route weight를 사용하면 인스턴스 개수와 상관없이 1% 카나리 배포가 가능하다.</li>
    </ul>
  </li>
  <li>failure injection test와 squeeze test
    <ul>
      <li>failure injection test: 특정조건에 맞는 요청의 경우 실패 또는 응답을 늦게 하도록 만들어 서비스에서 실패에 대한 처리가 제대로 되어 있는지 확인할 수 있는 테승트</li>
      <li>squeeze test: 하나의 인스턴스에 요청 비율을 높여 부하를 높이는 테스트</li>
    </ul>
  </li>
</ul>

<h3 id="5-ceph">5. Ceph</h3>
<p><img src="/assets\img/CS/Ceph_Operation.jpg" alt="" /></p>
<ul>
  <li>분산형 스토리지로 <strong>여러 스토리지들을 클러스터로 묶어 하나로 보이게 하는 스토리지</strong></li>
  <li>장점: 분산으로 저장하여 복구에 용이하고 하나의 클러스터로 묶어 클러스터를 바라보게만 하면 됨</li>
  <li>파일, 블록, 오브젝트 등 다양하게 제공하며 <strong>RADOS</strong>라는 것을 사용해 실질적인 기능을 구현함</li>
  <li>Data가 들어오면 Data의 종류의 따라 Object로 변환되고 변환된 Object는 Libados에 따라 이후과정은 룰에 따라 OSD에 저장 됨</li>
</ul>

<h3 id="6장애조치실패허용fail-over">6.장애조치/실패허용(fail-over)</h3>
<p>특정머신이 다운될 때 중복 백업 머신으로 전환하는 기술로 고가용성을 달성하기 위한 매우 일반적인 구현 방법. 종종 4계층 레이어, 7계층 레이어와 같은 다양한 로드 밸런싱 기술과 혼합되어 사용된다.</p>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="cs" /><category term="cs" /><summary type="html"><![CDATA[기술면접 대비 클라우드 관련 개념 정리]]></summary></entry><entry><title type="html">데이터를 말아올리는 대표적인 방법 - Message Queue</title><link href="https://icechoco.github.io/server/2022-05-20-Message-Queue/" rel="alternate" type="text/html" title="데이터를 말아올리는 대표적인 방법 - Message Queue" /><published>2022-05-20T00:00:00+09:00</published><updated>2022-06-10T16:03:39+09:00</updated><id>https://icechoco.github.io/server/Message-Queue</id><content type="html" xml:base="https://icechoco.github.io/server/2022-05-20-Message-Queue/"><![CDATA[<p><strong>이 글을 쓰는 이유</strong></p>

<blockquote>
  <p>크게 두 가지 목적에 의해 이 글을 작성하게 되었다.<br />
1) 데이터를 말아 올리는 대표적인 방법 4가지 중에서 많이 사용되는 MQ에 대해서 개념, 솔루션 종류를 알아본다.<br />
2) 요즘 클라우드 환경으로 전환됨에 따라 많이 사용되며 개인적으로도 관심이 있는 카프카에 대해 개념을 알아본다.</p>
</blockquote>

<hr />
<p>한 번에 처리해야할 데이터가 굉장히 많거나, 어떤 두 프로그램 간에 커뮤니케이션이 원활하지 않거나와 같은 여러 이유로 실시간 통신이 제대로 작동하지 않는 경우 우리는 <strong>비동기식 통신(Asynchronous Communication)</strong>을 고려할 수 있다. 그 방법에는 크게 MQ, Jenkins, Lambda, Spring Batch까지 총 4가지가 있다.</p>

<h2 id="1-mq-message-queue">1. MQ (Message Queue)</h2>
<p>애플리케이션을 비동기식 통신으로 분리해야할 경우 사용하는 메시지 기반의 미들웨어로 여러 시스템, 서비스 간의 연결도 지원하는 솔루션이다.<br />
MOM(Message Oriented Middleware)를 구현한 솔루션으로 비동기 메시지를 사용하는 서비스들 사이에서 데이터를 교환해주는 역할을 한다.<br />
Producer(sender)가 메시지를 큐에 전송하면 Consumer(receiver)는 큐에서 메시지를 가져오면서 처리한다.<br />
MQ는 producer와 consumer에 message 프로세스가 추가되는 것이 특징이다.<br />
MQ를 사용하여 비동기로 요청하고, 처리하고자 하는 서비스들을 분리하여 사용할 수 있다.</p>

<h3 id="1-1-관련개념">1-1. 관련개념</h3>
<h4 id="message">Message</h4>
<p>전송되어야 할 데이터를 우리는 메시지라고 부르며 데이터 포맷의 유형이기도 하다.</p>

<h4 id="queue">Queue</h4>
<p>가장 간단한 형태의 큐는 <strong>순차적으로 처리되는 일련의 요청들</strong>을 가리킨다.
이런 일련의 요청들에 대한 처리를 위해서는 무엇을 알아야 할지 생각해보면 가장 먼저 요청받은 메시지를 알고, 대기열이 어느 정도있는지도 알고 있어야 하고, 전체적으로도 알고 있어야 한다.</p>

<ul>
  <li>모든 사람들이 매일 사용하는 도구, <strong>이메일</strong>
    <ul>
      <li>이메일은 비동기 통신이 어떻게 동작하는지 알 수 있는 완벽한 예다.</li>
      <li>큐에 대한 이론을 실제 우리의 생활에 적용해볼 수 있다.</li>
      <li>A가 네이버 메일에서 메시지를 보내면, B는 받은 편지함에 들어오는 답장을 기다릴 수 있다.
        <ul>
          <li>발신자: A / 수신자 : B</li>
          <li>여기서 B의 이메일의 받은 편지함을 거기에 보관되어 있는 메시지의 대기열이라고 생각해보자.</li>
          <li>그리고 어떤 시점에 A가 보낸 메일을 B는 받을 것이고, 그가 원할 떄 언제든지 메일을 읽을 수 있다.</li>
          <li>시간이 더 오래 지날 경우, B가 읽어야 하는 메시지의 목록은 더 많아져 있을 것이다</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>나의 네이버 메일도 잠깐 확인 안하면 메일들이 엄청 쌓여있다. 근데 약간 비동기의 예시라고 하기에 조금 현실과 동떨어지는 부분이 있는데,
그건 바로 일반적으로 이메일을 다 확인하지 않고 일부만 열어본다는 것이다.</p>

<p>예를 들어서 내가 메일을 쓰고 그에 대한 답장을 기다리는 경우에 대해서만 메일함을 계속 들여다보거나 관련 없는 메일도 읽어보는 것 같다.
다른 사람들도 이런 경우가 아니면 대개 받은 메일함을 대충 한 번 보고 넘기지 않나…?
물론 이메일 하나하나 다 열어보고 확인하는 사람도 있겠지만 나처럼 내가 이메일을 쓰고 답장이 오기를 기다릴 때만 다 읽어보는 사람이 대부분 일 것이다.
그래서 위와 같은 이유로 큐의 개념인</p>

<blockquote>
  <p>들어오는 요청을 순차적으로 다 처리한다</p>
</blockquote>

<p>라는 개념과 이메일의 현실에서는 조금 차이가 있긴 하지만…! 그래도 이메일은 비동기를 현실 세계에 비유할 수 있는 가장 적절한 예시다. 그 이유는</p>

<ul>
  <li>이메일을 아무때나 작성하고 보낼 수 있다. 수신자가 내 메일을 받았는지, 언제 대답할 예정인지에 대해서 따로 걱정하고 계획하지 않아도 된다.</li>
</ul>

<p>그럼 이제 큐가 뭔지 알겠다. 그럼 실제로 큐가 어떤식으로 사용되는지 사용사례를 알고, 그 사용 사례를 통해 Message의 유형에 대해서도 알고 싶다.
큐는 메시지의 줄, 즉 대기열이다. 여기서 메시지를 보내는 사람을 Producer이라하고, 받는 사람을 Consumer라 한다.</p>

<h5 id="메시지-큐의-장점">메시지 큐의 장점</h5>
<ul>
  <li>비동기(Asynchronous): 큐에 넣기 때문에 나중에 처리할 수 있다.</li>
  <li>비동조(Decoupling): 애플리케이션과 분리 가능하다</li>
  <li>탄력성(Resilience): 일부가 실패해도 전체에 영향을 받지 않는다.</li>
  <li>과잉(Redundancy): 실패할 경우 재실행이 가능하다</li>
  <li>보증(Guarantees): 작업이 처리된 것을 확인할 수 있다.</li>
  <li>확증성(Scalable): 다수의 프로세스들이 큐에 메시지를 보낼 수 있다.</li>
</ul>

<p>큐는 위와 같은 장점으로 인해 대용량 데이터를 처리하기 위한 배치 작업이나, 채팅 서비스, 비동기 데이터를 처리할 때 사용한다.</p>

<h4 id="mommessage-oriented-middleware-메시지-지향-미들웨어">MOM(Message Oriented Middleware): 메시지 지향 미들웨어</h4>
<ul>
  <li>분산 시스템 간 메시지를 주고 받는 기능을 지원하는 소프트웨어나 하드웨어 인프라</li>
</ul>

<h4 id="프로토콜">프로토콜</h4>
<p><strong>AMQP(Advanced Message Queuing Protocol)</strong><br />
이기종 플랫폼 간의 상호 메시지 교환 가능하며, 특히 클라우드 컴퓨팅 환경에 매우 적합하다.<br />
AMQP는 금융계의 이기종 플랫폼 간의 메시지 상호 정보 교환을 위해서 JPMorgan의 John O’Hara에 의해 개발되었으며 2006년도에 최초 사용되었다고 한다.<br />
AMQP working Node group에 의해 개발된 오픈 스펙이다.</p>

<p>구현 소프트웨어 예시 : RabbitMQ</p>
<ul>
  <li>Subscribe to have messages delivered to them (“Push API”): this is the recommended option.</li>
  <li>Polling(“Pull API”): 이 방법은 <strong>매우 비효율적</strong>이고 대부분의 경우에서 <strong>피해야 할</strong> 방법이다.</li>
</ul>

<p>즉, Push와 Pull 방식 모두 가능하나 push를 권장하고 있다.</p>
<ul>
  <li><a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">RabbitMQ 공홈 - AMQP 0-9-1 Model Explained</a></li>
</ul>

<p>이 외에도 StormMQ, Apache Qpid와 같은 오픈 소스 구현 브로커가 있다.</p>

<p><br /></p>

<p><strong>JMS(Java Messaging System)</strong>
자바 플랫폼 간의 상호 메시지 교환이 가능하다. 단, 이기종 플랫폼 간은 제한적이다.<br />
RabbitMQ 문서를 보면 클라우딩 컴퓨팅 또는 Social Service 환경에서 처럼 대용량 메시지 처리는 AMQP가 적합하다.</p>

<p>구현 소프트웨어 예시 : Active MQ</p>
<ul>
  <li>ActiveMq does not support the AMQP protocol. and it does not select the consumer. because JMS is basically a pull system from 
receiver perspective. the broker does not push (Consumer에서 pull하는 방식으로 처리한다)</li>
</ul>

<p>메시징 모델</p>
<ul>
  <li>JMS는 publish-subscriber, point-to-point 메시징 모델을 제공한다.</li>
</ul>

<hr />

<h3 id="1-2-메시지-플랫폼">1-2. 메시지 플랫폼</h3>
<p>메시지 플랫폼은 크게 두가지 종류로 나뉘어진다. 첫 번째는 메시지 브로커, 두번째는 이벤트 브로커이다.<br />
메시지 브로커는 이벤트 브로커로 역할을 할 수 없지만, 이벤트 브로커는 메시지 브로커 역할을 할 수 있다.</p>

<p><strong>메시지 브로커(Message Broker)</strong></p>
<ul>
  <li>메시지 브로커는 많은 기업들의 대규모 미들웨어 아키텍처에서 사용되어 왔다.
    <ul>
      <li>미들웨어: 서비스하는 애플리케이션들을 보다 효율적으로 아키텍처들을 연결하는 요소로 작동하는 SW
        <ul>
          <li>ex) 메시징 플랫폼, 인증 플랫폼, DB</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Producer(송신자)와 Consumer(수신자)를 통해 메시지를 통신하고 네트워크를 맺는 용도로 사용해왔다.</li>
  <li>특징
    <ul>
      <li>데이터를 보내고 처리하고 삭제함</li>
      <li>메시지를 받아서 적절히 처리하고 나면 즉시 또는 짧은 시간 내에 삭제되는 구조</li>
    </ul>
  </li>
  <li>EX) Redis Queue, Rabbit MQ, Apache Kafka, ZeroMQ, AWS SQS, Azure Service Bus, Apache ActiveMQ, IBM MQ</li>
</ul>

<table>
  <thead>
    <tr>
      <th>보내는 쪽</th>
      <th>Sender</th>
      <th>Producer</th>
      <th>publisher</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>받는 쪽</td>
      <td>Receiver</td>
      <td>Consumer</td>
      <td>subscriber</td>
    </tr>
  </tbody>
</table>

<p><strong>이벤트 브로커</strong></p>
<ul>
  <li>이벤트 또는 메시지라고 불리는 레코드를 딱 하나만 보관하고 인덱스를 통해 개별 액세스를 관리함</li>
  <li>업무상 필요한 시간 동안 이벤트를 보존 가능</li>
  <li>메시지 브로커와 달리 데이터를 삭제하지 않음</li>
  <li>서비스에서 나오는 이벤트를 마치 DB에 저장하듯이 이벤트 브로커의 큐에 저장함
    <ul>
      <li>딱 한번 일어난 이벤트 데이터를 브로커에 저장함으로써 단일 진실 공급원으로 사용 가능</li>
      <li>장애가 발생했을 때 장애가 일어난 지점부터 재처리 가능</li>
      <li>많은 양의 실시간 스트림 데이터를 효과적으로 처리 가능</li>
      <li>이 외에도 다양한 이벤트 기반 MSA에서 중요한 역할을 처리함</li>
    </ul>
  </li>
  <li>이벤트 브로커로 클러스터를 구축하면 이벤트 기반 MSA로 발전하는데에 중요한 역할을 하며, 메시지 브로커로도 사용할 수 있음</li>
  <li>EX) Kafka, AWS의 키네시스</li>
</ul>

<h2 id="2-mq-대표-솔루션">2. MQ 대표 솔루션</h2>
<h3 id="21-대표적인-이벤트-브로커-kafka">2.1 대표적인 이벤트 브로커, kafka</h3>
<p><img src="/assets\img/Server/server_kafka.png" alt="server_kafka" /></p>

<h4 id="카프카란">카프카란?</h4>
<ul>
  <li>분산 이벤트 스트리밍 플랫폼</li>
  <li>프로듀서/컨슈머 분리</li>
  <li>메시지 데이터를 여러 컨슈머에게 허용</li>
  <li>대용량, 대규모 메시지 데이터를 빠르게 처리할 수 있는 메시징 시스템</li>
  <li>고성능 : 높은 처리량을 위한 메시지 최적화</li>
  <li>무중단 스케일 아웃 가능 → 카프카의 클러스터를 만든 뒤에 데이터가 많아지면 스케일 아웃해야하는데, 이때 무중단으로 가능</li>
  <li>관련 생태계 제공</li>
  <li>포춘 100개 기업 대상으로 80프로 이상이 kafka를 사용하고 있음</li>
  <li>국내에서도 우리가 아는 큰 회사들은 kafka를 많이 사용하고 있음</li>
  <li>대용량, 대규모 메시지 데이터를 빠르게 처리할 수 있는 메시징 시스템</li>
  <li>링크드인에서 시작했으나 → 현재는 아파치 공식 오픈소스</li>
  <li>데이터 처리를 여러 어플리케이션에서 하는 것이 아니라 중앙의 한 곳에서 처리할 수 있도록 중앙 집중화되었음</li>
  <li>애플리케이션, 웹사이트, 센서 등에서 취합한 데이터 스트림을 한 곳에서 실시간으로 관리할 수 있게 됨</li>
  <li>기업의 대용량 데이터를 수집하고 이를 사용자들이 실시간 스트림으로 소비할 수 있게 만들어줌</li>
</ul>

<h4 id="mq-미사용사용-웹-서비스-구조의-예시">MQ 미사용/사용 웹 서비스 구조의 예시</h4>
<ul>
  <li><strong>어플리케이션과 데이터 베이스의 동기적 직접 통신 구조</strong></li>
</ul>

<p><img src="/assets\img/Server/server_sync_comm.png" alt="" /></p>

<p>어플리케이션과 DB가 강하게 결합되어 있어 어플리케이션의 요청&amp;응답 과정에서 DB 서버로의 요청&amp;응답 모두 완료되어야 응답이 가능하다.<br />
따라서 다음과 같은 문제가 발생 가능하다.</p>

<ol>
  <li>DB의 응답 시간이 길어진다면 어플리케이션 또한 그만큼 응답시간이 길어진다.</li>
  <li>DB 장애시 어플리케이션이 동작하지 못한다.</li>
  <li>어플리케이션 입장에서 감당할 수 있는 요청의 수가 DB에서는 감당이 불가능하다면, 성능저하 또는 장애가 발생할 수 있다.</li>
</ol>

<ul>
  <li><strong>MQ를 통한 어플리케이션과 DB의 통신</strong></li>
</ul>

<p><img src="/assets\img/Server/server_async_comm.png" alt="" /></p>

<ol>
  <li>어플리케이션이 요청을 보내고, DB의 응답을 기다리지 않고 응답을 보낼 수 있다.</li>
  <li>DB는 큐의 요청을 꺼내 처리한다.</li>
  <li>DB 장애가 발생해도 어플리케이션은 독립적으로 동작 가능하다.</li>
  <li>어플리케이션과 DB 사이의 통신을 처리량에 따라 제어 가능하다.</li>
</ol>

<hr />

<h4 id="카프카는-왜-많이-사용되고-있을까">카프카는 왜 많이 사용되고 있을까?</h4>
<h5 id="1-high-throughput-message-capacity">1) High throughput message capacity</h5>
<p>짧은 시간내에 엄청난 양의 데이터를 컨슈머까지 전달할 수 있다. 파티션을 통한 분산처리가 가능하기 때문에 데이터의 양이 많아질수록 Consumer 갯수를 늘려서 병렬처리가 가능하다.
이를 통해 데이터 처리를 더욱 빠르게 할 수 있다.</p>

<h5 id="2-scalability와-fault-tolerant">2) Scalability와 fault tolerant</h5>
<p>확장성이 뛰어나다. 이미 사용되고 있는 카프카 브로커가 있다 하더라도 신규 브로커 서버를 추가해 수평확장이 가능하다. 
그리고 브로커 중 몇대가 죽는다 하더라도 이미 replica로 복제된 데이터는 안전하게 보관되어있어 복구가 가능하다.</p>

<h5 id="3-undeleted-log">3) Undeleted log</h5>
<p>다른 플랫폼과 달리 카프카 토픽에 들어간 데이터는 컨슈머가 데이터를 가져간다 하더라도 사라지지 않는다. 
만약 다른 플랫폼에서 이러한 처리를 하려고 했다면 복잡한 방식을 썼어야 했겠지만, 카프카에서는 컨슈머의 그룹id만 다르면 동일한 데이터도 각각 다르게 처리가 가능하다.</p>

<p>그럼 카프카는 대규모 데이터 처리가 발생하는 곳에서만 쓰는 것이 좋을까? 아니다. 스타트업도 사용하면 좋다. 스타트업의 경우는 빠른 확장성과 안정성을 중요시 하는데, 카프카를 이용하면 빠른 Scale out이 가능하다.<br />
카프카 클러스터 내부의 브로커 개수를 늘려서 원활하게 데이터 처리가 가능하다. 즉 어떤 형태의 기업에서도 적용이 가능하다.</p>

<h4 id="탄생-배경">탄생 배경</h4>
<p>2009년 당시 링크드인에는 두 가지 이슈가 있었다고 한다. 첫 번째 이슈는 ‘데이터 중앙 저장소가 무엇인가?’였다.<br />
현재는 DW를 사용하는 것이 익숙하지만 그때까지만 하더라도 Hadoop도 없었고, 빠르게 대응할 수 있는 SQL DB도 없었다. 때문에 그들은 모든 데이터에 빠르게 접근하기 위한 방법을 찾아야 했다.</p>

<p>그와 동시에 두 번째 이슈는 다양한 데이터 소스가 존재한다는 것이다. 사용할 데이터로 이루어진 DB 뿐만 아니라 Application, 이벤트, 네트워크 핑까지 수집했다. 이런 다양한 데이터들을 수집하다보니 어떻게 이 통합해야 하는지에 대한 고민에 직면했다.</p>

<p>그래서 그들은 데이터와 애플리케이션을 전체적으로 보는 데에 집중했다. Application은 DB나 Queue를 사용했었고, 데이터는 ETL 툴이나 Analytics툴을 사용했다. 즉, 애플리케이션과 데이터간에 시각화의 차이가 있었다.</p>

<p>하지만 그들은 새로운 것을 만들어내고 싶진 않았고, 이미 있는 것들을 조합하여 돌아가게 만들어보고 싶었다. 그래서 rabbitMQ, retrofit, ETL툴을 조합하여 사용했다. 그런데 사용하면 할수록 문제의 핵심을 해결하지 못한다는 느낌이 들었다고 한다. 그래서 만들게 된 것이 바로 <strong>카프카</strong>이며 2011년 초에 오픈소스화 되었다.</p>

<h4 id="기본구조">기본구조</h4>
<p>카프카는 4개의 구성요소로 이루어져 있다.
<img src="/assets\img/Server/basic_structure.jpg" alt="" /></p>
<ol>
  <li>카프카 클러스터
    <ul>
      <li>메시지를 저장하는 저장소</li>
      <li>하나의 카프카 클러스터는 여러개의 브로커로 구성되어 있음(보통 3대 이상의 브로커로 클러스터를 구성)</li>
      <li>브로커는 각각의 서버라도 보면됨</li>
      <li>브로커들이 메시지를 나눠서 저장하고, 이중화 처리하고, 장애 발생 시 대체도 함</li>
      <li>데이터를 이동하는데에 핵심 역할을 맡음</li>
      <li>1.1 <strong>Kafka broker</strong>
        <ul>
          <li>주로 실행된 카프카 애플리케이션 서버 중 1대를 운영함</li>
          <li>주키퍼와 연동을 해야함( ~2.5.0버전 )
            <ul>
              <li>주키퍼의 역할: 메타데이터(브로커 id, 컨트롤 id 등) 저장</li>
              <li>추후 주키퍼를 걷어낼 예정이라고 함</li>
            </ul>
          </li>
          <li>n개 브로커 중 1대는 컨트롤러(Controller) 기능 수행
            <ul>
              <li>컨트롤러: 각 브로커에게 담당 파티션 할당 수행</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>주키퍼 클러스터
    <ul>
      <li>카프카 클러스터에 대한 정보를 기록 및 관리하는 용도</li>
    </ul>
  </li>
  <li>프로듀서: 카프카 클러스터에 메세지를 보내는 것</li>
  <li>컨슈머: 메시지를 카프카에서 읽어옴</li>
</ol>

<h5 id="토픽과-파티션">토픽과 파티션</h5>
<p><img src="/assets\img/Server/server_kafka_partition.png" alt="" /></p>
<ul>
  <li>메시지를 구분하는 단위</li>
  <li>뉴스용 토픽, 주문용 토픽
    <ul>
      <li>파일시스템의 폴더와 메일함과 유사</li>
      <li>토픽은 1개 이상의 파티션으로 구성</li>
      <li>파티션: 메시지를 저장하는 물리적인 파일</li>
      <li>프로듀서와 컨슈머가 토픽을 기준으로 메시지를 받게됨</li>
      <li>파티션에는 프로듀서가 보낸 데이터들이 들어가 저장되는데 이 데이터를 <strong>레코드</strong>라고 한다.</li>
    </ul>
  </li>
</ul>

<h5 id="파티션과-오프셋-메시지-순서">파티션과 오프셋, 메시지 순서</h5>
<ul>
  <li>파티션은 추가만 가능한(append-only) 파일</li>
  <li>오프셋: 각각의 메시지가 저장되는 위치</li>
  <li>프로듀서가 넣은 메시지는 파티션의 맨 뒤에 추가</li>
  <li>컨슈머는 오프셋 기준으로 메시지를 순서대로 읽음</li>
  <li>파티션에 저장된 메시지는 컨슈머가 읽었는지와는 상관없이 삭제되지 않음</li>
  <li><strong>여러 파티션과 프로듀서</strong>
    <ul>
      <li>라운드로빈 또는 키로 파티션을 선택함</li>
      <li>프로듀서가 카프카에 메시지를 전달할때 선택 가능</li>
      <li>같은 키는 메시지 순서가 유지됨</li>
    </ul>
  </li>
  <li><strong>여러 파티션과 컨슈머</strong>
    <ul>
      <li>컨슈머가 카프카 브로커에 연결할 때 나는 어떤 그룹에 속한다라고 지정하게 되어있음</li>
      <li>⭐ 한 개의 파티션은 그룹의 한 개 컨슈머에만 연결 가능</li>
      <li>컨슈머그룹 기준으로 파티션의 메시지가 순서대로 처리됨을 보장함</li>
    </ul>
  </li>
  <li><strong>성능이 왜 좋을까?</strong>
    <ul>
      <li>파티션 파일에 대해 OS가 제공하는 페이지캐시를 사용</li>
      <li>Zero copy를 사용</li>
      <li>브로커가 컨슈머에 대해 하는 일이 없음</li>
    </ul>
  </li>
  <li><strong>메시지 필터, 메시지 재전송과 같은 일을 브로커가 하지 않음</strong>
    <ul>
      <li>묶어서 보내기, 묶어서 받기(batch)</li>
    </ul>
  </li>
  <li><strong>프로듀서: 일정 크기만큼 메시지를 모아서 전송 가능</strong>
    <ul>
      <li>처리량 확장이 쉬움</li>
      <li>1개 장비의 용량이 한계가 있는 경우 브로커와 파티션을 추가하면 됨</li>
    </ul>
  </li>
  <li><strong>리플리카 - 복제</strong>
    <ul>
      <li>장애가 났을 때 이를 대처하기위해 리플리카를 사용</li>
      <li>리플리카 : 파티션의 복제본</li>
      <li>복제수만큼 파티션의 복제본이 각 브로커에 생김
        <ul>
          <li>리더가 속한 브로커에 장애 발생 시 다른 팔로워가 리더가 됨</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>프로듀서의 기본 흐름</strong>
<img src="/assets\img/Server/Basic_flow_of_producer.jpg" alt="" />
    <ul>
      <li>프로듀서가 Serializer를 이용해 바이트 배열로 변환하고, Partitioner를 통해 파티션을 결정함</li>
      <li>그때 배치로 메시리지를 묶어서 저장함</li>
      <li>센더가 배치들을 차례대로 가져와서 저장함</li>
    </ul>
  </li>
  <li><strong>센더의 기본 동작</strong>
<img src="/assets\img/Server/senders_basic_behavior.jpg" alt="" />
    <ul>
      <li>센더는 별도 스레드로 동작</li>
      <li>배치를 차례대로 하나씩 꺼내서 카프카 브로커로 보냄</li>
      <li>센더는 센더대로 배치를 꺼내서 브로커에 보내고, 센더 메소드는 계속해서 배치에 누적시킴</li>
      <li>센더는 배치가 다 차지 않아도 바로 보냄</li>
    </ul>
  </li>
  <li><strong>처리량 관련 주요 속성</strong>
<img src="/assets\img/Server/key_attributes_related_to_throughput.jpg" alt="" /></li>
  <li>lingers.ms : 전송 대기 시간 ( 기본값 0 )
    <ul>
      <li>대기시간이 없으면 바로 전송</li>
      <li>대기 시간을 주면 시간만큼 기다렸다가 배치를 전송</li>
      <li>10, 100과 같이 값을 줄 수 있음</li>
    </ul>
  </li>
  <li>전송결과 확인 안하는 경우
    <ul>
      <li>전송 실패를 알 수 없게 구현 가능</li>
    </ul>
  </li>
  <li>전송 결과를 확인해야하는 경우
    <ul>
      <li>sender 메시지의 Future 사용</li>
    </ul>
  </li>
</ul>

<h3 id="22-ibm-mq">2.2 IBM MQ</h3>
<ul>
  <li>가장 많이 사용되는 상용 MQ 제품으로 표준 JMS 메시징 기반으로 MQTT 프로토콜을 지원한다.</li>
</ul>

<p>현재 내가 속한 부서에서도 DB간 동기화 시 IBM MQ를 사용하고 있다.</p>

<h3 id="23-apache-activemq">2.3 Apache ActiveMQ</h3>
<ul>
  <li>JAVA 기반의 JMS Queue를 지원하는 오픈소스로 MQTT, AMQP, OpenWire, STOMP 등의 프로토콜을 지원한다.</li>
  <li>다양한 언어를 지원하며 클러스터링이 가능하다.</li>
  <li>모니터링 도구가 없다.</li>
  <li>REST API를 통해 웹기반 메시징 API를 지원한다.</li>
  <li>Ajax를 통해 순수한 DHTML을 사용한 웹스트리밍 지원을 한다.</li>
</ul>

<h3 id="24-rabbitmq">2.4 RabbitMQ</h3>
<ul>
  <li>고성능을 목표로 AMQP 프로토콜을 사용하여 개발된 MQ로 Eralang OTP 기반으로 개발되었다.</li>
  <li>실시간 모니터링이 용이하다</li>
  <li>다양한 언어 및 OS를 지원한다</li>
  <li>RabbitMQ 서버 간 클러스터링이 가능하다.</li>
</ul>

<h2 id="참고">참고</h2>
<ul>
  <li><a href="https://www.youtube.com/watch?v=xErwDaOc-Gs">What is a Message Queue?</a></li>
  <li><a href="https://youtu.be/H_DaPyUOeTo">카프카, 레빗엠큐, 레디스 큐의 큰 차이점! 이벤트 브로커와 메시지 브로커에 대해 알아봅시다.</a></li>
  <li><a href="https://youtu.be/0Ssx7jJJADI">kafka 조금 아는 척하기 1</a></li>
  <li><a href="https://velog.io/@ehdrms2034/Kafka-3%EC%9E%A5-%EC%B9%B4%ED%94%84%EC%B9%B4-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-%EC%84%A4%EB%AA%85-1">[Kafka] 3장 카프카 기본 개념 설명 (1)</a></li>
  <li><a href="https://sarc.io/index.php/miscellaneous/1615-message-queue-mq">Message Queue (MQ) 란 무엇일까</a></li>
  <li><a href="https://m.blog.naver.com/PostView.nhn?blogId=willygwu2003&amp;logNo=130171452288&amp;proxyReferer=https:%2F%2Fwww.google.com%2F">JMS vs AMQP</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="server" /><category term="server" /><summary type="html"><![CDATA[이 글을 쓰는 이유]]></summary></entry><entry><title type="html">[Database] DB 샤딩(Sharding)이란 무엇인가?</title><link href="https://icechoco.github.io/database/2022-05-18-What-is-Database-Sharding/" rel="alternate" type="text/html" title="[Database] DB 샤딩(Sharding)이란 무엇인가?" /><published>2022-05-18T00:00:00+09:00</published><updated>2022-05-19T01:09:46+09:00</updated><id>https://icechoco.github.io/database/What-is-Database-Sharding</id><content type="html" xml:base="https://icechoco.github.io/database/2022-05-18-What-is-Database-Sharding/"><![CDATA[<p><img src="/assets\img/Database/Database-Sharding.png" alt="Database-Sharding" /></p>

<p>Database를 확장할 수 있는 방법은 하드웨어 확장, Replica 추가, 그리고 Sharding까지 여러가지가 있다. 그리고 이 글에서는 <strong>Database Sharding이란 무엇인가?</strong>에 대해 그 개념을 정리하고자 한다.</p>

<p>요즘은 점점 데이터가 쌓여가면서 대용량 데이터로 인해 이슈를 겪는 곳이 많은 것 같다. 내가 속한 부서에서도 문제 없이 정상적으로 조회되던 화면이 1년동안 2,400만건의 데이터가 쌓이면서 조회가 되지 않는 이슈가 발생한 적이 있다.<br />
이렇게 쌓이는 대규모 데이터는 DB 시스템의 과부하로 용량의 한계를 맞이하게 한다. 이때 관리자들은 시스템 업그레이드를 고려하는데 이때 시스템 업그레이드는 위에서 첫 번째 방법으로 말했던 하드웨어 확장을 의미한다.<br />
즉 장비를 고사양으로 전환해 기존 시스템의 처리 용량을 증대시키는 방법이다. 이는 <strong>Scale-up</strong>이라고도 한다. 여기서는 이 방식을 사용하여 DB 자원을 증설한다.</p>

<h2 id="scale-up-the-hardware">Scale-up the Hardware</h2>
<p>이 방식은 기존에 사용하는 장비를 업그레이드 하는 것이기 떄문에 기존 장비 사양에 따라서 증설 계획이 결정된다. 하지만 보통 DB는 최초 구매할 때 부터 고사양으로 구매하는 것이 일반적이기 떄문에, 이렇게 좋은 성능의
DB에서 더 좋은 장비를 구매한다는건 비용적으로 많은 부담을 안길 수 있으며 약간의 제약이 따른다.</p>

<h2 id="sharding">Sharding</h2>
<p>엥 그럼 비용도 아끼면서 어떻게 장비를 활용하는 것이 대용량 데이터베이스를 저장할 수 있단 말인가! 이러한 문제점을 해결하기 위해서 DB 시스템은 소프트웨어적으로 DB를 분산시켜 처리할 수 있는 구조를 만들었는데,
이러한 기술 중 하나가 우리가 오늘 배우려고 하는 <strong>샤딩(Sharding)</strong>이다! 샤딩은 2가지 종류가 있는데 아래 2개로 나뉘어 진다.</p>
<ul>
  <li>DB가 저장하고 있는 테이블을 테이블 단위로 분리하는 방법</li>
  <li>테이블 자체를 분할하는 방법</li>
</ul>

<blockquote>
  <가정> 우리가 사용하는 DB에 총 5개의 테이블이 있다. 근데 5개의 테이블에 대용량 데이터가 갑자기 몰려 시스템 사양을 초과헀다. 이를 샤딩하기 위해 한 대의 DB 시스템을 2대로 증설하려 한다.
</가정>
</blockquote>

<p>여기서 첫 번째 방법인 테이블 단위로 분리하는 방법(a)을 사용하는 경우를 생각해보자. 총 5개의 테이블에서 첫 번째 장비에는 테이블 3개, 두 번째 장비에는 테이블 2개로 분리할 수 있다. 
두 번째 방법인 테이블 자체를 분할하는 방법(b)은 총 5개의 테이블을 모두 반반씩 쪼개어 두 개의 장비에 나누어 저장하는 방법이다.</p>

<p><img src="/assets\img/Database/Database-Sharding-example.png" alt="Database-Sharding-example" /></p>

<p>좌측과 같이 한 곳에 저장되어 있던 테이블을 두 개 이상의 shard로 데이터를 분리하는 경우, DB 시스템은 사용자 Query에 따라 검색되어야 할 데이터가 어떤 Shard에 위치하고 있는지 위치 정보를 관리하는 모듈이 필요하다.</p>
<ul>
  <li><strong>중개자(broker)</strong>: 샤딩된 데이터의 위치 정보를 관리하는 모듈. 질의를 분석하여 Shard를 선택하고, 응답에 대한 결과를 전달하는 역할을 담당</li>
</ul>

<h3 id="예시">예시</h3>
<p>피자를 생각해보자. 난 한 조각씩 잘려진 피자를 갖고 있고 이 조각 피자를 친구들에게 공유하려고 한다. 데이터 분할이라고도 하는 샤딩은 피자 조각을 공유하는 것과 동일한 개념이다.
기본적으로 큰 데이터 세트를 더 작은 덩어리(논리적 샤드)로 분할하고 이러한 덩어리를 다른 머신/데이터베이스 노드(물리적 샤드)에 저장/배포하는 데이터베이스 아키텍처 패턴이다.</p>

<p>여기서 각 덩어리/파티션은 “샤드”로 불리며 <strong>각 샤드는 원본 데이터베이스와 동일한 데이터베이스 스키마를 가진다.</strong>
우리는 각 row가 정확히 하나의 샤드에 나타나는 방식으로 데이터를 배포한다. 이것은 애플리케이션의 확장성을 향상시키는 좋은 메커니즘이다.</p>

<p><img src="/assets\img/Database/comparing-Sharding.jpg" alt="comparing-Sharding" /></p>
<blockquote>
  <p>데이터베이스 샤드는 자율적이다. 동일한 데이터나 컴퓨팅 리소스를 공유하지 않는다. 그러나 어떤 경우에는 특정 테이블을 각 샤드로 복제하여 참조 테이블로 사용하는 것이 더 적합할 떄도 있다.</p>
</blockquote>

<h3 id="sharding-system의-구조">Sharding System의 구조</h3>
<p><img src="/assets\img/Database/structure-of-Sharding.png" alt="structure-of-Sharding" /></p>

<p>위 그림은 Sharding System의 구조를 보여준다. 이 시스템은 크게 응용계층, 중개자 계층, 데이터(서버 또는 샤드) 계층으로 구성된다.</p>
<ul>
  <li>응용계층
    <ul>
      <li>데이터에 접근하기 위해 중개자를 통해 모든 데이터 입출력을 진행</li>
      <li>응용은 샤딩된 DB 시스템의 자세한 구조를 알 필요 없이 하나의 추상화된 DB가 존재하는 것 처럼 느끼게 됨</li>
    </ul>
  </li>
  <li>중개자 계층
    <ul>
      <li>응용계층과 데이터 계층 사이에 위치</li>
      <li>샤딩 시스템의 가장 핵심적인 부분</li>
      <li><strong>샤드 메타 정보(Shard Meta data)</strong>를 저장하여 중개자로부터 전달된 질의를 분석</li>
      <li>적절한 샤드에 명령을 수행하고 그 결과를 응용에 전달함</li>
    </ul>
  </li>
  <li>데이터 계층
    <ul>
      <li>여러개의 샤드(또는 서버)로 구성됨</li>
      <li>각각의 샤드는 일반 DB 시스템과 동일한 역할을 담당</li>
    </ul>
  </li>
</ul>

<p>중개자 계층이 저장하는 샤드 메타 정보는 분할을 결정하는 정책에 따라 아래 3가지로 분류된다.</p>
<ul>
  <li>형태에 따른 분류
    <ul>
      <li>독립된 쿼리가 보장되는 시스템에서 RDB를 분할하는 방법에 효과적임</li>
    </ul>
  </li>
  <li>Key 기반 분류
    <ul>
      <li>자동 샤딩 시스템에 잘 적용됨</li>
    </ul>
  </li>
  <li>Look-up 테이블 기반 분류
    <ul>
      <li>Scale-out 중심의 분산 DB에 적합</li>
    </ul>
  </li>
</ul>

<p>위 3가지 Shard 전략 모두 장단점을 갖고 있으므로 어떤 전략이 무조건 적으로 좋다라고 말할 순 없다. 각각의 장단점을 잘 파악하고 어떤 전략을 사용할지 결정해야 한다.</p>

<h3 id="참고">참고</h3>
<ul>
  <li><a href="https://www.youtube.com/watch?v=hdxdhCpgYo8&amp;t=269">What is Database Sharding?</a></li>
  <li><a href="https://www.geeksforgeeks.org/database-sharding-a-system-design-concept/">Database Sharding – System Design Interview Concept</a></li>
  <li><a href="http://mongodb.citsoft.net/?page_id=225#comment-91922">샤딩 시스템의 개요</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="database" /><category term="database" /><category term="React" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[Spring] SpringBoot로 Rest API 만들기 - Swagger API 문서 자동화</title><link href="https://icechoco.github.io/java,/spring/2022-05-12-make-rest-api-with-springBoot/" rel="alternate" type="text/html" title="[Spring] SpringBoot로 Rest API 만들기 - Swagger API 문서 자동화" /><published>2022-05-12T00:00:00+09:00</published><updated>2022-06-09T00:19:36+09:00</updated><id>https://icechoco.github.io/java,/spring/make-rest-api-with-springBoot</id><content type="html" xml:base="https://icechoco.github.io/java,/spring/2022-05-12-make-rest-api-with-springBoot/"><![CDATA[<p>평소에 내가 속한 부서에서는 프론트와 백엔드 개발자가 나뉘어 있지 않고 한 사람이 다 하다보니 API 문서 자동화를 제공해주는 Swagger를 사용하고 있지 않았다. 
외부 시스템과 연계해야 할 때는 API 문서를 엑셀 또는 파워포인트로 정리하여 공유가 되었다. 그런데, 최근에 외부 시스템과 원활한 IF를 위해 Swagger를 적용하는 곳이 생기고 있다.  <br />
그런데 이번에 YAPP 백엔드 팀원 분이 Swagger를 사용해봤더니 프론트와 백엔드 간의 의사소통이 원활했다라는 말을 듣고 이번 사이드 프로젝트에도 적용하기로 하였다.</p>

<p>Swagger는 문서 자동화 툴이며 간단한 설정으로 테스트가 가능한 Web UI를 지원한다. API를 테스트하기 위해 부가적으로 Postman과 같은 프로그램을 깔지 않아도 된다!<br />
또한 최소한의 작업을 통해 자동으로 API Document를 만들어주기 때문에 프론트 개발자에게 문서 내용을 전달하기위해 워드나 파워포인트를 만들지 않아도 된다는 장점이 있다.</p>

<h2 id="buildgrald에-swagger-라이브러리-추가하기">build.grald에 swagger 라이브러리 추가하기</h2>
<p><code class="language-plaintext highlighter-rouge">build.grale</code> 파일에 아래와 같이 라이브러리를 추가한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">implementation</span> <span class="nl">group:</span> <span class="err">'</span><span class="n">io</span><span class="o">.</span><span class="na">springfox</span><span class="err">'</span><span class="o">,</span> <span class="nl">name:</span> <span class="err">'</span><span class="n">springfox</span><span class="o">-</span><span class="n">swagger2</span><span class="err">'</span><span class="o">,</span> <span class="nl">version:</span> <span class="err">'</span><span class="mf">2.9</span><span class="o">.</span><span class="mi">2</span><span class="err">'</span>
	<span class="n">implementation</span> <span class="nl">group:</span> <span class="err">'</span><span class="n">io</span><span class="o">.</span><span class="na">springfox</span><span class="err">'</span><span class="o">,</span> <span class="nl">name:</span> <span class="err">'</span><span class="n">springfox</span><span class="o">-</span><span class="n">swagger</span><span class="o">-</span><span class="n">ui</span><span class="err">'</span><span class="o">,</span> <span class="nl">version:</span> <span class="err">'</span><span class="mf">2.9</span><span class="o">.</span><span class="mi">2</span><span class="err">'</span>
</code></pre></div></div>

<h2 id="buildgrald에-swagger-라이브러리-추가하기-1">build.grald에 swagger 라이브러리 추가하기</h2>
<p>yapp.bestFriend.config 패키지에 SwaggerConfig 파일을 작성한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableSwagger2</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SwaggerConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">Docket</span> <span class="nf">docket</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Docket</span><span class="o">(</span><span class="nc">DocumentationType</span><span class="o">.</span><span class="na">SWAGGER_2</span><span class="o">).</span><span class="na">select</span><span class="o">()</span>
                <span class="o">.</span><span class="na">apis</span><span class="o">(</span><span class="nc">RequestHandlerSelectors</span><span class="o">.</span><span class="na">basePackage</span><span class="o">(</span><span class="s">"yapp.bestFriend.controller"</span><span class="o">))</span>
                <span class="o">.</span><span class="na">paths</span><span class="o">(</span><span class="nc">PathSelectors</span><span class="o">.</span><span class="na">any</span><span class="o">())</span>
                <span class="o">.</span><span class="na">build</span><span class="o">()</span>
                <span class="o">.</span><span class="na">apiInfo</span><span class="o">(</span><span class="n">apiInfo</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">ApiInfo</span> <span class="nf">apiInfo</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ApiInfoBuilder</span><span class="o">()</span>
                <span class="o">.</span><span class="na">title</span><span class="o">(</span><span class="s">"절친 API 문서"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">description</span><span class="o">(</span><span class="s">"절친 API 서버 문서입니다."</span><span class="o">)</span>
                <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="s">"1.0"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li><strong>basePackage(“yapp.bestFriend.controller”)).paths(PathSelectors.any())</strong>
    <ul>
      <li>yapp.bestFriend.controller 하단의 Controller 내용을 읽어 mapping된 resource들을 문서화 시킨다.</li>
      <li><code class="language-plaintext highlighter-rouge">PathSelectors.ant("/v1/**"")</code>와 같이 설정하여 v1으로 시작하는 resource들만 문서화 시키는 것도 가능하다.</li>
    </ul>
  </li>
  <li>ApiInfo를 작성하면 문서에 대한 설명과 작성자 정보를 표시할 수 있다.</li>
</ul>

<h2 id="usecontroller-수정하기">UseController 수정하기</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Api</span><span class="o">(</span><span class="n">tags</span> <span class="o">=</span> <span class="o">{</span><span class="s">"회원 API"</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserController</span> <span class="o">{</span>

<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li><strong>@Api(tags = {“회원 API”})</strong>
    <ul>
      <li>UserController를 대표하는 최상단 타이틀 영역에 표시되는 값 세팅</li>
    </ul>
  </li>
</ul>

<h3 id="참고">참고</h3>
<ul>
  <li><a href="https://daddyprogrammer.org/post/313/swagger-api-doc/">SpringBoot2로 Rest api 만들기(4) - Swagger API 문서 자동화</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="java," /><category term="spring" /><category term="java" /><summary type="html"><![CDATA[평소에 내가 속한 부서에서는 프론트와 백엔드 개발자가 나뉘어 있지 않고 한 사람이 다 하다보니 API 문서 자동화를 제공해주는 Swagger를 사용하고 있지 않았다. 외부 시스템과 연계해야 할 때는 API 문서를 엑셀 또는 파워포인트로 정리하여 공유가 되었다. 그런데, 최근에 외부 시스템과 원활한 IF를 위해 Swagger를 적용하는 곳이 생기고 있다. 그런데 이번에 YAPP 백엔드 팀원 분이 Swagger를 사용해봤더니 프론트와 백엔드 간의 의사소통이 원활했다라는 말을 듣고 이번 사이드 프로젝트에도 적용하기로 하였다.]]></summary></entry><entry><title type="html">[Spring] 카카오, 구글 소셜 로그인 구현하기</title><link href="https://icechoco.github.io/java,/spring/2022-05-10-social-login/" rel="alternate" type="text/html" title="[Spring] 카카오, 구글 소셜 로그인 구현하기" /><published>2022-05-10T00:00:00+09:00</published><updated>2022-05-25T15:45:46+09:00</updated><id>https://icechoco.github.io/java,/spring/social-login</id><content type="html" xml:base="https://icechoco.github.io/java,/spring/2022-05-10-social-login/"><![CDATA[<p>Spring Boot 구조로 구성된 사이드 프로젝트에 적용 예정인 OAuth2 소셜로그인에 대해 정리하기위해 이 글을 쓰게 되었다.</p>

<h2 id="사전-지식">사전 지식</h2>
<h3 id="oauth2">OAuth2</h3>
<p>OAuth란 <strong>인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹사이트 상의 정보들에 대해 접근 권한을 부여할 수 있는 수단을 제공하는 것</strong>이다.
예를 들어 구글에 저장되어 있는 사진을 가지고 어떤 서비스를 만들고자 할 때 사용된다.</p>

<p><strong>OpenID connect</strong></p>
<ul>
  <li>권한관리를 위한 OAuth 2.0 위에 인증 관리를 올린 것</li>
</ul>

<p><strong>Spring Security(스프링 세큐리티)</strong></p>
<ul>
  <li>자바 어플리케이션에 권한(Authorization)과 인증(Authentication)을 구현하는데 필요한 기능을 제공하는 프레임 워크</li>
</ul>

<h3 id="json-web-token">JSON Web Token</h3>
<p>JSON Web Token(JWT)은 참여자 간에 안전하게 정보를 주고 받기 위해 JSON 객체에 정보를 내장하는 방법을 정의하는 개방형 표준(RFC7519)이다.</p>

<p>토큰의 종류</p>
<ul>
  <li>access_token: 리소스 서버에 실제로 접근하기 위한 권한을 갖고 있음
    <ul>
      <li>중요한 정보이기 때문에 토큰의 보호기능으로서 만료시간이 있으나 짧음(대개 몇 분 정도로 유지)</li>
    </ul>
  </li>
  <li>Refresh Token: 새로운 access_token 토큰을 발급 받기 위해 요청</li>
  <li>ID Token: 굳이 서버에 가지 않아도 사용자의 정보를 바로 받아서 쓸 수 있음</li>
</ul>

<h4 id="토큰의-구조">토큰의 구조</h4>
<ul>
  <li>Header: 토큰의 Type, <strong>서명에 대한 알고리즘</strong>, BASE64로 인코딩됨</li>
  <li>★ Payload: 데이터, valims(key-value 형태의 데이터), BASE64로 인코딩됨</li>
  <li>signature: 헤더와 payload의 내용이 임의로 조작되었는지를 검증해줌</li>
</ul>

<h5 id="1-header">1. Header</h5>
<p>토큰의 서명을 생성하기 위해 어떤 알고리즘을 사용하였는지를 나타냄</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "alg": "ES256",
    "type": "JWT",
    "kid": "Key ID"
}
</code></pre></div></div>
<ul>
  <li>alg</li>
  <li>type</li>
  <li>kid: Key ID Header Parameter, JWS(Json web Signature)를 암호화하기 위해 사용된 키를 가리킴</li>
</ul>

<h3 id="2-payloaddata">2. Payload(Data)</h3>
<p>Payload는 실제 JWT의 컨텐츠이다.</p>

<h3 id="3-signature">3. signature</h3>
<p>보통 RS256 방법을 많이 쓴다.</p>
<ul>
  <li><strong>HS256</strong>
    <ul>
      <li>Secret key가 있으며 로그인과 validation이 둘다 이루어짐</li>
    </ul>
  </li>
  <li><strong>RS256</strong>
    <ul>
      <li>private key로만 사이닝을 하고, 다른 서비스들은 public key를 가지고 Validation하는 것</li>
    </ul>
  </li>
</ul>

<p>그럼 keycloak는 이 public key를 언제 다운받을까? public key를 안갖고 있는 최초 1회에 다운로드 받는다.</p>

<h3 id="statefule--stateless">Statefule &amp; Stateless</h3>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Stateful(Session)</th>
      <th>Stateless(Token)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>세션 정보 저장</td>
      <td>In-Memory, Database와 같은 원격 저장소를 사용함</td>
      <td>X</td>
    </tr>
    <tr>
      <td>세션 회수(취소)</td>
      <td>가능</td>
      <td>X (토큰 만료 시간으로 보완)</td>
    </tr>
    <tr>
      <td>정보 노출</td>
      <td>X(중요한 정보들을 client에 노출없이 서버에 저장해 쓸 수 있음, 세션 ID만 노출)</td>
      <td>JWT는 위조는 불가하지만 내용은 공개됨</td>
    </tr>
    <tr>
      <td>확장성</td>
      <td>또 다른 메모리가 있으면 replication을 해야하기 때문에 확장성이 좋지 않음</td>
      <td>아주 높음</td>
    </tr>
    <tr>
      <td>예시</td>
      <td>JSession</td>
      <td>JWT</td>
    </tr>
  </tbody>
</table>

<h2 id="전체-시퀀스-다이어그램">전체 시퀀스 다이어그램</h2>

<p><img src="/assets\img/total_sequence_diagram.jpg" alt="total_sequence_diagram" /></p>

<blockquote>
  <p>시퀀스 상단: OAuth 2.0 표준을 따르는 소셜 로그인 시퀀스 다이어그램<br />
시퀀스 하단: JWT 토큰의 유효기간이 끝났을 때의 시퀀스 다이어그램</p>
</blockquote>

<h3 id="시퀀스-설명">시퀀스 설명</h3>
<p>위 다이어그램과 같이 보길 권장한다.</p>
<ol>
  <li>유저 - 소셜 로그인을 요청</li>
  <li>프론트엔드 - 백엔드로 GET “/oauth2/authorization/{provider-id}?<br />
redirect_uri=http://localhost:3000/oauth/redirect”으로 OAuth 인가 요청</li>
  <li>백엔드 - Provider 별로 Authorization Code 인증을 할 수 있도록 리다이렉트 (Redirect: GET “https://oauth.provider.com/oauth2.0/authorize?…”)</li>
  <li>유저 - 리다이렉트 화면에서 provider 서비스에 로그인</li>
  <li>로그인이 완료된 후, Authorization server → 백엔드로 Authorization Code 응답</li>
  <li>백엔드 - Authorization Code를 이용해 Authorization Server에 Access Token 요청</li>
  <li>Authorization Server → 백엔드로 Access Token 응답</li>
  <li>백엔드 - Access Token을 활용하여 Resource Server에 User data 요청</li>
  <li>백엔드 - 획득한 User Data를 DB에 저장 후, JWT 액세스 토큰과 Refresh Token을 생성</li>
  <li>Refresh Token은 수정이 불가능한 쿠키에 저장하고, 액세스 토큰은 프론트엔드 리다이렉트 URI에 쿼리스트링에 토큰을 담아 리다이렉트 (Redirect: GET http://localhost:3000/oauth/redirect?token={jwt-token})</li>
  <li>프론트엔드에서 토큰을 저장 후, API 요청 시 헤더에 Authorization: Bearer {token}을 추가하여 요청</li>
  <li>백엔드에서는 토큰을 확인하여 권한 확인</li>
  <li>토큰이 만료된 경우, 쿠키에 저장된 리프레스 토큰을 이용하여 액세스 토큰과 리프레시 토큰을 발급</li>
</ol>

<h3 id="참고">참고</h3>
<ul>
  <li><a href="https://meetup.toast.com/posts/239">JWT를 소개합니다</a></li>
  <li><a href="https://deeplify.dev/back-end/spring/oauth2-social-login#%EC%B9%B4%EC%B9%B4%EC%98%A4-oauth-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%93%B1%EB%A1%9D">스프링부트 소셜 로그인</a></li>
  <li><a href="https://devansvd.com/oauth/">Demystifying OAuth 2.0 - A Tutorial &amp; Primer</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="java," /><category term="spring" /><category term="java" /><summary type="html"><![CDATA[Spring Boot 구조로 구성된 사이드 프로젝트에 적용 예정인 OAuth2 소셜로그인에 대해 정리하기위해 이 글을 쓰게 되었다.]]></summary></entry><entry><title type="html">[Spring] 좋은 객체 지향 설계의 5가지 원칙(SOLID)대로 개발하기</title><link href="https://icechoco.github.io/java,/spring/2022-05-09-SOLID/" rel="alternate" type="text/html" title="[Spring] 좋은 객체 지향 설계의 5가지 원칙(SOLID)대로 개발하기" /><published>2022-05-09T00:00:00+09:00</published><updated>2022-05-19T15:07:18+09:00</updated><id>https://icechoco.github.io/java,/spring/SOLID</id><content type="html" xml:base="https://icechoco.github.io/java,/spring/2022-05-09-SOLID/"><![CDATA[<p>사이드 프로젝트 개발을 본격적으로 들어가기 전, 객체 지향 설계를 위해서는 고려해야하는 SOLID 중 가장 중요한 DIP에 대해서 정리한다.<br />
그리고 정리한 개념을 기억하며 순수 Java로 Spring의 dependency 설정 도움 없이 구현을 해보고자 한다.<br />
이 과정을 통해 왜 Spring을 사용해야 하는지 알게 된 상태에서 Spring Boot 사용을 통해 개발하고자 함이 목적이다.</p>

<h2 id="좋은-객체-지향-설계의-5가지-원칙solid">좋은 객체 지향 설계의 5가지 원칙(SOLID)</h2>
<h3 id="dip-의존-관계-역전-원칙dependency-inversion-principle">DIP 의존 관계 역전 원칙(Dependency Inversion Principle)</h3>
<ul>
  <li>의존 관계 역전 원칙은 SOILD에서 가장 중요한 원칙 중 하나이다.</li>
  <li>프로그래머는 <strong>“추상화에 의존해야지, 구체화에 의존하면 안된다.”</strong> 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
    <ul>
      <li>Client Code가 구현체를 바라보는게 아니라 Interface만 바라봐라</li>
    </ul>
  </li>
  <li>즉, 역할에 의존해라</li>
  <li>그런데 OCP에서 설명한 MemberService는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존한다.</li>
</ul>

<h3 id="정리">정리</h3>
<ul>
  <li>객체 지향의 핵심은 다형성</li>
  <li>다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.</li>
  <li>다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.</li>
  <li><strong>다형성 만으로는 OCP, DIP를 지킬 수 없다.</strong></li>
  <li>뭔가 더 필요하다.</li>
</ul>

<h2 id="객체-지향-설계와-스프링">객체 지향 설계와 스프링</h2>
<p>Spring을 공부하다보면 왜 이렇게 객체 지향의 중요성에 대해 많이 이야기가 나오는 것일까? 그것은 <strong>스프링은 다음 기술로 다형성과 OCP, DIP</strong>를 가능하게 지원하기 때문이다.</p>
<ul>
  <li>DI(Dependency injection) : 의존관계, 의존성 주입</li>
  <li>DI 컨테이너 제공 : 자바 객체들을 컨테이너 안에 넣어어놓고 그 안에서 의존관계를 주입해주는 역할을 한다. 이것들을 활용하면 클라이언트의 변경 없이 개발이 가능하다.</li>
</ul>

<h3 id="정리-1">정리</h3>
<ul>
  <li>모든 설계에 역할과 구현을 분리하자
    <ul>
      <li>자동차, 공연의 예를 떠올려보자</li>
    </ul>
  </li>
  <li>어플리케이션 설계도 공연을 설계하듯이 배역만 만들어두고, 배우는 언제든지 <strong>유연</strong>하게 <strong>변경</strong>할 수 있도록 만드는 것이 좋은 객체 지향 설계다.</li>
  <li>이상적으로는 모든 설계에 인터페이스를 부여하자.</li>
</ul>

<p>하지만 실무적으로 고민해보자.</p>
<ul>
  <li>인터페이스를 도입하면 추상화라는 비용이 발생한다. 이말은 추상화를 하게 되면 개발자의 코드를 한 번 더 열어봐야 한다. 이것이 코드 추상화의 단점이다.</li>
  <li>그러므로 기능을 확장할 가능성이 없다면 처음에는 구현체로 하는 것도 좋다.</li>
</ul>

<h2 id="스프링의-핵심원리-이해----예제-만들기">스프링의 핵심원리 이해  - 예제 만들기</h2>
<h3 id="프로젝트-생성">프로젝트 생성</h3>
<ol>
  <li><a href="https://start.spring.io/">start.spring.io</a>에 접속한다</li>
  <li>아래와 같이 설정 후 Genereate 한다.
    <ul>
      <li>Project : Gradle Project</li>
      <li>Language: Java</li>
      <li>Spring Boot : 2.6.7 (정식 릴리즈 된 버전 중 가장 최신 버전)</li>
      <li>Project Metadata (여긴 Custom하게 자기가 설정하고 싶은 이름으로 설정하면 된다)
        <ul>
          <li>Group: hello</li>
          <li>Artifact : core</li>
          <li>Packaging : Jar</li>
          <li>Java : 11</li>
        </ul>
      </li>
      <li>Dependencies
        <ul>
          <li>Add Dependencies 클릭</li>
          <li><code class="language-plaintext highlighter-rouge">Spring Web</code>을 입력 한 후, <code class="language-plaintext highlighter-rouge">Spring Web</code>을 클릭해서 추가</li>
          <li>그 외 사이드 프로젝트에서 자신이 사용할 의존성 추가</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h3 id="core-프로젝트-살펴보기">core 프로젝트 살펴보기</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>📂 hello-spring // 루트 폴더
├─ gradle
│ ├── wrapper // Gralde을 쓰는 폴더
├─── 📂 src // java 소스 상위 폴더  
│ ├── 📂 main 
│ │ ├─── java      // 실제 패키지와 java 소스 파일들이 위치한 곳
│ │ ├─── resources // 실제 자바코드 파일을 제외한 어떤 xml이나 properties, HTML, application 설정파일 등의 리소스    
│ ├── test         // TestCode와 관련된 소스들이 위치한 곳
│ │ ├─── java      
│ │   ├─── hello.hellospring
│ ├── build.gradle // 버전 설정 및 라이브러리 가져오는 역할
├─ JRE System Library // 사용하는 Jaba Library
├─ Project and External Dependencies // Project에서 사용하는 외부 라이브러리
├─ 📂 bin // 빌드 후 실행 파일 등이 생성
├─ 📂 gralde // graldew가 사용하는 실행 파일
├─ build.gradle
├─ graldew // Gradle Wrapper 쉘 스크립트로 로컬에 따로 프로젝트에 선언된 Gradle 버전 설치 필요 없이 
│             자동으로 해당 OS 및 버전과 호환되는 Gradle 실행 파일을 다운받아서 프로젝트를 빌드할 수 있게 하는 일종의 유틸리티 도구
├─ gralde.bat // gradlew의 Windows 용 스크립트
├─ HELP.md // Gradle 도움말
├─ settings.gradle : 프로젝트의 Gradle 설정 파일
</code></pre></div></div>

<h3 id="gradlew를-이용한-빌드-및-실행">Gradlew를 이용한 빌드 및 실행</h3>
<ul>
  <li>파일 탐색기를 실행한다 (단축키 : <code class="language-plaintext highlighter-rouge">Windows+E</code>)</li>
  <li>내 프로젝트 경로로 이동한다. (나의 경우는 <code class="language-plaintext highlighter-rouge">C:\Ara\공부\YAPP\20th-Android-Team-2-BE-Personal-dev</code>로 이동)</li>
  <li>폴더 경로를 선택 후 <code class="language-plaintext highlighter-rouge">cmd</code>를 입력한 뒤 엔터키를 누른다.</li>
  <li>cmd 창에서 아래 명령을 실행한다.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gradlew tasks
</code></pre></div>    </div>
    <p>그럼 아래와 같은 결과가 출력된다. 중요한 것들은 ⭐ 표시한 아래 3가지이다.</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Starting a Gradle Daemon (subsequent builds will be faster)

&gt; Task :tasks

------------------------------------------------------------
Tasks runnable from root project 'bestFriend'
------------------------------------------------------------

Application tasks
-----------------
⭐ bootRun - Runs this project as a Spring Boot application.

Build tasks
-----------
assemble - Assembles the outputs of this project.
bootBuildImage - Builds an OCI image of the application using the output of the bootJar task
bootJar - Assembles an executable jar archive containing the main classes and their dependencies.
bootJarMainClassName - Resolves the name of the application's main class for the bootJar task.
bootRunMainClassName - Resolves the name of the application's main class for the bootRun task.
⭐ build - Assembles and tests this project.
buildDependents - Assembles and tests this project and all projects that depend on it.
buildNeeded - Assembles and tests this project and all projects it depends on.
classes - Assembles main classes.
clean - Deletes the build directory.
jar - Assembles a jar archive containing the main classes.
testClasses - Assembles test classes.

Build Setup tasks
-----------------
init - Initializes a new Gradle build.
wrapper - Generates Gradle wrapper files.

Documentation tasks
-------------------
javadoc - Generates Javadoc API documentation for the main source code.

Help tasks
----------
buildEnvironment - Displays all buildscript dependencies declared in root project 'bestFriend'.
dependencies - Displays all dependencies declared in root project 'bestFriend'.
dependencyInsight - Displays the insight into a specific dependency in root project 'bestFriend'.
dependencyManagement - Displays the dependency management declared in root project 'bestFriend'.
help - Displays a help message.
javaToolchains - Displays the detected java toolchains.
outgoingVariants - Displays the outgoing variants of root project 'bestFriend'.
projects - Displays the sub-projects of root project 'bestFriend'.
properties - Displays the properties of root project 'bestFriend'.
tasks - Displays the tasks runnable from root project 'bestFriend'.

Verification tasks
------------------
check - Runs all checks.
⭐ test - Runs the test suite.

Rules
-----
Pattern: clean&lt;TaskName&gt;: Cleans the output files of a task.
Pattern: build&lt;ConfigurationName&gt;: Assembles the artifacts of a configuration.

To see all tasks and more detail, run gradlew tasks --all

To see more detail about a task, run gradlew help --task &lt;task&gt;

BUILD SUCCESSFUL in 8s
1 actionable task: 1 executed
</code></pre></div></div>

<p>그럼 여기서 빌드를 수행해보자</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gradlew build
</code></pre></div></div>

<p>빙드가 성공했으면 <code class="language-plaintext highlighter-rouge">./build/libs</code> 아래에 jar 파일이 생성된다. 나중에 배포할 때 이 jar 파일을 서버에서 실행하면 웹서버까지 같이 띄워지기 떄문에 Tomcat을 따로 설정할 필요도 없으니 얼마나 간편한가!</p>

<h3 id="참고">참고</h3>
<ul>
  <li><a href="https://www.google.com/search?q=%EA%B5%AC%EA%B8%80%EB%B2%88%EC%97%AD%EA%B8%B0&amp;oq=&amp;aqs=chrome.0.35i39i362l8.1609134099j0j15&amp;sourceid=chrome&amp;ie=UTF-8">소트웍스 앤솔러지 - 규칙 8: 일급 콜렉션 사용</a></li>
</ul>]]></content><author><name>Ara cho(IceChoco)</name><email>dkfk2685@naver.com</email></author><category term="java," /><category term="spring" /><category term="java" /><summary type="html"><![CDATA[사이드 프로젝트 개발을 본격적으로 들어가기 전, 객체 지향 설계를 위해서는 고려해야하는 SOLID 중 가장 중요한 DIP에 대해서 정리한다. 그리고 정리한 개념을 기억하며 순수 Java로 Spring의 dependency 설정 도움 없이 구현을 해보고자 한다. 이 과정을 통해 왜 Spring을 사용해야 하는지 알게 된 상태에서 Spring Boot 사용을 통해 개발하고자 함이 목적이다.]]></summary></entry></feed>